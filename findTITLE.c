/* 980716 RJB
 \ Read datafiles generated by Cloud's record_XY routine. Files are scanned for
 \ multiple occurences of <pat1> and <pat2>; only files in which the last line
 \ containing <pat1> also contains <pat2> are selected (= names are echoed on stdout).
 \ stderr echoes more information.
 \ If the -C argument is given, also checks for multiple presentations of the same stimulus
 \ and appends " | presn <n> of <N>" to the line containing <pat1> and <pat2>, if this is not
 \ yet the case. With the -C argument a "*read_file*traces/<c>.xg" is prepended before the 1st
 \ *EXTRATEXT* statement following the data (<c> is the number of the stimulus, found by
 \ the pattern ("[...] cond <c> pres [...]" in the *TITLE*.
 \ Multiple patterns (no regexps) as in egrep can be specified with the -E option.
 */

#include <stdio.h>
#include <stdlib.h>

#include <string.h>

#include <local/defun.h>
#include <local/Macros.h>

IDENTIFY( "Read datafiles generated by Cloud's record_XY routine");

#include <sys/types.h>
#include <regex.h>

int buflen= 1024;

extern char *index(), *strdup();

Boolean rexps= False;

#define MAXHITS	256

typedef enum PatNo { P1, P2 } PatNo;

typedef struct PatStat{
	int pat_no;
	char *filename[MAXHITS];
	int hit_no, series[MAXHITS], presns[MAXHITS], pres_no[MAXHITS], line_no[MAXHITS], cond_no[MAXHITS], accepted, found;
	char match[MAXHITS][256];
	regex_t CPat2, *Pat2;
#ifdef DEBUG
	char pattern[128];
#endif
} PatStat;
	
PatStat *ps= NULL;

regex_t CPat1, CPat2, *Pat1= NULL, *Pat2= NULL;

char *re_strstr( regex_t *exp, char *pat )
{ char *c= pat;
  Boolean diff= True;
  int eflag= 0;
/* This code makes gcc 2.7.1 generate wrong code with full optimisations: (?)
	while( c && *c && (diff= regexec(exp, c, 0, NULL, eflag)) ){
		c++;
		eflag= REG_NOTBOL;
	}
 */
	while( c && *c && diff ){
		if( (diff= regexec(exp, c, 0, NULL, eflag)) ){
			c++;
			eflag= REG_NOTBOL;
		}
	}
	if( diff ){
		return( NULL );
	}
	else{
		return( c );
	}
}

int find_pat( char *buf, PatNo pnr, char *pat, int casesens, int extended, char **match )
{ char bb[buflen];
  char *c= buf, *d= bb;
  char *hitstr;
	if( !casesens ){
		while( *c ){
			*d++= toupper((*c++));
		}
		*d= '\0';
	}
	else{
		strcpy( bb, buf);
	}
	if( extended ){
	  char *pattern= strdup(pat);
	  int p= 1;
		c= pattern;
		do{
			if( (d= index( c, '|')) ){
				*d= '\0';
			}
			if( rexps ){
			  regex_t *Pat= NULL;
				if( pnr== P2 ){
					if( !ps[p-1].Pat2 ){
					  int err;
						if( (err=regcomp( &(ps[p-1].CPat2), c, REG_NOSUB)) ){
#ifdef sgi
						  char buf[1024];
							regerror( err, &(ps[p-1].CPat2), buf, 1024 );
							fprintf( stderr, "find_pat: can't compile pattern %d \"%s\": %s\n",
								p, c, buf
							);
#else
							fprintf( stderr, "find_pat: can't compile pattern %d \"%s\"\n",
								p, c
							);
#endif
							hitstr= NULL;
						}
						else{
							ps[p-1].Pat2= &(ps[p-1].CPat2);
#ifdef DEBUG
							strncpy( ps[p-1].pattern, c, 127 );
#endif
						}
					}
					Pat= ps[p-1].Pat2;
				}
				else{
					Pat= Pat1;
				}
				if( Pat ){
					hitstr= re_strstr( Pat, buf );
				}
			}
			else{
#ifdef DEBUG
				if( pnr== P2 ){
					strncpy( ps[p-1].pattern, c, 127 );
				}
#endif
				hitstr= strstr( buf, c );
			}
			if( hitstr ){
				if( match ){
					*match= strdup(c);
				}
				free(pattern);
				  /* return the ID of the pattern	*/
				return(p);
			}
			if( d ){
				*d= '|';
				c= &d[1];
				p+= 1;
			}
			else{
				c= NULL;
			}
		}
		while( c && *c );
		free(pattern);
	}
	else{
		if( rexps ){
			hitstr= re_strstr( (pnr==P1)? Pat1 : Pat2, buf );
		}
		else{
			hitstr= strstr( buf, pat);
		}
		if( hitstr ){
			return(1);
		}
	}
	return(0);
}

#ifndef MAX
#	define MAX(a,b)                (((a)>(b))?(a):(b))
#endif

char *pat1= NULL, *pat2= NULL;
int get_arguments= 1, casesens= 1, extended= 0, patterns, count_presns= 0, last_presn= 0, debug= 0;
Boolean read_pars= False;

int CleanUp()
{ int i;
	if( ps ){
		for( i= 0; i< patterns; i++ ){
			if( ps[i].Pat2 ){
				regfree( ps[i].Pat2 );
			}
		}
		free( ps );
	}
	if( pat1 ){
		free(pat1);
	}
	if( pat2 ){
		free(pat2);
	}
	if( Pat1 ){
		regfree( Pat1 );
	}
	if( Pat2 ){
		regfree( Pat2 );
	}
}

int GetPat1( const char *arg )
{ int err;
	pat1= strdup(arg);
	if( (err= regcomp( &CPat1, pat1, REG_NOSUB )) ){
#ifdef sgi
	  char buf[1024];
		regerror( err, &CPat1, buf, 1024 );
		fprintf( stderr, "findTITLE: can't regcompile 1st pattern \"%s\": %s\n",
			pat1, buf
		);
#else
		fprintf( stderr, "findTITLE: can't regcompile 1st pattern \"%s\"\n",
			pat1
		);
#endif
		CleanUp();
		exit(-1);
	}
	Pat1= &CPat1;
}

int GetPat2( const char *arg )
{ int err;
	pat2= strdup(arg);
	if( extended ){
	  char *d, *c= pat2;
	  int p= 1;
		do{
			if( (d= index( c, '|')) ){
				*d= '|';
				c= &d[1];
				p+= 1;
			}
			else{
				c= NULL;
			}
		}
		while( c && *c );
		patterns= p;
	}
	else{
		patterns= 1;
		if( (err= regcomp( &CPat2, pat2, REG_NOSUB )) ){
#ifdef sgi
		  char buf[1024];
			regerror( err, &CPat2, buf, 1024 );
			fprintf( stderr, "findTITLE: can't regcompile 2nd pattern \"%s\": %s\n",
				pat2, buf
			);
#else
			fprintf( stderr, "findTITLE: can't regcompile 2nd pattern \"%s\"\n",
				pat2
			);
#endif
			CleanUp();
			exit(-1);
		}
		Pat2= &CPat2;
	}
	if( !(ps= (PatStat*) calloc( patterns, sizeof(PatStat) )) ){
		fprintf( stderr, "findTITLE: can't allocate %d pattern buffers (%s)\n",
			patterns, serror()
		);
		CleanUp();
		exit(-1);
	}
}

int ParseArg( const char *c, Boolean getpats )
{
	if( strcmp( c, "-i")== 0 ){
		casesens= 0;
	}
	else if( strcmp( c, "-f")== 0 ){
		read_pars= True;
	}
	else if( strcmp( c, "-E")== 0 ){
		extended= 1;
	}
	else if( strcmp( c, "-C")== 0 ){
		count_presns= 1;
		rexps= 0;
	}
	else if( strcmp( c, "-R")== 0 ){
		rexps= 1;
		count_presns= 0;
	}
	else if( strcmp( c, "-last")== 0 ){
		last_presn= 1;
	}
	else if( strcmp( c, "-db")== 0 ){
		debug= 1;
	}
	else if( strcmp( c, "--")== 0 ){
		get_arguments= 0;
	}
	else if( strncmp( c, "-L", 2)== 0 ){
	  int l;
		if( (l= atoi( &c[2] ))> 0 ){
			buflen= l;
		}
	}
	else if( getpats && !(c[0]== '-' && get_arguments) ){
		if( !pat1 ){
			fprintf( stderr, " => pattern 1", c );
			GetPat1( c );
		}
		else if( !pat2 ){
			fprintf( stderr, " => pattern 2", c );
			GetPat2( c );
		}
	}
}

char *FGets( char *binbuf, char *cbuf, int *len, FILE *fp )
{ int rlen= 0;
  char *c;
	if( binbuf && cbuf && fp && len && *len ){
		if( (rlen= fread( binbuf, sizeof(char), *len, fp )) ){
		  int i= 0, nb= 0;
		  char *d;
			c= cbuf;
			d= binbuf;
			while( i< rlen ){
				if( (*c++ = *d++)== '\0' ){
					nb+= 1;
				}
				i+= 1;
			}
			if( i && c[-1]== '\0' && nb== 1 ){
			  /* read a line of C text	*/
				c= cbuf;
			}
			else if( rlen ){
			  /* read a string of binary characters	*/
				c= cbuf;
			}
			else{
			  /* Nothing read	*/
				c= NULL;
			}
		}
		else{
			c= NULL;
		}
	}
	else{
		c= NULL;
	}
	*len= rlen;
	return( c );
}

main( int argc, char *argv[] )
{ char *fn;
  FILE *fp;
  int i= 1;
  int hits= 0, series= 0;
  int last_pn, hitcount= 0;
	if( argc< 3 ){
		fprintf( stderr, "%s [-i|-R|-E|-C|-L<maxlinelen>|-f <fname>|--] <pat1> <pat2> file1 [file2...]\n", argv[0] );
		fprintf( stderr, "\tgives filenames in which the last line with <pat1> also has <pat2>\n" );
		fprintf( stderr, "\t-i: case-insensitive\n"
					"\t-E: multiple patterns, <pat> = '<pat1>|<pat2>|pat3'\n"
					"\t-R: allow Basic Regular Expressions (see regcomp(3))\n"
					"\t-C: count number of presentations, based on a template \"pres %%d \" in the string matching <pat1> and <pat2>\n"
					"\t\t-R and -C are mutually exclusive - only the last is taken into account\n"
					"\t-last: list only the file with the last presentation (cf. -C)\n"
					"\t-f <name>: read arguments from file <name>\n"
					"\t--: allow <pat1> to begin with a dash (-)\n"
		);
		exit(-1);
	}
	while( i< argc ){
		if( get_arguments && argv[i][0]== '-' ){
			ParseArg( argv[i], False);
		}
		else if( get_arguments && read_pars ){
		  FILE *fp;
			read_pars= False;
			if( (fp= fopen( argv[i], "r")) ){
			  char buf[buflen];
				while( get_arguments && fgets( buf, buflen, fp) && !feof(fp) && !ferror(fp) ){
					if( buf[strlen(buf)-1]== '\n' ){
						buf[strlen(buf)-1]= '\0';
					}
					fprintf( stderr, "\"%s\"", buf );
					ParseArg( buf, True );
					fputc( '\n', stderr );
				}
				fclose( fp );
			}
			else{
				fprintf( stderr, "findTITLE: can't open arguments-file \"%s\" (%s)\n",
					argv[i], serror()
				);
			}
		}
		else if( !pat1 ){
			GetPat1( argv[i] );
			get_arguments= 0;
		}
		else if( !pat2 ){
			GetPat2( argv[i] );
		}
		else{
		  char buf[buflen], last[buflen];
			if( (fp= fopen( (fn= argv[i]), "r")) ){
			  char *c;
			  int pn, hit= 0, ln= 0, hln, start_of_series= 0;
				c= fgets( buf, sizeof(buf)-1, fp );
				while( c && !feof(fp) && !ferror(fp) ){
					if( !start_of_series ){
						if( strstr( buf, "Start of Series") ){
							series+= 1;
							start_of_series= 1;
							if( last_presn ){
								fprintf( stderr, "\r%s ...%c[K", fn, 0x1b );
								fflush( stderr );
								for( pn= 0; pn< patterns; pn++ ){
									if( ps[pn].found ){
										ps[pn].accepted+= 1;
										ps[pn].found= 0;
									}
								}
							}
							else if( debug ){
								fprintf( stderr, "New series #%d \"%s\"\n", series, fn );
								fflush( stderr );
							}
							hitcount= 0;
						}
					}
					if( find_pat( buf, P1, pat1, casesens, extended, NULL) ){
						if( (pn= find_pat( buf, P2, pat2, casesens, extended, NULL )) ){
							last_pn= pn- 1;
							hln= ln;
							hit= 1;
							strcpy( last, buf);
						}
						else{
							hit= 0;
						}
					}
					c= fgets( buf, sizeof(buf)-1, fp );
					ln+= 1;
				}
				fclose(fp);
				if( hit ){
				  int hn;
				  int store_presn= !strstr( last, " | presn ");
					if( store_presn || last_presn ){
					  char *pres= strstr( last, "pres ");
					  int presn= 1;
						if( pres ){
							sscanf( pres, "pres %d ", &presn );
						}
						if( ps[last_pn].hit_no< MAXHITS ){
							hn= ps[last_pn].hit_no;
							if( ps[last_pn].filename[hn] ){
							  /* Should never happen!	*/
								free( ps[last_pn].filename[hn] );
							}
							ps[last_pn].filename[hn]= strdup(fn);
							ps[last_pn].line_no[hn]= hln;
							if( count_presns){
							  char *cnd= strstr( last, "cond ");
								if( cnd ){
									sscanf( cnd, "cond %d ", &(ps[last_pn].cond_no[hn]) );
								}
							}
							ps[last_pn].pres_no[hn]= presn;
							ps[last_pn].series[hn]= series;
							if( last_presn ){
								strncpy( ps[last_pn].match[hn], last, 255 );
								ps[last_pn].match[hn][255]= '\0';
								{ char *c= &ps[last_pn].match[hn][strlen(ps[last_pn].match[hn])-1];
									if( c && *c== '\n' ){
										*c= '\0';
									}
								}
							}
							else{
								ps[last_pn].accepted+= 1;
							}
							if( /* presn> ps[last_pn].presns[series] && */ debug ){
								fprintf( stderr, "fn=\"%s\" pr#=%d series=%d hn=%d presns[series]=%d presn=%d\n",
									fn, last_pn, series, hn, ps[last_pn].presns[series], presn
								);
								fflush( stderr );
							}
							ps[last_pn].presns[series]= MAX( presn, ps[last_pn].presns[series] );
							ps[last_pn].hit_no+= 1;
							ps[last_pn].found+= 1;
						}
					}
					fflush( stdout );
					fflush( stderr );
					hitcount+= 1;
					if( !last_presn ){
						fprintf( stdout, "%s", fn );
						fflush( stdout );
						if( isatty(fileno(stdout)) ){
							fputs( ":", stderr );
							if( store_presn ){
								fprintf( stderr, "[presn %d]", ps[last_pn].pres_no[hn] );
							}
							fprintf( stderr, "(%d) %s", hitcount, last);
							fflush( stderr );
						}
						else{
							fprintf( stderr, "%s:", fn );
							if( store_presn ){
								fprintf( stderr, "[presn %d]", ps[last_pn].pres_no[hn] );
							}
							fprintf( stderr, "%s", last );
							fflush( stderr );
							fputc( '\n', stdout );
						}
						fflush( stdout );
					}
					else{
						fprintf( stderr, " (%d)", hitcount );
						fflush( stderr );
					}
					hits+= 1;
				}
			}
			else{
				perror( fn);
			}
		}
		i+= 1;
	}
	if( last_presn ){
		fprintf( stderr, "\r" );
		fflush( stderr );
		for( i= 0; i< patterns; i++ ){
			if( ps[i].found ){
				ps[i].accepted+= 1;
				ps[i].found= 0;
			}
		}
	}
	if( count_presns || last_presn ){
	  int j, hn;
	  FILE *fp;
	  char buf[buflen], *c;
		for( i= 0; i< patterns; i++ ){
			if( (hn= ps[i].hit_no) ){
				fprintf( stderr, "Pattern #%d: %d of %d hits\n", i, ps[i].accepted, hn );
				for( j= 0; j< hn; j++ ){
				  char pfx[8];
				  FILE *tfp;
				  extern char *rindex();
				  char *tfn, *bn= rindex( ps[i].filename[j], '/');
				  int different= 0;
					if( last_presn ){
						series= ps[i].series[j];
						if( ps[i].presns[series]<= 1 || ps[i].pres_no[j] == ps[i].presns[series] ){
						  char *fn= ps[i].filename[j];
							fprintf( stdout, "%s", fn );
							fflush( stdout );
							if( isatty(fileno(stdout)) ){
								fputs( ":", stderr );
								fprintf( stderr, "%s", ps[i].match[j] );
								fprintf( stderr, " [presn %d of %d]\n", ps[i].pres_no[j], ps[i].presns[series] );
								fflush( stderr );
							}
							else{
								fprintf( stderr, "%s:", fn );
								fprintf( stderr, "%s", ps[i].match[j] );
								fprintf( stderr, " [presn %d of %d]\n", ps[i].pres_no[j], ps[i].presns[series] );
								fflush( stderr );
								fputc( '\n', stdout );
							}
							fflush( stdout );
						}
						if( !count_presns ){
							goto next_file;
						}
					}
					strncpy( pfx, (bn)? bn : ps[i].filename[j], 5);
					tfn= tempnam(NULL, pfx);
					tfp= fopen( tfn, "w");
					if( (fp= fopen( ps[i].filename[j], "r")) && tfp ){
					  int ln= 0;
					  char readfile[256];
						series= ps[i].series[j];
						sprintf( readfile, "*read_file*traces/%d.xg", ps[i].cond_no[j] );
						c= fgets( buf, buflen, fp );
						while( c && *c && !feof(fp) && !ferror(fp) && !ferror(tfp) ){
							if( readfile[0] && strncmp( buf, readfile, strlen(readfile))== 0 ){
								readfile[0]= '\0';
							}
							if( ln== ps[i].line_no[j] ){
								if( readfile[0] ){
									fprintf( tfp, "%s\n\n", readfile );
									fflush( tfp );
									readfile[0]= '\0';
									different+= 1;
								}
								c= buf;
								while( *c && *c!= '\n' ){
									putc( *c++, tfp );
								}
								if( ps[i].presns[series]> 1 ){
									fprintf( tfp, " | presn %d of %d ", ps[i].pres_no[j], ps[i].presns[series] );
									different+= 1;
								}
								if( *c== '\n' ){
									putc( *c, tfp );
								}
								fflush( tfp );
							}
							else{
								fputs( buf, tfp );
							}
							c= fgets( buf, buflen, fp );
							ln+= 1;
						}
						fclose(fp);
						if( !ferror(tfp) ){
							if( !fclose(tfp) ){
								if( different ){
									if( rename( tfn, ps[i].filename[j] ) ){
										perror( "Error moving tempfile to sourcefile" );
									}
									else{
										fprintf( stderr, "%s updated with %d changes\n", ps[i].filename[j], different );
									}
								}
								else{
									unlink( tfn );
									fprintf( stderr, "%s not changed\n", ps[i].filename[j] );
								}
							}
							else{
								perror( "Error on temp file" );
							}
						}
						else{
							perror( "Error on temp file" );
							fclose(tfp);
							perror( "Error on temp file" );
						}
					}
					else{
						if( !fp ){
							perror( ps[i].filename[j] );
						}
						else{
							perror( "Can't open temp file for storage");
						}
					}
next_file:;
				}
			}
		}
	}
	CleanUp();
	if( hits ){
		exit(0);
	}
	else{
		exit(2);
	}
}
