.TH XGRAPH 1,RJB "20030227" "A manual attempt ;^)"
.SH NAME
xgraph,x-plot,X-plot,XGraph \- Draw a graph on an X11 Display
.SH SYNOPSIS
.TP
.B xgraph
[ options ] [ =WxH+X+Y ] [ -display host:display.screen ] [ file ... ]
.TP
.B x-plot
<xcol>,<ycol>[,<dycol>] [x-plot options] [xgraph options] -f|-F <filename(s)>
.TP
.B X-plot
[X-plot options] [xgraph options] -file|-File <filename(s)> -xcol <xcol> -ycol <ycol>[,<dycol>] [<ycol>[,<dycol>]..]
.TP
.B XGraph [-unique|-pid]
\-|<filename(s)>
.TP
.SH DESCRIPTION
The 
.I xgraph
programme draws a graph on an X display given data read from either
data files or from standard input if no files are specified.
It can display a number (limited only by memory) of independent data sets using different colours
and/or plotsymbols and/or line styles for each set.
Initially, 128 sets are allocated (or as many as specified with the
\fB-maxsets\fP option), but storage space is doubled each time it is necessary.
Errors can be displayed as standard bars; as two triangles with their
tip in the datapoint, or as boxes (rectangles with height proportional to the
error). All these are drawn in their own linestyle, which is by default is equal
to the linestyle of the dataset; the width is either a global (settable) default,
or can be specified per set. It is also possible to connect the low and high
ranges with lines (in the dataset's linestyle), thereby creating an \fIerror region\fP, or
to interprete the "error" values as intensities (indices in a colour lookup table) or as
marker sizes.
A rather unusual option is the \fBvector\fP (formerly called vanity) mode: in this mode, the data in the Error columns are taken to
represent an orientation (\fBa\fP), and at each point a vector is drawn at angle \fBa\fP to
the positive X-axis. Currently, two modes are possible: one in which the vector starts in the datapoint (type 0), and
a 2nd (type 1) in which (by default) the datapoint is at 1/3 of the vector, with 1/3 pointing in the direction
of the orientation, and the remaining 2/3 in the opposite direction. In this mode, an arrow-head is drawn on the
"hot" end; the arrow is (by default) 1/5 of the vector's length. Specifying a negative vector length effectively
makes the vector point in the opposite directory.
A last possibility: that no errors be shown.

.I xgraph
annotates the graph with a title,  axis labels,  grid lines or tick
marks, grid labels,  
and a legend.
There are options to control the appearance of most components of
the graph. With most window managers, xgraph's windows display a certain amount of useful information
in their titlebars:

\fIXG[g] <window.serial.number> [mode] x/y=<data-aspectratio>:<plotwindow-aspectratio> <printfilename or inputfilename> <Yname> +- <Ename> vs. <Xname> <which> [<last redraw time per redraw>;<number of redraws>] $=<process id> "<read buffer>"\fP

The \fImode\fP switch shows whether xgraph is in normal mode (nothing shown), or
in \fBraw_display\fP, \fBquick\fP and/or \fBsilenced\fP mode. The first word is \fBXG\fP or \fBXGg\fP, when
in \fBTrueGray\fP mode. The \fBwhich\fP field shows either the number of the
drawn set (if only 1 is drawn), or a display that shows how many sets were drawn, of how many
to be drawn, of how many sets total.

.PP
XGraph can handle a small variety of input formats, ranging from just 1 to 3 whitespace
separated columns of numbers, through the ancient \fIgraph(1G)\fP format, to "full-featured"
executable dumps. Let us first have a look at a sample inputfile that \fIgraph\fP could also read -- partly.

The data consists of a number of
.I "data sets."
Data sets are separated by a blank line.
A new data set is also
assumed at the start of each input file.
A data set consists of an ordered list of points of the form "X Y" or "X Y Error", the
numbers being separated by whitespace.
Each point must appear on a separate line.  
The name of a data set can be specified by a line which begins
with a double quote followed by the set name.
An example input file with four data sets is shown below. Note
set three is not named. Set 4 demonstrates some hopefully useful behaviour.
Set 5 has only one column: the datapoints' "serial number" (index) will be used as the X values:
.sp 1
.nf
0.5 7.8
1.0 6.2
"set one
1.5 8.9

"set two
-3.4 1.4e-3
-2.0 1.9e-2
-0.65 2.2e-4

2.2 12.8 0.1
2.4 -3.3 0.2
2.6 -32.2 0.4
2.8 -10.3 0.05

"sample data showing immunity to Inf (IEEE)
-Inf	0
0	1
1	Inf
2	1
Inf	0
2	-1
1	-Inf
0	-1
-Inf	0

"set listing only Y values
4
3
2
1

.fi
.PP
Xgraph recognises Inf, -Inf, NaN, ++ or +.+ (Inf) and --- or --.- (-Inf). Such data
points are displayed at infinity in the appropriate direction (i.e. never within
the plotting window). (Inf,Inf) is connected to the previous point by a diagonal (45 degrees
at aspect ratio 1) linesegment; (Inf,other) by a horizontal linesegment. When one of the coordinates
of the bounding box is Inf/-Inf, it is substituted by DBL_MAX/-DBL_MAX (+- 1.7976931348623157E+308 for
8byte IEEE floats).
.PP
Contrary to \fIgraph(1G)\fP, xgraph can actually be instructed to read any number of columns. However, it remains a 2D
graphing programme, so it will always
use only 3 columns (to be specified per dataset) for displaying, no matter how the 3rd column is interpreted.
Input data can also be in binary format. This allows for
much faster I/O, but can create larger files (depending on the data and on the platform's floatingpoint size),
and result in platform-dependent files. Generally, IEEE doubles should be exchangeable without too much hassle, but
I never checked this beyond the Silicon Graphics (TM), HP (TM) and Linux-i686 workstations that I have access to, and 4byte float
file generated with Turbo Pascal (TM) on an Intel PC (using endian conversion). For the binary format,
see below under \fB*BINARYDATA*\fP.
.PP
After
.I xgraph
has read the data,  it will create a new window to graphically
display the data.
The interface used to specify the size and location of this window follows X conventions, but
ultimately depends on the window manager currently in use.
Refer to the reference manual of the window manager for details.
.PP
Once the window has been opened,  all of the data sets will be displayed
graphically (subject to the options explained below) with a legend and a number of buttons in 
the upper right corner of the screen.
To zoom in on a portion of the graph, press a mouse button in
the window and sweep out a region.
.I xgraph
will then open a new window looking at just that portion of the graph (if runtime transformations are
being performed, this may not work: see below). When the zoom is performed with the 2nd (middle) button,
the print/hardcopy dialog will be opened for the new window. When the zoom is performed with the 3rd (right)
button, the zoom will take place inside the current window (no new window is opened).
If the
.B Control
button is pressed while zooming,
.I xgraph
will close the original window. In all cases, padding will be applied to the selected zoom region, unless padding
is not active (controlled via the \fB[User]\fP button in the Settings Dialog).
.I Xgraph
also presents a number of control buttons in the upper right corner of
each window:
.B Shht
(a button with an "iron cross")
.B Label
(a button with a pencil)
.B Info
(a button with a spider)
.B Settings
(a button with a question mark,
.I or a watch when drawing),
.B Hardcopy
(a button with a spraycan),
.B Close
(a button with a skull), and a row of buttons with cryptic texts, which is/are discussed in the section on
\fBaveraging\fP.
.IP "Close button"
Windows are closed by depressing a mouse button while the mouse
cursor is inside the
.I Close
button.  Typing EOF (control-D) in a window also closes that window, or any Dialog windows
associated with it.
.IP "Hardcopy button"
This button causes a dialog to appear asking about Hardcopy (printout)
options. 
.IP "Settings button"
Clicking this button (or typing 's') calls up the Settings Dialog. This
button animates a heart (as far as possible) when a redraw is in progress.
.IP "Info button"
This button (or typing 'i') pops up a window with file names and comments/information
found in those files.
.IP "Label button"
This button (or entering \fBMod1-l\fP) (de)activates the "User Label entry mode". In this mode, the first mouse-click in
the graph defines the arrow-side of a User Label;
.B xgraph
now shows a single line connected to the pointer. Releasing the button defines the (centre of the)
label-side: a text-entry dialog is opened, into which a
label text can be entered. When the \fBcontrol\fPkey is depressed when releasing the mouse button, the newly
created label is linked to the set which contains a point closest to the arrow-side of the label. And when
the \fBshift\fPkey is pressed when clicking the button (or hitting \fBMod1-l\fP), the label is linked either to
1) \fBall\fP marked sets, when they're all being shown; or 2) to all highlighted sets when they're being
shown; 3) to the case that none of the marked sets are shown; or 4) to the case that none of the highlighted
sets are shown. (This option can also be activated by Shift-clicking the label button.)
A label can also be created by control-clicking the 3rd (right) mousebutton.
When the controlkey is still held when the mousebutton is released, the first point entered is replaced
by the coordinates of the nearest data-point of a displayed set,
and the label-text gives the name of the set to which this point (\fBpnr\fP) belongs, and its coordinates. This text
is updated to always show the actual co-ordinate values, as long as the text is not changed through
the Settings Dialog (which would set \fBpnr\fP to -1; see under the \fB*ULABEL*\fP file-command).
This dialog also allows to link a set to a point \fIn\fP: if this point is valid, and the labeltext 
contains the pattern "#n: ", the label becomes "dynamic".
User labels created in raw mode retain their position relative to the true origin (and datapoints)
regardless of runtime transformations, those entered in non-raw mode end up in a different location
when a different transformation applies.
A label with two identical coordinate-pairs is drawn without a box surrounding it: all other labels
show a dot to indicate the labelled (first) point, a frame (box) around the text, and a line connecting
frame and dot. These attributes are all drawn in the ZeroColor (-zg) colour when the label's colour-spec is
of type \fIdefault\fP, the linked-to set's colour for colour-spec \fIlinked\fP, or the label's colour
in other cases.
.I Cursor up/down
accepts the text. When the button is Mod1-clicked, behaviour is different. It will scan for \fIexisting\fP
labels which have their arrow-point inside the plotting region, and the text-box co-ordinates outside
that region. Such labels are clipped to the plotting region: the text box is placed at the nearest
plotting-border.
The line width used in drawing the labels can be specified via the \fBlWidth\fP button on the text input dialog for entering
the label text.
User labels can also take the form of simple horizontal or vertical lines that span the entire width/height of the plotting
window. For these labels, only the co-ordinates of the 'selected' (clicked) point are stored and used. This type of label
can be selected using the \fBtype\fP button on the aforementioned text input dialog. These line labels can be displaced/selected
just as other labels.
More information below, under
.B *ULABEL*
.TP
.IP "Shht button"
Switches xgraph to "silent" mode, in which the display is almost completely de-activated. In this way,
one can e.g. forget about too small drawing regions. Also, all events but key-presses are ignored, making
it an ideal mode for doing large processing batches.
.PP
These buttons can be hidden/unhidden by typing
.B g
in a window.
.PP

.SH SETTINGS DIALOG
This dialog allows for changing most of the display/processing options. Most, if not all or even more,
of the functionality that can be controlled with it is described below. Almost all control widgets provide some
information on the function they perform when one control-clicks on them (click with the Control key depressed). I
will thus not discuss each and every item in this place.

XGraph uses its own simple toolbox, xtb. This is a lightweight toolbox, providing the most often used, simple control widgets.
It is based on X11 only. It provides buttons, button rows (similar to radio buttons) sliders, text input and text output fields.
All these fields can be enabled, or disabled (in the latter case, they appear "stippled").
Text fields are always single line, and capable of displaying 2 fonts. Text and the cursor can be shifted, but it is not yet
possible to click somewhere in the text to position the cursor. On the other hand, it is possible to control-click to bring
up a popup that shows the text properly formatted over multiple lines if appropriate. Clicking on a line of text will in that
case position the cursor at the beginning of that line. (Note that several such input fields have a button associated with them
that will call up an editor for advanced editing). Clicking once in the text will assign input focus to the field: this is
indicated by the text being drawn in reverse (which is thus not an indication of selection!). In the dialogs, numerical input
fields allow increment/decrement with the cursor up/down keys.
Buttons have the usual behaviour: clicking on them changes their state. However, there are buttons that will invoke some
action (like closing the dialog, or redrawing the window), and then return to their inactive state. There are also buttons
that flip a state, and remain in their new position, like (old-fashioned) push-buttons. In the default colouring scheme,
pushed (activated) buttons appear recessed, and their text is rendered in a dark colour. In addition to this main state
(active/inactive), xtb buttons provide an additional state indicator. Sometimes, it happens that a button controls the
function of, say, a text input field. Let's assume that the alternative function of a text-input field allows to assign
a label to something, and that it is desirable to know whether or not a label has been assigned even when the text-input field
displays its principal function. In that case, one can toggle the button's secondary state. If this is done, the button's 
"shadow" (which creates the depth effect) changes from black to dark red.

The window is sized such that its elements (the placement of which is determined on the fly) fit.
The size of a few of the text-entry elements (fields) can change
as needed. Shrinking is usually handled automatically, expansion can be induced by resizing the window, when 
needed.

Always visible is a horizontal slider control that can be used to select a set, a UserLabel, one of the processing
stages, etc. The central (set-number) window just right of it allows the same, but also allows
to enter negative/symbolic values which select other editables such as X and Y labels, processing routines, etc. The slider
can be controlled with the cursor-left/right keys, the set-number window with the cursor-up/down keys; just as all other
text-input fields editing numerical values. Finally, there is a button-with-three-dots (ellipsis): clicking this will
popup a very simple menu giving direct access to a certain number of predefined entries.

Buttons can be pressed with any mouse-button, and text-input fields can be activated by hovering the mouse over them,
or by clicking in them (gives them the focus). Buttons can also be selected by holding the Control and Mod1 keys, and pressing
any other alphanumerical key. This will cycle the focus through buttons the name of which commences with the entered key (NB:
since the Mod1 key is pressed, behaviour is (mostly) similar to Mod1-clicking the button). The order in which matching buttons
are cycled depends on the order in which they have been (internally) defined... A selected button can be flipped with
Control-Mod1-Return. Pressing the F4 function key removes focus from the window it is currently assigned to. This restores
the focus-follows-mouse behaviour that I personally prefer.
Concerning text-input focus: the "cursor" is controlled with the cursor-left/right/home/end keys,
and pressing the TAB key will accept the current input and jump to (focus on) some next field. Escape backs up without accepting. For
the set-number window, pressing TAB will pass the other relevant set-spec. editables, to end up at the other large text-input
window which can edit several options depending on the button-row to its left. Pressing TAB in this field returns the focus
to the set-number window, and increments its value. From this window, it is also possible to directly jump to the multi-purpose
window by pressing Control-TAB (pressing TAB somewhere in the Settings dialog takes you to the set-number window).
The multi-purpose (m-p) entry field can (amongst others) edit a set's legend, title, \fB*SET_PROCESS*\fP procedure, its associations,
and edit its colour and highlighting colour. The m-p's width is adapted to the maximum width of the information to be edited.
A text-line just above shows (part of) the value for the previous multi-purpose
selection (e.g. the title when the m-p field's previous function was title-editing). For non-sets, most of those m-p selections
are non-defined, thus the m-p field behaves independently of the m-p selection.
Note that upon first opening the Settings dialog the m-p selection
is made which gives the smallest non-zero width to the m-p window.

The control elements are grouped into those that apply to individual sets, and those that apply to global graph settings
(regardless of whether they apply to all currently open graphs, or only to the one that the Dialog is attached to).
By default, the Settings dialog will open showing all controls: there are lots of them. If you have a large screen and
good eyes (= use a small dialog font), you can probably use this configuration all the time, since it allows the fastest
operation one you know you're way around. Alternatively, there is a button row just under the dialog's title, that allows
subselections to be shown, much like the tabs known from various GUIs. Thus, you can select the controls from either one
of the aforementioned groups, or all, or none (which actually means to display only a very selected few). The window
will be resized as necessary. Deselecting one of the group buttons will switch back to all controls display.
I think of this as a mouse friendly solution - it doesn't have to run so much back and forth all the time :)

Many of the usage details given above apply to the other dialog windows too!

.SH HARDCOPY DIALOG
The hardcopy dialog window has the following fields:
.IP "Output device"
Specifies the type of the output device (e.g. "HPGL", "Postscript", etc).
An output device is chosen by depressing the mouse inside its name.
The default values of other fields will change when you select a
different output device.
.IP "Output to"
Specifies whether the output should go directly to a device
or to a file.  Again,  the default values of other fields will change
when you select a different disposition.
.IP "Work Dir & File/Device/Command"
Contains 2 input fields. The upper one specifies the current working directory. The
lower one, the name of the file, device or command that the output should go to.
If the "Output to" is "To Device" or "PS Preview", this field specifies a
.I UNIX pipe,
e.g.
.B cat - > /dev/postscript
or \fBxgraph.pspreview\fP.
With either of these two, you can e.g. create a .pdf version of your graph with the command
\fB ps2pdf " -" <outfilename>\fP. Note the <space>- between double quotes to force the ghostscript
5.5 ps2pdf command to accept standard input instead of a file. In ghostscript 6.01 this is no longer
necessary.
\fBxgraph.pspreview\fP takes a single optional argument, \fB-sc\fP (or -strip-comments or --strip-comments). This
removes all PostScript comments from the pipe. This may prevent \fIgv\fP (v 3.5.8) from crashing sometimes...

If the disposition is "Append File" or "New File", (the difference is clear)
this field specifies the name of the output file. Appending
.B .gz
to a filename causes the output to be piped through
.B gzip -9v >> <filename>
or
.B gzip -9v > <filename>
respectively. Similarly, appending \fB.bz2\fP will pipe through the bzip2 command; \fB.rar\fP will cause a RAR archive
to be created, containing a single file.
In all cases, the outputfile is locked (through
.I lockf(2))
to prevent multiple instanteneous writes to it. Truncation of an existing
file (when "New File" has been selected) takes place only after obtaining
the lock. Obtaining a lock can take some time! (This is indicated in the
titlebar of the Hardcopy dialog.)
Filenames are not allowed to contain spaces: this is to be able to export them without
elaborated quoting "regimes" through either the environment, or some shell's parser (or both..). (Spaces are removed when necessary,
but can be entered as they may be needed in some cases.)
Finally, even when sending output to a file, it is possible to specify a viewing command which will be invoked after successfull
completion of the output. A pattern of the form \fIname | command\fP will create or append to the file <name>, and then invoke
the command \fIcommand < name\fP. Note that the 'opcode' to activate this functionality is \fI | \fP (a vertical bar/pipe-symbol
surrounded by two spaces): additional spaces are \fBnot\fP removed. This option is necessary because not all functionality is
compatible with streamed output feeding directly into a rendering command (like the PostScript version of the AllWin feature).
.IP "Maximum Dimensions"
This specifies the maximum size of the plot on the hardcopy
device in centimeters. When requested (the \fBAspect\fP button),
.I xgraph
takes in account the aspect ratio of the plot on the screen,
and, based on the specified height, will scale the plot's width.
If the device supports it,  the plot may also be rotated on the page
based on specified orientation, Landscape or Portrait.
.IP "Size"
Adjusts the (screen) window to approximately the requested print dimensions.
This supposes that the X server doesn't ly about the screen's metric dimensions.
.IP "Aspect"
Tells xgraph to preserve the plot's aspect ratio (as it is onscreen) by adjusting
the selected width (which will be updated).
.IP "AllWin"
\fIWhen dumping XGraph code\fP:
Tells xgraph that it should output code that will restore all windows currently open. The stacking order will probably
be (quite) different, because X does not provide a means to determine it. Similarly, the complex parentage structure
that xgraph maintains will not be fully restored: it will become a single line heritage, where each new window will
parent the next opened window. This can have repercussions on cross-references like those by \fB*CROSS_FROMWIN_PROCESS*\fP.
An "AllWindows" file is first parsed once to read in all data, and then installs itself as a script file. Thus, it will
read itself once more when the first (root; 0:0:0) window is opened, but now skipping over all data definitions to the
section that will restore the other windows. Pass the \fB-NoIncludes\fP option to prevent that from happening.
\fIWhen dumping PostScript\fP:
All currently open windows are printed in the specified file, in an N-Up column-major layout that can be specified by Mod1-Clicking
the \fIAllWin\fP button. Evidently, this can take a while, esp. when (batch-mode) \fIGS\fP text size determination is in use. Care
has been taken to provide sufficient feedback (via the hardcopy dialog's window titlebar, and the OK button itself) to avoid user
actions that would modify the contents of the graph-being-printed, before the dump is finished.
Additional parameters that can be specified in this dialog allow to ensure preservation of aspect (1:1) and an automated scaler
which decreases the specified sizes and increases the PostScript scale by the same factor. This only has a side-effect on the
font sizes, but otherwise prevents problems that can occur through the aspect preservation (which works by \fIincreasing\fP the
height or width in order to accomodate an NxN layout instead of the specified NxM one; too large dimensions cause (internal)
errors in the generated PostScript).
String format: N x M [1:1 *scale]
.IP 1st Size
For PostScript windows: use size information from the last hardcopy output (the button is thus mis-named). Currently, this
ensures that the plot area of all following graphs is identical to that of the last graph
printed without this option. No sanity checking is performed, so activating this for the very first postscript output will
generate a lot of error messages. 
Also note that some text may fall off the printed page. PSize (see below) won't correct for this, but
this problem is moot when importing the result in e.g.  Adobe Illustrator for further editing.
.IP "Subset"
Clicking this button opens a dialog.
To print/save any <n> sets in as many files as necessary, enter
a value <n> in this dialog. In the filename, the first printf(2)
format field (e.g. %03d) will then be replaced by the file sequential number
starting at 0.
Hence, n=1 will cause all datasets to be printed/saved in separate files.
A value n<=0 will deactivate this feature (as shown by the button's state).
An interaction exists with the \fBXGStrip\fP feature. When that feature is set, the dumped sets are selected from
among those currently displayed, otherwise, the full collection of datasets is used. This is the same regardless
the output device (Postscript or other) selected. Hence, to obtain similar dumping behaviour with or without
subsetting for the Postscript device, XGStrip must be set (it is ignored when subsetting is not active).
NB: No check is made against multiple printf() format fields!
.IP "PS Page ##"
.IP "PS Settings"
Context-sensitive button: available in PostScript respectively XGraph dump mode.
In the first case, it shows the PS pagenumber, which can be reset to 1 by pressing
the button. In the latter case, it allows the \fB-XGDump_PrintPars\fP switch (which allows
printer-settings to be saved) to be (un)set.
.IP "PS fields:"
marker base size, marker increment size,
scale in percents (relative to dimensions specified), horizontal and vertical position
on the paper, the orientation (\fBP\fPortrait or \fBL\fPandscape), and whether or not a
\fBshowpage\fP (PostScript "print and eject paper") should be appended to the output.
Presently, 16 markers are defined internally. For PS dumps, this can be augmented according to your heart's desire
by setting an env. var XG_PS_MARKSFILE to point to the desired file. See the file \fPXgraph.psMarkers\fP
for general formatting hints. PS markers are named \fBMn\fP where n is a serial number.. and expect
an X, Y and size argument on the stack. Note that this file can also be used to change other default
settings (linejoin, linecap, etc.); after its inclusion, the main body of the figure comes.
.IP Page
Unset to avoid adding a \fIshowpage\fP command to PostScript output. Has no effect when EPS is generated.
.IP PSize
Output some PostScript code that will set the 'paper' to the graph's size. This can be handy when generating a PDF figure from
the PostScript.
.IP EPS
Generate Encapsulated PostScript instead of 'regular' PostScript. Notably, this means that the graph's origin is set at the paper's
origin, and that the \fIstatusdict\fP command is not used. Of course, EPS files are supposed to contain only a single figure/page,
so no showpage is written.
.IP DSC
Output PostScript comments to conform to the Document Structuring Convention, notably info about page numbers and totals, etc. An
attempt is also made to compute the \fIBoundingBox\fP, and to write it in the EPS header (= not at the end). This requires the graph
to be printed twice, so this feature is (largely) deactivated when the output is not to a file but to a pipe (= directly to a
command).
.IP "X Font size"
Tells xgraph to assume that the X11 fonts used for onscreen plotting correspond
to the fonts selected for PostScript printing, and to use their dimensions to determine
the width of strings (instead of some font-dependent average character width). In any case, an
estimation of the character width is made, an estimator (EST) times the virtual resolution (1200 dpi)
divided by PostScript's "internal" resolution (72 dots to an inch). This estimator is supposed to
allow a reasonable width approximation for strings in variable width fonts, and can be changed
with the \fB-ps_fest\fP option, or by \fB<Mod1>\fP clicking on this button. The default value
(0.675) works OK with the font I usually use (Palatino-Bold, between 10pt and 24pt approx.). For
LucidaSans-DemiItalic, use 0.74 .
This option must be on (in fact, it can only be turned off with this button) to allow the use
of GhostScript to determine the postscript widths of strings (the [GS] button).
.IP "GS"
Use GhostScript to determine the width of strings in PostScript dumps. When this option is set,
a small PostScript programme is generated for each string of which the printing width must be known.
This is evaluated using gs (which must be in your path), which will print the string's actual width
given the current resolution, scaling, PostScript includes, etc. This is of course a slow process, so a cache is built
of all strings/font/pointsize combinations evaluated. In addition, when the command <Mod1>-g is given,
all currently relevant, unknown widths are determined in a single batch process (a single gs invocation). For
this, a postscript dump is sent to \fI/dev/null\fP. Another way to do this is to pass the \fB-gs_twidth_batch\fP
option, or set \fB$gsTextWidthBatch\fP to True. In that case, the batch dump is done each time the hardcopy
dialog is invoked (opened or brought to the front via XGraph). Another option is to set \fBAuto_gsTextWidthBatch\fP
(or \fB-gs_twidth_auto\fP, or by <Mod1> clicking the [GS] button).
With this option set (default), XGraph will do the batch recursively each time a
PostScript dump is to be made and the [Done] button in the Hardcopy dialog is not set.
When gs can't find a font in its path, it will
normally substitute a default font for it, and determine the width in that font. There is little
to be done about that; at least, previewing using gs will give correct results :) In this mode, the EST
estimator described above is (largely) ignored.
The GS and auto_gsTextWidth options are on by default.

One could ask why use this solution. The reason is simple: it is far easier than implementing support for .afm 
files and/or determining font metrics from postscript fonts, which would be necessary if afm files are not
available. And determining font metrics from postscript fonts would require Ghostscript or writing a Type1 font parser...
It is also more elegant: now, Ghostscript functions as a printing driver, making it possible to use "centrally
installed" Type1 and TrueType
fonts both on screen (thanks to the X11 server), in screen previews (thanks to Ghostscript alone)
and on a printer (thanks to Ghostscript's ps2pdf).
.IP "Scale Plot Area"
Tells xgraph to scale only the plotting area (excluding the space taken by title, legends and labels)
to the desired width
.IP "Info"
Add extra page(s) containing the text "under" the
.B Info
button. Rather dumb text-to-PostScript (yes; PS only..) routine that does no line-wrapping.
.IP "Sort Sheet"
Whether or not to sort the X-values in a "SpreadSheet" or "Cricket" dump. Opposite of the
.B -nosort
option
.IP "Complete"
Selected by default; ensures that an XGraph dump will contain all the necessary information to
re-create the dumped window as well as possible. When de-selected, only set-data (datapoints) and
set-headers are dumped, which can be useful to generate "include" files that can be read into another
xgraph instance without messing with its settings.
If in addition the \fB-really_incomplete\fP command line argument was given, 'incomplete' XGraph dumping is
really incomplete: only the data values are dumped, the sets' \fB*LABELS*\fP, and any \fB*SPLIT*\fP that
are defined. The Complete button shows the state of the \fBreally_incomplete\fP flag by its background colour.
.IP "XGBounds"
Whether or not to include the current bounding box (axes min/max) in an XGraph dump.
.IP "XGStrip"
Whether or not to dump only displayed data in a SpreadSheet or XGraph dumps. This also enables the non-dumping
of points discarded by runtime processes.
.IP "DumpAv"
When this is selected, an
.B XGraph
dump will contain the calculated values of an "average set", instead of the
.B *AVERAGE*
command that would/might recreate it (this would go wrong if not all sets are saved).
.IP "DumpProc"
If this is selected, an
.B XGraph
dump will contain the results of
.B *DATA_PROCESS*
transformations, instead of the commands.
.IP "Binary"
Dump data as binary, instead of columns of ASCII representations. Much faster, but less flexible.
.IP "DHex"
Dump doubles (ascanf variables, set associations and set data if not Binary) in a hexadecimal form: see
the \fB%dhex\fP format description under \fB*DPRINTF*\fP.
.IP "2Page"
When this is selected, XGraph gives some help in printing 2 graphs on a single page (PostScript only). The
first graph will be printed at the top (in Portrait mode) or at the left (in Landscape) of the page, and no
\fBshowpage\fP command will be generated. The next graph will be printed below or to the right of the first,
and a \fBshowpage\fP command will be generated, after which the cycle recommences. The scale field can be
used to adapt the graph's size (i.e. set to 70.7%).
.IP "Margins"
Allows the inclusion of corner marks in PostScript output.
.IP "PS RGB"
When selected, XGraph outputs RGB PostScript, making it possible to preserve the selected colours on
a suitable printer. Note that screencolours ("light mixing": full R+G+B = white) are not necessary always printable
-- dye mixing: full R+G+B = black! When not selected, XGraph substitutes colours with a grayscale value that
has a psychometrically similar brightness (0.3 * R + 0.59 * G + 0.11 * B). Available only when dumping as PostScript!
.IP "XG RGB"
Takes the place of the previous button when \fBXGraph\fP format is selected. This instructs XGraph to store all the
current colour definitions in the dump. It is set automatically by the presence of either a \fB*GLOBAL_COLOURS*\fP
command or a \fB*PROPERTIES* [..] cname="cspec"\fP (or \fB*ULABEL* ... cname=\fP) field, in any of the input-files.
This option causes the setting of the reverse-video (\fB-rv\fP) and/or \fB-IgnoreCNames\fP flag to be saved too.
Note that labels preserve "dynamic" colourspecifications (default and linked, see under \fB*ULABEL*\fP) when dumped,
this in contrast to sets. This might be implemented for sets too in a future update. \fB<Mod1>\fP-clicking on
this button toggles the state of the \fB-TrueGray\fP flag.
.IP "Font Family" fields
These fields specify the name of a font to use when drawing
the indicated text items.  Suitable defaults are initially chosen for
any given hardcopy device, but currently only the PostScript and XGraph device make actually use
of the fonts specified here. The PostScript fonts are expected to be font/style specifications
(e.g. Palatino-Bold-Italic); the size is taken from the size field described below. The PostScript device
reads out the font specifications when a dump is made: no validation of changes is necessary. For the XGraph device,
the font fields specifiy the full X11 font specification; changing them \fIand validating the change\fP modifies
the fonts used for displaying. The XGraph device ignores the size fields.
.IP "Font Size"
These fields specify the desired size of the selected fonts in points
(1/72 of an inch).  
If the device supports scalable fonts,  the
font will be scaled to this size. Changes to the (PostScript) font sizes should be validated to be taken into account
immediately.
.IP "Control Buttons"
After specifing the parameters for the plot,  the "Ok" button causes
.I xgraph
to produce a hardcopy. Hitting the
.I Enter
key on the numeric keypad does the same thing; hitting the
.I Return
key also causes xgraph to close the window after doing the hardcopy operation.
Pressing the "Cancel" button will abort the hardcopy operation.

.SH COMMANDLINE OPTIONS
.I Xgraph
accepts a large number of options a number of which can be specified
either on the command line or in the user's ~/.Xdefaults file.
A list of these options is given below. 
Many of these options can be changed using the
.I Settings
or
.I Hardcopy
dialog boxes. 
Commandline options can also be passed through the \fBXGRAPH_ARGUMENTS\fP env.var., a
\fB*ARGUMENTS*\fP statement in an inputfile, or by the \fBARG\fP field in the Settings
dialog. The latter is useful for those options which don't have a direct control in that
dialog box, like the colour options.
The command line
option is specified first, followed by its X default name (if any) in parenthesis.
The format of the option in the X defaults file is "programme.option: value"
where programme is the programme name (xgraph) and the option name is the
one specified below.  Note that the value of a flag in the X defaults
file must be "1".
In some cases (notably the arguments toggling an option), a 0 or 1 can be
appended directly after the argument (i.e.
.I -option0
or
.I -option1).
In case of a toggle switch, an appended 0 will switch off the switch, and a 1
will switch it on. All other "appendices" have no effect.

Colo[u]r options (\fB-fg\fP, etc.) receive either a canonical colourname (like "red"),
a numerical X11 colour spec. (like #ff0000 which is equally red), a decimal RGB specification
of comma-separated floats in [0,255] (as in 255,0,0), or the value \fBdefault\fP, 
which resets the colour to its default value (specified through the X11 resources, or the
internal default) it had at startup. The dialogboxes and buttons always use a 4-level graymap.

From the XParseColor(3X) manpage:

COLOR NAMES 

An RGB Device specification is identified by the prefix ``rgb:'' and conforms to the following syntax: 

rgb:<red>/<green>/<blue> 

<red> , <green> , <blue> := h | hh | hhh | hhhh 
h := single hexadecimal digits (case insignificant) 

Note that h indicates the value scaled in 4 bits, hh the value scaled in 8 bits, hhh the value scaled in 12 bits, and hhhh the
value scaled in 16 bits, respectively. 

For backward compatibility, an older syntax for RGB Device is supported, but its continued use is not encouraged. The
syntax is an initial sharp sign character followed by a numeric specification, in one of the following formats: 

#RGB    (4 bits each) 
#RRGGBB    (8 bits each) 
#RRRGGGBBB    (12 bits each) 
#RRRRGGGGBBBB    (16 bits each) 

The R, G, and B represent single hexadecimal digits. When fewer than 16 bits each are specified, they represent the
most-significant bits of the value (unlike the ``rgb:'' syntax, in which values are scaled). For example, the string ``#3a7'' is the
same as ``#3000a0007000''. 

An RGB intensity specification is identified by the prefix ``rgbi:'' and conforms to the following syntax: 

rgbi:<red>/<green>/<blue> 

Note that red, green, and blue are floating-point values between 0.0 and 1.0, inclusive. The input format for these values is
an optional sign, a string of numbers possibly containing a decimal point, and an optional exponent field containing an E
or e followed by a possibly signed integer string. 

The standard device-independent string specifications have the following syntax: 
.LP
.Ds 0
CIEXYZ:<X>/<Y>/<Z> 
CIEuvY:<u>/<v>/<Y> 
CIExyY:<x>/<y>/<Y> 
CIELab:<L>/<a>/<b> 
CIELuv:<L>/<u>/<v> 
TekHVC:<H>/<V>/<C> 
.De
.LP
All of the values (C, H, V, X, Y, Z, a, b, u, v, y, x) are floating-point values. The syntax for these values is an optional plus or
minus sign, a string of digits possibly containing a decimal point, and an optional exponent field consisting of an ``E'' or
``e'' followed by an optional plus or minus followed by a string of digits. 

<End citation>

To be sure, xgraph will always include an RGB specification (in brackets; see below) when including colours in an
XGraph dump. This way, when a canonical name is not defined on another X server, or has a different definition,
the colour's definition on the server where the file was last saved can be restored. This is automatic if the
canonical name is undefined.

There may be a difference between a colour defined with rgb:rrrr/gggg/bbbb and rgbi:ri/gi/bi, depending on the X server. XFree86
(under Linux) applies gamma correction to RGB values specified with the latter, intensity notation. It does not with the former
notation (assuming the correction to have been applied already). Needless to say that this can have undesired effects, especially
since colour PostScript printing uses the colours as displayed on the screen. So if an intended grayscale is coloured due to the
gamma correction, this will be visible on the printout too. Therefore, a global variable exists, \fB$AllowGammaCorrection\fP
(default True). When set, colours requested through an RGB triplet, as well as the obtained RGB specification attached to
the stored colournames, use the intensity notation. Colours specified with the rgb:rrrr/gggg/bbbb notation are still
not gamma corrected, of course. When \fB$AllowGammaCorrection\fP is unset (0), all RGB colour allocation is forced through the
rgb:/// notation to ensure that no gamma correction is applied. Even colours requested in the intensity notation (of course: no
gamma correction is allowed..). This may not work similarly, or at all, on all X servers.

.TP
.\".B  \-s (Spline)
.\"This option specifies the lines should be drawn as spline curves.
.\"Currently,  this is implemented using the X spline option which
.\"fits only three points at a time.  Thus,  the effect is not what
.\"you might expect.
.\".TP
.B -2ndGEN[01]
Causes commands in the inputfiles that would normally be executed immediately, to be delayed
until the next reread-after-save/dump. Only works with commands that have a \fI2ndGEN_\fP form,
like \fB*READ_FILE\fP and \fB*STARTUP_EXPR*\fP. This option can come in handy when a complicated
processing is done that uses several command (or batch or whatever) files. Suppose that one of the stages
involves a lengthy manual task (like cleaning up, removing outliers etc.), with the following stages
to be launched automatically after this task has been fulfilled (e.g. by doing an XGraph Preview, which
directly pipes the data to another xgraph instance). In that case, I find it useful to save regularly, for
obvious reasons. If I need to restart the process, I of course don't want the next stages to be launched,
put to be put off.. that's what this option is for.
.TP
.B \-absy
This option causes
.I xgraph
to take the absolute value of the (scaled; see
.B *SCALEFACT*
) Y values before any other transformations are done.
.TP
.B  \-af <fontname> (AxisFont)
Axis font. All axis values are drawn using this font.
.TP
.B  \-ag <colour>
The colour to draw the axes (or "borders") in. Defaults to black.
.TP
.B \-AllTitles[0|1]
By default, XGraph will show all titles ("-t" title, "-T" title and those of the datasets being shown) on subsequent lines,
as long as they are not a repetition of (equal to) the previous
line.
The \fB-AllTitles\fP option can be used to deactivate this filtering; this option can also be accessed by <Mod1>-clicking
the [No tit.] button in the Settings dialog. It is a global setting, affecting the title display in all windows.
.TP
.B \-aspect
Create a 1:1 resultant aspect-ratio by changing the bounds on one of the axes. This
corrects for non-1:1 aspect-ratios of the plotting area. It is also possible to have
the window-size be adapted: see under the key-press \fB<Mod1>-a\fP.
.TP
.B \-auto
force auto scaling (ignore indications in files)
.TP
.B \-average_error
Toggle. When set, xgraph draws errors which correspond to the per-set average
error (include *DATA_PROCESS* transformations). During an XGraph dump, the
average of the raw errors is output in a 4th column.
.TP
.B \-aw w
set width of axis lines
.TP
.B  \-b
Force
.I xgraph
to output the graph in black and white (even if the display is colour).
This is useful for those using
.I xwd(1)
to produce hardcopies of the graph.
.TP
.B \-bar
.TP
.B -brt <t>
.TP
.B -brb <b>
.TP
.B -brw <w>
Specifies that vertical bars should be drawn from the data points to
a base point which can be specified with -brb.  Usually,  the -nl
flag is used with this option.  The point itself is located at
the centre of the bar. The width of the bar can be specified with the -brw option. If a
non-positive number is specified, this defines the space between bars; -brw 0 results in
touching bars. Thus, a negative width enables auto-scaling of the actual barwidth, such that there is
(on average..) a given space (1 pixel for -brw -1) between bars. Note that this supposes that
the bars are drawn from left to right (i.e. that X increases..). If a base point has not been
defined, the bottom of the window is used. Otherwise, bars are drawn from the base defined up to
or down to the current Y: the specified base-point (a Y value) is subject to any *TRANSFORM_Y*
defined. Bars are always symmetrical around the actual X value. When a nonlinear axis transformation
(say, F(x)) is used, the correct width is shown (i.e. F(x+w/2)-F(x-w/2)), but centered around X.
Thus, a width that on the "raw" axis does not touch or overlap, is not unlikely to overlap 
on the transformed axis.
All different bar types (see below) have one feature in common. They indicate with their height a
given Y value, and with their width a potential 2nd value (that is fixed over the dataset). Many
other applications support bars with outlines of different linewidths, but these are usually lines
around the bar's edges (as the name suggests...). However, the result is that a bar of 100 high, with
an outline linewidth of 6 will really be 103 high. One then has to judge the actual height (Y) from estimating
the centre of the outline. XGraph reduces that bars' width and height to accomodate
for the outline linewidth.
The \fB-brt\fP option specifies the type of bars. Currently, there are 7 options. \fBt=0\fP, the
default: bars are drawn as lines with width according to \fB-brw\fP. The selected linestyle applies
to the whole bar, and an "outline" is drawn (solid) in the selected linewidth and linecolour.
\fBt=1\fP: bars are drawn as outlined rectangles of the appropriate height and
width (\fB-brw\fP), independent of the outline's width. The outline is drawn according to the selected
linewidth and linestyle. \fBt=2\fP: similar to t=1, but the bars are filled (currently) with the
current or set's highlight colour. \fBt=3\fP: a cross between t=0 and t=2. The bar is filled by a
vertical line of the selected linestyle (as in t=0) and in the appropriate highlightcolour, the contour
is drawn in solid, in the selected linewidth and linecolour (as in t=0). \fBt=4\fP: like t=2, but
the fill-colour is now determined based on the bars' intensity (error) values and the currently
installed INTENSITY_COLOURS. \fBt=5,6\fP: these are actually not really bars at all, but bars reduced
to their minimal expression, as suggested by Edward Tufte in one of his excellent books. He argues that
using a bar to indicate a centre (X) value and a height (Y) is redundant: this can be done by a vertical line
and a horizontal line too. If one takes on of the bar's sides for the vertical line, and half its top for the
horizontal, then a "hook display" a la Tufte results. With this, one can show 2 datasets in (almost) the space
that a single dataset occupies using regular bars. Type 5 gives rightward hooks, type 6 leftward.
.TP
.B -bar_legend_dimensions X,Y,M
Determine the display of barplot "bars" in the legend (type 1 legend). The X is a weight on
the standard PostScript marker width (set via -PSm or hardcopy dialog), that determines the
width of the drawn bar. Its (half)height is determined by the \fBY\fP that is a weight on the legend
text pointsize; a value of 1 means twice as high as the text. The \fBM\fP parameter is a scaler
on the resulting height that determines the margin between a drawn bar and the next.
<Mod1>-clicking on the [bars] button in the Settings dialog calls up a window in which these values
can be set interactively.
"Tufte hook bars" (bartype 5 and 6) are drawn as wide as other bars in the legend. This is conceptionally
not exact, as they should be half as wide only. But I find it aesthetically more correct for the legend
display to draw them as they are drawn :)
.TP
.B  \-bb[01] (BoundingBox)
Draw a bounding box around the data region.  This is very useful
if you prefer to see tick marks rather than grid lines (see -tk).
Given without numerical option, these commands override the settings specified in the
set-specific \fB*PROPERTIES*\fP commands. Giving a numerical option avoids this.
.TP
.B  \-bd <colour> (Border)
This specifies the border colour of the
.I xgraph
window.
.TP
.B  \-bg <colour> (Background)
Background colour of the
.I xgraph
window. Translated to psychonometrically corresponding gray
value in the PostScript dump, unless the \fBPS RGB\fP mode is selected.
Other colours can refer to this colour as "BackGround".
.TP
.B -bs[0|1]
Turns on/off backing store (and save unders). This is an X11 option that determines, basically, if XGraph is required to redraw
regions that become exposed after a covering window is displaced/removed (-bs0), or whether the X11 server should take care
of that (-bs1). The same can also apply to just moving a completely uncovered XGraph window! The default is off (because
theoretically this is something that takes time). If set through this command line option, the setting is saved in XGraph
dumps.
.TP
.B  \-bw <size> (BorderSize)
Border width (in pixels) of the
.I xgraph
window.
.TP
.B \-bf <filename>
Predefine a \fBBoxFilter\fP file name.
.TP
.B \-BoxFilterUndo0|1
(De)Activate the undo function on the BoxFilter functionality. Can be set from within a boxfilter file.
.TP
.B \-Cauto[01]
Indicates that xgraph should or should not honour a \fB*Cxye*\fP
statement in the input. Such a statement will override the last \fB-Cxye\fP
option. This feature now defaults to \fIoff\fP (but one can re-activate it in the \fBxg_init.xg\fP file).
.TP
.B \-Cxye
specify (different) order of x, y, error columns in input; e.g.
.B -Cexy
means that the E-values are in the first columns, the X-values in
the 2nd, and the Y-values in the 3rd. This option overrides the possible effect 
of a previous
.B -Cauto
statement.
.TP
.B -colour
Startup in colour mode. In this case, XGraph defines a set of 16 colours which are used
in cyclic fashion to draw sets. The global colours that are allocated are slightly different
from the ones allocated in \fB-monochrome\fP mode (see below). The biggest difference with the
latter mode is that in that mode the \fB-fg\fP colour is used as default to draw all sets.
The colour in which sets are drawn can be changed through the settings dialog.
.TP
.B \-ColouredSetTitles
Draw datasets' titles using the datasets' colours. This also implies that all titles are drawn, currently.
.TP
.B -Columns <NCols>,<xcol>,<ycol>,<ecol>
Specify the number of columns, and the numbers (starting at 0) of the columns in which to
find the X, Y and Error values.
.TP
.B -Cross[0123]
Replaces the normal X cursor (a small cross) with a large "crosslines" cursor.
A crosslines cursor has the pecularity that the cross will show (and be updated)
in all active windows. The cursor's screen co-ordinates are translated to "world co-ordinates", which are
afterwards re-translated into screen values for each separate window, subject to its axes-transformations.
Thus, if two different windows show different parts (sets) of a data collection, but with a (large)
overlap in the co-ordinate space, moving the cross in one window will show the same locations in the other
window.
The cross is drawn in zero-colour (-zg) in the window containing the pointer, in grid colour (-gg) in
the other windows. When the value 2 or 3 is passed, the current location is in addition shown as a co-ordinate
pair next to the intersection of the two lines. In this mode, the measurement information (Control-Button2)
that is normally shown in the window's titlebar is also shown next to the cross. This textual feedback
is only shown in the window that contains the pointer for -Cross2, and in all windows for -Cross3. That latter option
is useful only when cross-window processing/transformations take place, otherwise all co-ordinates shown are identical
in all windows...
This setting is not preserved when dumping to an XGraph file (or a new process).
This option is also accessible through the \fBCursorCross[]\fP ascanf function.
.TP
.B \-db[level]
Turns on debugging mode [level]. Also see the \fB-wns\fP option. Debugging can also be set from the settings dialog,
and with the \fBdebug\[val,level]\fP ascanf function. There is also a window-specific debug/no-debug flag that can
be set only from within the settings dialog.
.TP
.B \-db_expr_error[0|1]
An aide in debugging processing expressions (DATA_??? range). With this flag set, if an error occurs during this
chain of processing, the chain will be executed immediately once more, with the \fB-fascanf_verbose\fP ($verbose)
flag set. This only happens when that flag is not yet set, to prevent unnecessary output. This will likely generate
an enormous amount of output, but the error will be traceable. That is, if it is reproduceable...
.TP
.B \-detach
Detach after initial communication with X-Server and reading in
and processing all datafiles. This is done by forking, and detaching
from the calling terminal
.I (stdin
is closed, and a new processgroup created). The older option
.B -detach0
causes
.IR xgraph
to fork before all other things, with the child doing all the work. This
means that accounting information (sys/user time) is not available, and
can cause the parent to hang indefinetely if the child crashes. See \fB-tellPID\fP.
.TP
.B  \-df <fontname> (DialogFont)
Dialog font. All dialogs, buttons, inputfields etc. make use of this font, and its
associated greek (symbol) font. Like the other fonts, this one can be changed runtime. However,
the width of buttons and other elements using it is not (necessarily) updated to accomodate
the new fonts' dimensions. The Settings and Hardcopy dialogs can be "fully" closed (not just
unmapped) by depressing the \fBMod1\fP key when clicking on respectively the "[Ok]" and the
"[Cancel]" button, or by sending your window manager's WM_DELETE_WINDOW command (f.delete in twm 
and mwm).
.TP
.B \-dir <dirname>
Change the working directory to <dirname>.
.TP
.B \-disconnect
Creates a new dataset when the direction of change of the
X-coordinate (increase -> decrease or vice versa) changes. This
is a simple way of viewing three-dimensional data without getting
a "retrace" line every time the X-coordinate jumps back to its
original value. See also the
.B *SPLIT*
command below.
.TP
.B -DumpAverage[0|1]
Specifies whether or not "average sets" are (XGraph) dumped as
.B *AVERAGE*
commands, or as regular sets.
.TP
.B -DPShadow[0|1|-1]
When set, discarded points leave a visible "shadow" in the form of a single pixel. They are not taken
into account when determining the axes' ranges, so how many are actually visible depend on the remaining
points being displayed, and the scaling settings. This is a global setting applying to all windows, and
affecting all forms of graphics output (screen, printing, &c). When set to -1, this flag is not exported
to an XGraph dump: usefull for cleaning up data with shadows, and not needing to bother to switch off the flag
before saving the result.
.TP
.B -DumpBinary[0|1|size]
Dump data as binary. This is much faster, and doesn't cause conversion loss (at least,
not on the same platform). However, data cannot be edited, and/or read errors that
do arise in some (non-xgraph-related manner :)) cannot be corrected. This option can be
given only as a commandline argument when \fB-DumpRead\fP has been specified.
The optional \fBsize\fP can be used to specify a dump size (precision) different from the default
C double float size. Currently, the only other choice are floats (4 bytes on most platforms, as opposed
to the 8 byte doubles). This can also be changed by Mod1-clicking on the \fI[Binary]\fP button in the
print dialog. The smaller sized model has the advantage of generating smaller files (and faster access
times) when required data precision allows it. Note however that once compressed, the size difference
disappears.
As of 20080724, XGraph also supports 16bit and 8bit integers as storage format. It will make use
of the \fB*EXTREMES*\fP information to translate to and from floating point values. Note that there is
little guarantee that no information will be lost during the conversion - and NaNs and Infs are not
supported in these integer formats.
.TP
.B -DumpDHex[0|1]
Sets the \fB*DPRINTF*\fP double printing format to \fB%dhex\fP while dumping an XGraph file. This activates
heximal printing of doubles: see the discussion under \fB*DPRINTF*\fP.
.TP
.B -DumpIncluded[0|1]
When \fB-DumpRead\fP is given, also dump the files that are included (or else just dump
the include command). Active by default. This option can be given only
as a commandline argument when \fB-DumpRead\fP has been specified.
.TP
.B -DumpPens[0|1]
Specify whether or not to dump the current state of the Pens in XGraph dumps (they're always drawn in
graphic dumps like PostScript!). This is done at the end of the file, using \fB*STARTUP_EXPR*\fP expressions,
and the current setting for the ascanf variable printing format. Note that this means that, upon restore/load
of such a dump, the Pens state is volatile: the data is loaded once, and any operation with one of the Pen
functions will likely alter the state non-reversibly. The only sure way to robustly restore graphics added
with Pens is to include the code that creates these graphics.
This feature is not yet fully implemented: saving of Pen attributes is not yet available.
.TP
.B -DumpProcessed[0|1]
Dump processed values, instead of raw data. Dump the result of processing and/or transformation.
(Dumping transformation results may have unexpected results - always do a preview!.) When a
description was given (e.g. *DATA_PROCESS_DESCRIPTION*), this is added to the *VERSION_LIST*
(or a new list is created), so that a trace of different processing stages can be maintained.
.TP
.B -DumpRead[0|1]
Dump whatever is read onto stdout, converting binary input into ASCII. Exits when the
last file has been processed. Useful to "really include" files specified with \fB*READ_FILE*\fP
or \fB*read_file*\fP commands (unless \fB-DumpIncluded0\fP has been given),
or to convert binary files into ASCII ones. When combined with \fB-DumpBinary\fP, data is dumped
as binary instead of ASCII (=> conversion the other way). This option can be given only
as a commandline argument.
.TP
.B \-eng{XY}<01>
Don't/Do use engineering notation on X or Y axis
.TP
.B \-error_region
Connect the low (i.e. Y-Error) and high (Y+Error) points of the
"errorbars" with lines, creating an error region around the datapoints.
."These lines are drawn in the same linestyle as the line (possibly) connecting the datapoints.
Error setting are (in principle) mutually exclusive.
.TP
.B -exact_X[0|1]
.TP
.B -exact_Y[0|1]
Modify how values are put along the axes. Normally, xgraph decides how many such values
to put, and at what interval. It then steps through this interval, retrieves a value,
and constructs the "valuelabel"
(which depends on the setting of the engineering notation flags (-engX/-engY) and whether or
not fractions are allowed). Then, it puts the label at the place corresponding to the original
value. Due to round-off, this can be anything but the correct location - especially when the
axis' range is in the order of 1/100 or smaller (normally, only 2 decimals are printed). Setting
these "exact" flags (they are by default) causes xgraph to re-consider the value corresponding
to the valuelabel, ensuring that what's along the axes is always at the right place. Drawback:
sometimes there's nothing along the axes because the reconsidered values are outside of the
plotting region... In this case, unset the exact flags, or change the appropriate axis scale, set
the appropriate engineering notation flags - whatever. I have not yet found a good solution.
.TP
.B \-f <path>
.TP
.B \-script <path>
Specify a file to be included after opening a window (a \fB*SCRIPT_FILE*\fP). Multiple files can
be included in this way, by passing multiple \fB-f\fP (not \fB-script\fP!) options.
\fIpath\fP can be either
a filename, or a pipe specifying a command to be executed. In the latter case, it should start with a 
\fB|\fP - and end with one also if multiple files are specified.
.TP
.B \-fascanf_functions
Show the help page, including an overview of all functions that are
known to fascanf(). This information is shown in a large popup-menu when
the
.B ?
key is pressed in a graph window. (See below the description of the \fB?\fP key-command.)
.TP
.B \-fascanf_verbose
Show every function evaluation performed by fascanf(). Output is in the
form
.B #\texp[arg1,arg2,..argN]== <result>
and can be
.IR very
verbose, especially for nested function calls.
.TP
.B  \-fg <colour> (Foreground)
Standard (default) foreground colour. Translated to psychonometrically corresponding gray
value in the PostScript dump, unless the \fBPS RGB\fP mode is selected.
Other colours can refer to this colour as "ForeGround".
.TP
.B -fit_after[01]
The autoscaling activated with the \fB-fit_?bounds\fP arguments described below normally
takes place before the redraw. When the \fB-fit_after\fP flag is set, it is done \fIafter\fP
redrawing, and redraws are generated until the scaling converges to a stable solution
(i.e. until the ranges of the scaled axis/axes no longer change). See the description of
the \fBFitBounds\fP ascanf function below.
.TP
.B \-fit_xbounds[012]
.TP
.B \-fit_ybounds[01]
Always (i.e. not just when opening the 1st window) scale the \fBX\fP and/or \fBY\fP axes
to the window. The option \fB-fit_xbounds2\fP also activates scaling of the polarBase to the
current range of angles ("X" coordinates) in polar mode - thus the vectors are displayed on a full
circle. Note that this option doesn't always give the expected results in combination with \fB-process_bounds\fP.
Sets can be excluded from autoscaling by setting their floating (\fBflt\fP) flag through the Settings
Dialog, or via an \fB*PROPERTIES*\fP flag.
.TP
.B \-fli[01]
Don't/Do use increment the width of lines for each new file
.TP
.B \-fn[01]
Don't/Do show filename to the right of the legend
.TP
.B -gg <colour>
Specify the colour of the grid.
.TP
.B -gp[0] <pattern>
Specify the gridlines' pattern. (See GridStyle). When called as -gp0, the pattern argument not read,
and a solid linestyle is selected.
.TP
.B -gs_twidth[01]
Use GhostScript to determine the widths of strings when generating a PostScript dump. See the discussion
of the "GS" button in the hardcopy dialog.
.TP
.B -gs_twidth_batch[01]
Select GhostScript stringwidth batch mode. See under the "GS" button.
.TP
.B -gw <gridWidth>
.TP
.B \-hc <colourname>
Specify the colour used for highlighting.
.TP
.B \-help[1]
Print help. The \fB-help1\fP form also displays this manpage, if it is correctly installed.
.TP
.B \-highlight_set <list>
Initially show the sets in <list> highlighted. Highlighting can be toggled by clicking on a set's
entry in the legendbox, and consists of drawing a broad band under the line connecting the set's datapoints and
under its errorbars or error-region. The same colour is used to "standout" the set's entry in the legendbox, and
its title. A set's
highlighting can also be toggled by "meta"clicking the 3rd mousebutton in the vicinity of a point
belonging to the set, and by holding the \fBMeta\fP (Mod1) key while releasing the mousebutton (when the \fBControl\fPkey
is also held, a label is also created at the same point).. Note that the number of elements accepted in <list>
equals 4 times the current number of allocated sets.
.TP
.B -hl_mode [01]
Select the highlighting mode. When 0 (the default), the total width of a highlighted line with width \fBw\fP is
5 * max(1,\fBw\fP) ^ hl_par1 . When 1, the width is \fBw\fP + hl_par1 . \fIhl_par1\fP can be set with the \fB-hl_pars\fP
argument.
.TP
.B -hl_pars hl_par1,hl_par2
Modify the highlighting behaviour. The first element in the parameterlist, hl_par1, is a parameter in the determination
of the total width of a highlighted line; default is 0.75. The 2nd element, when true (the default), causes highlighting
of a highlighted set's legend-text and title-text; when false, no text highlighting is performed. These options can
currently only be given through the commandline and the Settings Dialog's ARG interfaces.
.TP
.B -IgnoreCNames[01]
When set, any \fBcname\fP colour specifications in set-specific \fB*PROPERTIES*\fP commands are ignored. Unset 
with \fB-IgnoreCNames0\fP. Applies to UserLabel colours too.
.TP
.B -IPN[012]
Requests a "shell" to be entered after the last file has been read. This shell provides 2 alternative
ways of entering any amount of \fB*EVAL*\fP (was: *PARAM_NOW*) expressions (see below). With \fB-IPN1\fP, expressions
are read from the terminal until EOF or \fIexit\fP is typed.
With \fB-IPN2\fP, input is read through an X11 input dialog that keeps popping
up until one types the magic word \fIexit\fP or until one kills the programme. The \fB-IPN0\fP version
nulls any previous invocations. The interest seems mostly of a "debugory" nature. See also \fB-PN\fP.
.TP
.B \-lb[01]
Don't/Do show the per-set Y-axis-label instead of the filename in the legend-box. See
.B *YXLABEL*
.TP
.B \-IO_Import <IO_ModuleName> <file>
Import \fBfile\fP using the import module \fBIO_ModuleName\fP. Normally, files are loaded after all arguments have been parsed;
this command executes immediately. Note that in this case, the loaded data will have <file> associated as filename.
.TP
.B \-Landscape
Print in landscape orientation
.TP
.B \-legendtype <x>
Specify how the legend is formatted. Presently, there are 2 choices: \fB<x>=0\fP (default) draws
a line fragment above the set's name; the fragment's width is the width of the longest setname. When
a set has a specific marker symbol, it is shown at the beginning (left) of the linefragment. All fragments
of sets belonging to the same group are linked with a vertical line which connects the fragments at the
right side. When \fB<x>=1\fP, the linefragments are shown to the left of, and at the same hight as the
setname, with the possible marker shown in the middle. In this case, the width of the linefragment depends
on the width of the set's marker; the vertical lines connecting groups are shown in the same way as for
type \fB0\fP, except that they make no contact with the linefragments. Generally, type \fB0\fP takes more
vertical space, and type \fB1\fP more horizontal space. In both cases, on-screen formatting may not correspond
accurately to the layout in a PostScript printout (which is generally correct) - the determination of text- and
marker widths (and heights) is somewhat fuzzy.
.TP
.B \-legend_ul[1] <x>,<y>
Place the upper left corner of the legend box at coordinate (x,y).
Can also be done by Shift-clicking with the 
.I 1st mousebutton
at the desired location. When done in raw mode, the coordinates of the clicked point are specified
in the data-domain, and can thus be subjected to all runtime transformations. Otherwise,
the coordinates of the clicked point are in the transformed data-domain, so that the
legend box will not necessarily remain in the correct position when changing transformations.
A transformable legend location can be specified with
.B \-legend_ul1
These coordinates can be changed through the Settings Dialog: when a set is selected in the selector-box,
the first two fields of the UserLabel-coordinate-entry fields show the X and Y coordinates of the legendbox.
.TP
.B  \-laf <fontname> (LabelFont)
Label font.  All axis labels (names) are drawn using this font.
.TP
.B  \-lef <fontname> (LegendFont)
Legend font.  All legends (names of datasets) are drawn using this font.
.TP
.B \-ln{x,y}[01]
Don't/Do use logarithmic scale for X or Y axis. Data are transformed as follows:

.EQ
size -1
bold
x dot = cpile {10 above ~}log(x)~;
.EN
.EQ
size -1
bold
y dot = cpile {10 above ~}log(y)
.EN
.TP
.B \-log_zero_{x,y} X
Subsitute X for 0 in input on a log x/y axis
.TP
.B \-log_zero_{x,y}_{min,max}
Indicates that the log_zero substitution value on a log x/y axis should be
placed at the axis's current min or max bound.
.TP
.B \-log_zero_sym_{x,y} S
Show symbol S at log_zero_{x,y} location [0*]
.TP
.B \-lw w
Specifies the width of the data lines in pixels.  The default is one.
.TP
.B \-lx x1,x2
Set x axis to interval x1,x2
This option limits the range of the X axis to the specified
interval.  This (along with -ly) can be used to "zoom in" on a particularly
interesting portion of a larger graph. The specified interval is enlarged
by 20% padding, and possibly to include the log_zero_x value. Use the form
.B \-LX x1,x2
to specify a "hard" interval.
.TP
.B \-ly y1,y2
Set y axis to interval y1,y2. The specified interval is enlarged
by 20% padding, and possibly to include the log_zero_y value. Use the form
.B \-LY y1,y2
to specify a "hard" interval.
.TP
.B -lleft llx,lly
.TP
.B -rright urx,ury
.TP
.B -bbox llx,lly,urx,ury
.TP
.B -boundingbox llx,lly,urx,ury
Alternatives to \fB-lx\fP and \fB-ly\fP. \fB-lleft\fP defines the lower-left corner (\fB-LLeft\fP to specify a "hard" interval);
\fB-rright\fP the upper-right corner and the \fB-bbox\fP forms define the whole rectangle as a 4-value sequence.
.TP
.B \-m[0|1] \-[0|1]M
Mark points distinctively (\-M varies with colour).
Given without numerical option, these commands override the settings specified in the
set-specific \fB*PROPERTIES*\fP commands. Giving a numerical option avoids this.
.TP
.B \-mark_set <list>
Initially mark the sets in <list>. Note that the number of elements accepted in <list>
equals 4 times the current number of allocated sets.
.TP
.B \-maxsets <n>
Increase the initial maximum number of sets to
.B <n>.
.TP
.B \-maxlbuf <len>
Increases the size of the buffers used for reading and parsing data up to
.B maxlbuf=<len>
bytes. This only works elegantly with
.IR GNU\ gcc,
which has dynamically sized local arrays. With other compilers, to simulate this feature,
these buffers are allocated as static variables: requesting long lines (large <len>) thus
results in more, permanent, memory-usage.
.TP
.B -MinBitsPPixel <bits>
Specify the minimally required bits per pixel. Default is 8, which seems to be a reasonable
guess for the default depth of current-day X servers. Asking for less won't have any effect
if the default visual has a larger depth (and no specific visual type has been requested).
Asking for more will probably generate a lot
of X messages, but seems to work without further problems. Currently, this option only works
on the commandline (but experimental support for selecting another visual after the initial startup can be
included during compilation). However, the \fBXGraph\fP script provides a way around this, allowing a
dump to specify its preferred visual.
In addition to requesting a minimal depth, a specific type (e.g. DirectColor) of visual
can be requested through the \fB-VisualType\fP argument. These two options work in concert,
but priority is given to the minimal depth: if the requested type can't be found at the
minimal depth or better, another type will be opened. See also the discussion of the \fB-use_XDBE\fP
argument.
.TP
.B -mindlegend[0|1]
Modifies the size of the data-window, the part of the plot "within" the axes-box, showing the
data. By default, (\fB-mindlegend1\fP), this window is determined in such a manner that the
legendbox is entirely visible, also when it has been positioned in a way that it depasses the
ranges of one or both of the axes. When unset (\fB-mindlegend0\fP; the default behaviour before
April 20, 1999), priority is given to maximising the size of the data-window. As a result, the
legendbox can be positioned in a way that it depasses the physiscal window: on screen, it will
then be (partly) invisible; on a printout, it may show up somewhere on the paper. This setting
applies also to the X and Y labels in case they are positioned by the user.
.TP
.B \-mlx x1,x2
This option limits the maximum range of the X axis to the specified
interval.  This (along with -mly) can be used to "zoom in" on a particularly
interesting portion of a larger graph.
.TP
.B \-mly y1,y2
Limit y axis to maximal interval y1,y2
.TP
.B -monochrome
Startup in monochrome mode. Uses a white background and black foreground (everything drawn). Changing
the foreground colour (\fB-fg\fP option) changes all elements \fIthat have no individually assigned colour\fP,
even at runtime (the \fBARG\fP "option" of the settings dialog). The colour in which sets are drawn
can be changed through the settings dialog; this makes them "immune" to changes in the foreground colour.
.TP
.B \-nbb_lx x1,x2 [-nbb_LX x1,x2]
Specifies behaviour when axes are drawn, but not the rectangular border (-bb0, hence, nbb). Normally, XGraph then
limits the axes drawn in that case to lengths that will nicely fit them within the rectangle otherwise
defined by the border. Their final length will depend on the values (labels) drawn along the axes. With
the \fB-nbb_lx\fP option, other values can be specified, e.g. to force the axis to show more values over
a larger range. If necessary, the real axis bounds (-lx) 
are enlarged to fit the specified range, as long as the specified values fit on the screen. These values
can also be entered through the Settings dialog (using the [nobb] button). The \fB-nbb_LX\fP variant
sets the axis to "unpadded" ("hard interval"; the [User] button in the Settings dialog).
.TP
.B \-nbb_ly y1,y2 [-nbb_LY y1,y2]
Idem, for the Y axis.
.TP
.B  \-nl (NoLines)
Turn off drawing lines.  When used with -m,  this can be used to
produce scatter plots.  When used with -bar,  it can be used to
produce standard bar graphs.
.TP
.B \-noaxis (DrawAxes)
Turn off the drawing of axes, or specify whether to draw the axes (with the X-resource).
.TP
.B -nocomments
Normally, XGraph keeps a log in which a lot of information on the input is stored. Such a log
can be useful, but it can also cost significant amounts of memory and or time, especially when
reading lots of (small) files. In that case, passing the \fB-nocomments\fP option causes only
the very first comment to be stored (startup information), and the rest to be silently and quickly
ignored.
.TP
.B \-noerr
Don't draw errorbars. Can be changed in settings dialog.
Setting this still causes scaling to account for values in error column.
.TP
.B -NewProcess_Rescales[0|1]
Whether or not the definition of some new runtime processing causes a (once only) automatic
rescale of the 2 axes. This is off by default, since it would undo the effect of saving
scaling-bounds for an XGraph dump with processing defined.
.TP
.B -No_IncludeFiles
Toggles whether or not (default false) the including of files from within other files is accepted.
.TP
.B \-nolabels
Don't draw UserLabels.
.TP
.B \-nolegend
Don't show the legend.
.TP
.B \-nolegendbox
Do not draw a box (frame) around the legend, if shown.
.TP
.B \-noreal_{x,y}_val
Show transformed values along axes (e.g. log values) instead of the real values
.TP
.B \-nosort
SpreadSheet save will not sort on X values
.TP
.B \-nosplit
Ignore \fB*SPLIT*\fP commands in the input.
.TP
.B \-notitle
Do not show the title(s) above the graph.
.TP
.B \-overwrite_AxGrid
Draw the axes, grid, etc. as the last thing before drawing the legend(s). This allows e.g. to have
the grid (white..) drawn over the data, instead of under.
.TP
.B \-overwrite_legend
Toggles switch that determines whether the legend box (and the User Labels) is shown before (default), or
after the data has been drawn. If drawn last, it potentially hides part of the data.
In this case, it immediately and correctly shows only the sets visible in its window; if drawn first,
this requires one redraw for the information to be retrieved.
.TP
.B \-overwrite_marks
Toggles switch that determines whether any marks (
.I -m,-M)
are drawn before or after the lines connecting the datapoints have
been drawn. If after (default), they potentially hide some parts of the lines,
which can be desirable if the mark is e.g. a "white circle". On the other hand, when a set is highlighted,
its markers are only fully visible in the overwrite mode. This option also applies to the drawing of textual
labels (see \fB*VALUEMARKS*\fP).
.TP
.B  \-p (PixelMarkers, SmallPixels)
Marks each data point with a small marker (pixel sized).  This is
usually used with the -nl option for scatter plots.
.TP
.B  \-P (LargePixels)
Similar to -p but marks each pixel with a large dot.
.TP
.B -PN <expression>
Pass a \fB*EVAL*\fP (was: *PARAM_NOW*) expression to be evaluated immediately.
.TP
.B \-Portrait
Print in portrait orientation
.TP
.B \-preserve_aspect
Preserve the on-screen aspect-ratio of the graph as well as possible in the (PostScript) output.
.TP
.B \-preserve_ftime
Preserve the output file's time stamps.
.TP
.B \-print
Immediately post hardcopy dialog; do not draw all data first.
Also activated by zooming with 2nd mousebutton
.TP
.B \-print_as <type>
Specify the type/language of a hardcopy dump. Use the
.B -help
option to obtain a list of available types.
.TP
.B \-print_sized
Make the size of the initial window equal to the size (in cm.) of
the requested hardcopy option.
.TP
.B \-printOK
Immediately do hardcopy; do not draw all data first
.TP
.B \-PrintInfo
Print the comments gathered from the datafiles (and found under the
.I Info
button) on a separate page. Works in PostScript and XGraph dumps only (slightly
different in an XGraph dump!). Like in the (error)
dialog boxes, the text is formatted according to a simple ruleset.
Lines starting with a whitespace, or lines followed by such a line,
are drawn left-justified. All other lines are drawn centered. The font
is the same as that used for drawing the legend.
The contents of the legend box (as shown when control-clicking on it) are
printed too.

In XGraph dumps (see below), it controls whether or not the contents of the
Info button are listed (as
.B *EXTRATEXT*
statements) in the header of the output file.
.TP
.B \-proc_ign_ev[0|1]
When set, ignore events that are not directly generated by the user during processing. A per-window setting.
.TP
.B \-progress
toggles the "rotator" progress indication shown by default when a
.I *PARAM_FUNCTIONS*
expression is being evaluated. This can speed up things by a factor 3. Another
way to accomplish the same is to redirect stderr to a file. See also the \fBProgress_ThresholdTime\fP
resource value.
.TP
.B \-ps_eps[01]
Try to generate somewhat better EPSF code. Notably:
1) Align the figure to the paper's origin (the lowerleft corner as seen in Portrait).
2) Don't output a showpage command at the end (the command to put the image on paper and eject it).
3) Don't call statusdict (an internal PostScript command).
.TP
.B -ps_fest x
Set the font width estimator. See the discussion of the hardcopy dialog's "X Font size" button.
.TP
.B \-PSm <base,incr>
set base and increment size for (PostScript) markers. Size is interpreted as the markers' halfwidth!
 This option defines the global marker size: it is possible to attribute a set-specific markersize
 with the settings dialog or through an *PROPERTIES* command. Set-specific markersizes can also be
 used to define a marker that scales with the axes.
.TP
.B -ps_<fontspec> <fontname>
Where \fB<fontspec>\fP is one of \fBtf\fP, \fBlaf\fP, \fBlef\fP or \fBaf\fP for defining
respectively the fonts used for title, labels, legend and/or axes in PostScript dumps.
.TP
.B -ps_<fontspec>_size <pointsize>
Specifies the corresponding pointsize.
.TP
.B -ps_s_inc <fname>
Appends \fB<fname>\fP to a list of files to be included in the start of the prolog section of a PostScript dump. Files
are included in the order of specification. Exported to XGraph dumps.
.TP
.B -ps_scale <percentage>
Obvious...
.TP
.B \-ps_setpage[01]
Include PostScript code that will cause (certain) printers/imagers to adapt
the canvas (paper) to the currently requested printing sizes, or otherwise
to adapt the printing scale to the paper being printed on.
Set this option when PDF should be created from the generated PostScript, and/or
the graph is larger than the default paper (usually A4).
Graphical interfaces to GhostScript (gv, gsview32; gs itself) honour these commands, but not always
perfectly (gv cuts part of the image, gsview32 actually seems to ignore the command). However,
the GhostScript (v 6.5) ps2pdf conversion does honour this command correctly.
.TP
.B -ps_transp[0|1]
Normally, xgraph paints its background in the background (-bg) colour when dumping PostScript.
When \fB-ps_transp1\fP has been specified, this is not done. In that case, the background colour
only shows in the legend box or in UserLabel boxes with a border. Note that in transparent mode, UserLabels without
border ("transparent" labels) and the axes labels no longer erase space around them, and the legend box
becomes transparent when no box is drawn around it.
.TP
.B -ps_xpos [0|1|2] , -ps_ypos [0|1|2]
Specify PostScript aligning on page: \fB0\fP: left/bottom; \fB1\fP: centred; \fB2\fP: right/top.
.TP
.B -ps_offset x,y
Specify, in points the offset for left-bottom aligned PostScript plots; defaults to \fB0,15\fP.
These offsets can also be entered through the hardcopy dialog by <Mod1> clicking on the corresponding
alignment button (i.e. the left and the bottom aligment button).
.TP
.B -ps_rgb[0|1]
Whether or not to dump colour PostScript.
.TP
.B \-maxWidth|\-maxHeight
hardcopy output dimensions in cm.
.TP
.B \-page
All debug output is piped to $PAGER
.TP
.B \-pf <filename>
Filename for printfile (output-dependent extension is added). Spaces in the name are substituted for underscores.
This filename is exported to XGraph dumps, or when restarting, unless (an)other name(s) has/have been specified in
the Hardcopy Dialog, in which case the last entered name is used (without extension).
.TP
.B \-plot_only_file <#>
Initially plot only sets in file number <#>
.TP
.B \-plot_only_set <list>
Initially plot and mark only sets whose number appears in the comma-separated <list>. Drawn sets can be cycled with the
(shift) cursor-left and -right keys (see below).. Note that the number of elements accepted in <list>
equals 4 times the current number of allocated sets.
.TP
.B \-polar[base]
Draw data in polar plot, with base (e.g. 360, or PI) [360].
.TP
.B \-print
post a hardcopy dialog without drawing the data
.TP
.B \-progname <name>
set name of programme to <name>: this is used to find X defaults (default: xgraph)
To be effective, this must be the first option given.
.TP
.B \-powA <A>
Power value for goniometric transformation in polar mode. Data are transformed
as follows:

.EQ
size -1
bold
x dot = y * cos cpile {A above (}x)~;
.EN
.EQ
size -1
bold
y dot = y * sin cpile {A above (}x)
.EN
<A> defaults to 1.0 .
.TP
.B \-pow{x,y}[01] <val> | \-powxy <A>,<B>
Power value for "sqrt" scale for X or Y axis. Data are transformed
as follows:

.EQ
size -1
bold
x dot = x cpile {A above ~}~;
.EN
.EQ
size -1
bold
y dot = y cpile {A above ~}
.EN
<A> and <B> default to 0.5 .
.TP
.B \-python[Version] [<code.py>]
Imports a Python file and/or specifies the Python version to use. Version specification follows the
naming scheme used for the plugins, i.e. \fI27\fP for version 2.7 (dymod \fIPython.27.so\fP) or \fI32\fP
for python 3.2 . If a filename is specified, the interpreter is of course loaded immediately, otherwise
loading is delayed. Note that no checking is done if the specified version exists, other than against
negative or zero numbers. Specifying an inexistant version will cause the plugin loading process to fail.
.TP
.B \-radix <radix>
Specify the radix (base) for goniometric operations (see also \fB-polar\fP).
.TP
.B \-radix_offset <offset>
Specify the offset for goniometric operations. For a radix of 360 degrees, this means:
offset 0 (default): 0 degrees points rightwards; offset 90: 0 points upwards; offset -90: 0
points downwards, etc.
.TP
.B -raw_display
Disables transformations. Can be unset through the Settings dialog or with the
.B R
key.
.TP
.B -raw_display_init[0|1|2]
Enables raw mode until just before the first script file is included (\fB-f\fP option) (-raw_display_init1) or after the
first (batch of) script file(s) has been included (-raw_display_init2). This is useful when loading an XGraph file that
already specifies (lengthy) transformations that should be replaced/updated. Without this option, chances are that a redraw
is generated before including the other or updated transformations, thus increasing the (initial) redraw time.
.TP
.B -readline[0|1]
Use GNU readline for getting input from the terminal (stdin). If you have GNU's readline installed,
this will allow some advanced editing options in the (rare) cases that XGraph expects input
from the terminal. If you don't have it installed, a warning is printed, and XGraph's default methods are used.
NB: my version of libreadline needs libtermcap, so I load the library too. It is not impossible that other
versions/implementations need other libraries as well: I'd appreciate to learn this (the readline manpage is
mute on this aspect).
.TP
.B -really_incomplete[0|1]
In 'incomplete' mode, dump only the data, and none of the various set headers (except for \fB*LABELS*\fP and \fB*SPLIT*\fP commands). See the discussion of the hardcopy dialog's Complete button.
.TP
.B \-RemoteConnection
Specify that the X11 connection is (to be considered as) to a remote screen, across a network connection. Currently, this
only means that a good number of XFlush and XSync calls are not executed.
.TP
.B \-ResetAttr
This option causes XGraph to reset the set-attributes for each file read.
.TP
.B  \-rv (ReverseVideo)
Reverse video.  On black and white displays,  this will invert
the foreground and background colours. It is hard to say what it does
exactly on colour displays: that is, it does <max>-<cval> for each of the
red, green and blue components, where <max> is the maximally allowed value, and
<cval> the current value. This is actually a conversion from RGB to CMY or vice-versa.
.TP
.B -SameAttr
This option causes sets to have the same attributes. Currently, this means that automatic designation of linestyles
is switched off, so that each new set will have the same style as its predecessor. The designation with the
.B *PROPERTIES*
command can be used to give group of sets their own styles. Markers are always designated automatically, on the basis
of a set's number.
.TP
.B \-scale_av_{x,y} X
set x,y range to average of x,y +/- X [3,3] times the standard deviation
.TP
.B \-show_overlap [raw]
Toggle option (default off). When on,
.I xgraph
calculates an average overlap between the datasets displayed in each window. This is most useful 
to check whether 2 (or more) sets are identical. In that case, the measure given is 1 with stdv.
of 0. Values not equal to this perfect value-pair are difficult to interpret given the
heuristics of the calculation:
For each combination of two distinct datasets, for each element (up to the last
element of the shortest set;
.I and even if outside
.I the bounding box), 
the overlap between the errorbars is determined, divided by the length of the shortest
bar. This calculation incorporates all transformations, except for axis transformations
(\fB*TRANSFORM_[XY]*\fP etc),
unless the \fBraw\fP flag has been specified, in which case raw data are always used.
Each individual overlap of two points is weight by the sum of the
number of observations (as set with the
.B *N*
command) per point of the two datasets. This results in an overlap-index which is 1 for complete overlap, and 0 for
no overlap, with points/sets with more observations weighted more heavily.
These individual overlaps are then averaged per said combination of two sets.
The overall overlap is determined as average (+- st.dev) of the means and of the standard
deviations over all these overlaps averaged over two sets. The resulting four values are
displayed in the legend box (if more than one set is displayed).
.B Note:
The algorithm assumes that identical elements of datasets have identical X-values. Thus
the calculated overlap only makes sense for sets of curves with (approximately) the same
set of X-values. Testing for mirror-symmetry of two sets by taking the absolute value of the
X coordinates is therefore sadly impossible, as of this writing.
.B Note2:
The discussion above applies to sets with error, or without error. The error-column can also be
interpreted as orientations (vector mode), as intensities, or as marker sizes.
In those cases, the following applies:
If both sets under comparison have one of these "error types", overlap for a point is 1 if both 
Y and orientation/intensity values are equal, 0.5 if either Y or orientation/intensity is equal, and
0 if neither is equal between the two points. If only one of the sets has one of these error types,
that set is assumed to have zero error, and comparison is between its Y values, and the Y values or
Y and error values of the other set.
.B Note3:
A "closeness" of the sets is also calculated. For this, the total Y and Error/orientation/intensity
ranges spanned by the 2 sets if determined first. Then, closeness in this range is determined for Y and E as

1- |v1-v2|/range

and the values for Y and E are averaged per point, and these means are averaged over all points. Again,
closeness is 1 for complete overlap, and decreases towards 0 for complete non-overlap.
.TP
.B -skip_to <label>
Upon reading the next input file, skip over all text until the first occurrence of a "command" \fB*label*\fP (that is, the specified
label between asterisks) is found at the beginning of a line. Processing continues (rather, starts) from there,
including the label command itself. The same thing can be done inside a file, using the \fB*SKIP_TO* <label>\fP command.
.TP
.B \-spa[01], -spax[01], -spay[01]
.IR (-scale_plot_area)
Options that control whether or not the hardcopy dimensions given by maxHeight and/or maxWidth
in the hardcopy Dialog apply to the whole plot [-spa0] (i.e. including the external
legend box, the labels and the axis-numbers) or to only the plot area
(i.e. the region within the axes). To enforce identical scaling on lists of figures, regardless of
e.g. the (length of the) values along the Y axis. This option has limited compatibility with
the \fIpreserve\ aspect\fP function: when either the horizontal (-spax) or the vertical (-spay)
size is adapted, the other is updated to preserve the onscreen aspect ratio. When both X and
Y dimensions are scaled to the plot area, the aspect ratio gets lost.
.TP
.B -splits_disconnect[01]
Modifies the behaviour of the \fB*SPLIT*\fP command; making it behave as a
"lift pen" or rather as a "start new set" instruction. See under \fB*SPLIT*\fP for
a more detailed discussion. Can be set in the Hardcopy Dialog (\fB[SDisc]\fP button).
.TP
.B \-sqrt{x,y}[01]
Don't/Do turn on power scale for X or Y axis (see
.B -pow
)
.TP
.B \-stats
print some statistics about each set and each file or file-subdivision (see
.B *FILE*
) (default 0)
.TP
.B -sV[01]
Toggle verbose scripting. In this mode, many of the "interactive" commands that act on windows and/or the data
in them give feedback on successfull termination.
.TP
.B -SwapEndian[01]
Convert little to big endian (or reverse) when reading binary input (\fB*BINARYDATA*\fP).
.TP
.B \-T <string>
Additional title of a plot. This string is centered at the top of the graph
(outside of the data box),
.I above
any titles specified with
.B *TITLE*
or the
.B -t
option. See the description of the \fB*TITLE*\fP command for a list of valid opcodes that get expanded to various
strings; those pertaining to sets are interpreted for the \fIfirst\fP drawn set (e.g. %CY expands to the last draw set's
Y-column label).
.TP
.B  \-t <string>
Title of the plot.  This string is centered at the top of the graph,
.I under
any titles specified with the \fB-T\fP command line option, or with the
.B *TITLE*
commands in the datafiles. It nullifies all
.I following
.B *TITLE*
commands! See the description of the \fB*TITLE*\fP command for a list of valid opcodes that get expanded to various
strings; those pertaining to sets are interpreted for the \fIlast\fP drawn set (e.g. %CY expands to the last draw set's
Y-column label).
.TP
.B -tar[N] [archive name]
XGraph is capable of extracting datafiles from (compressed) tar and other archives. This is currently a rudimentary and experimental
feature. The syntax is indicated above. A positive \fBN\fP activates the mechanism, and sets the source \fBarchive name\fP.
The first \fBN\fP files specified on the command line are expected to be contained in that archive. Files not existing
in the archive are \fInot\fP read in otherwise, and do not decrease the count. Currently, only a single archive name can be
specified, and XGraph can't make a distinction if 1 file was extracted from the archive, or multiple files.
XGraph will recognise \fIzip\fP and \fIrar\fP archives from their "magic" file stamp, and will attempt to launch the appropriate
command to read the specified file from that archive (the \fIunzip\fP and \fIunrar\fP commands are necessary, respectively; unrar
can be a link to the \fIrar\fP command, or the free un-archive utility available from http://www.rarsoft.com/rar_add.htm).
By default, the archive is supposed to be a tar archive (hence the option's name),
and XGraph will pass the appropriate extraction options to the \fItar\fP
command. This is assumed to be the GNU tar command, that supports -z for compressed/gzipped archives and -y for bzip2'ed
archives.
The idea behind this option is to gain disk space by storing multiple files in a single, compressed archive.
.TP
.B -tas[<value>]
Activates the \fIDetermine Average Slope\fP function (global setting). This calculates, per window, the average slope 
of the lines between non-discarded data points, both in world (graph) and in screen (canvas) co-ordinates. The former
is independent of window/printing size and/or aspect, the latter is. \fI<value>\fP controls the behaviour. 0: off; 1:
on, signed slopes; 2: on, determine average of absolute-values of the slopes.
.TP
-B -tcl[0|1]
Activates calculation of the transformed curve length (for the ascanf \fBtr_curve_len\fP function) \fIwhen support for
this functionality has been compiled in\fP.
.TP
.B \-tellPID[01]
This option makes sense only when the -detach option has been given. It determines on which stream XGraph gives the detaching
progress information, that contains the process ids (PID) of the calling and the child process. Normally, this information
is sent to stderr. When the \fB-tellPID\fP option is activated, the information is sent to stdout, such that it becomes available
e.g. to a programme that spawns XGraph (and wants to send signals to it).
.TP
.B  \-tf <fontname> (TitleFont)
Title font.  This is the name of the font to use for the graph title.
It defaults to 9x15.
.TP
.B \-tk[01], -htk[01], -vtk[01]
This option causes
.I xgraph
to draw tick marks rather than full grid lines.  The -bb option
is also useful when viewing graphs with tick marks only. The \fB-htk\fP and \fB-vtk\fP
versions allow to disable the horizontal respectively the vertical lines of the grid.
Given without numerical option, these commands override the settings specified in the
set-specific \fB*PROPERTIES*\fP commands. Giving a numerical option avoids this.
.TP
.B \-transform_axes[01]
This option controls how the numbers along the axes are shown
when TRANSFORM_[XY] transformation(s) are defined. If set (default),
this processing takes place first, and the axes show the values/ranges resulting from those
transformations, along a normal, linear scale. If not set,
the axes show the input values/ranges, regardless of the transformation; i.e. the same values
(at different - though correct - locations which depend on the transformations taking place.
.TP
.B \-triangle
Draw error "triangles" instead of errorbars. The default width of the triangles' base is equal to
the selected markersize, this in contrast to the default width of the horizontal part of errorbars which is
hardcoded.
.TP
.B -TrueGray[0|1]
Usually, xgraph displays in colour on colour displays. The \fB-MonoChrome\fP option selects
a monochromatic colourscheme, but does not disable colourdisplay. To better judge grayscale
rendition of colourimages (as on a printer or grayscale screen), the TrueGray option selects
a psychometric colour-to-grayscale conversion. That is, the human sensitivity to red, green and
blue is taken into account to convert colour to grayscale, to maintain relative brightness.
This option can also be selected runtime: \fBMod1\fP-clicking on the \fB[XG RGB]\fP button
(visible when XGraph output has been selected) toggles the flag.
Note that setting this flag set has a similar, non-runtime changeable effect as requesting grayscale PostScript
output (the RGB values being set to identical values) - the \fB[PS RGB]\fP button thus no
longer has any effect! The windows' titlebars show "XGg" instead of "XG" as the first word when
TrueGray has been set.
.TP
.B -use_XDBE[0|1]
Activates the builtin support for the X11 Double Buffer extension (see man DBE). Briefly, this X11 extension
(that is supported by most servers) makes it possible to draw in an offscreen buffer, and then do a very
fast swap of the visible buffer and that background buffer, e.g. once the window update has been finished.
This greatly reduces flicker in many cases in which redraws are auto-generated (-fit_after scaling, animations, ...).
But none of the drawing process itself will be visible anymore, of course!
The DBE extension is coupled to certain Visuals that support it. Therefore, this option takes precedence over the other 
arguments, notably over -VisualType (below). The minimal required depth (-MinBitsPerPixel) is honoured, though.
This has not been tested on many different server types yet.
.TP
.B -ValCat_[XY][0|1]
Conditional toggle the ValCat_X or ValCat_Y settings. When set, xgraph expects a \fIvalue to category\fP
mapping to exist for the corresponding axes. This mapping defines a textual representation (the
category) for a given value. When this value occurs along the grid spanned along the corresponding
axis, the category is shown instead of the value. The exact behaviour depends on the corresponding
\fBexact_[XY]_axis\fP setting: in non-exact mode, if a value is not represented in the category-list,
the nearest value that \fIis\fP represented in the list is used instead. In exact mode, this
"distortion" of the grid does not occur. The category lists are defined with \fB*VAL_CAT_[XYI]*\fP.
It is also possible to include a column with \fIascanf strings\fP (strings as valid for ascanf; "string"
or `"string"); via the Settings Dialog those strings can then be loaded into the category
mapping appropriate for the selected axis. The current set selection (including all, previous, etc.) is
used for this. The values associated with the strings are the ascanf address values; these are doubles.
Since these values are generally extremely small, it is likely that the behaviour is not always as
expected. See also the \fBArrays2ValCat[]\fP ascanf function.
.TP
.B -ValCat_X_levels <val>
Defines over how many lines (levels) the X axis ValCategories are displayed. If <val>==3, there will be
3 lines, with the first category drawn on the 1st, the 2nd on the 2nd line, the 3rd on the 3rd line, and
the 4th again on the 1st line, etc. If <val>==-3, the same thing happens except that the 1st category
will be drawn on the 3rd line, etc.
.TP
.B -ValCat_[xy]step
Control the increment rate of the categorical axes. These axes often need a much smaller increment
if all categories are to be shown (= a compensation for the much larger label widths).
The effect of these arguments is overriden by the \fB-[xy]step\fP arguments.
.TP
.B \-vectors <length> (obsolete)
Request type 0 vector mode, in which the data in the "error" column (usually the 3rd) is interpreted
as an orientation for a "vector" to be drawn at the corresponding point. The length of the vectors is
specified by the \fB<length>\fP argument (or \fB*VECTORLENGTH*\fP set-specific command),
and their orientation depends on the current radix specified
by the \fB-radix\fP command: orientation 0 gives a horizontal vector pointing to the right (or left for
a negative vector length). The other
characteristics are the same as for normal errorbars.
.TP
.B \-vectorpars <type>,<length>[,pars]
Request vector mode, in which the data in the "error" column (usually the 3rd) is interpreted
as an orientation for a "vector" to be drawn at the corresponding point. The length of the vectors is
specified by the \fB<length>\fP argument (or \fB*VECTORPARS*\fP set-specific command),
and their orientation depends on the current radix specified
by the \fB-radix\fP command: orientation 0 gives a horizontal vector pointing to the right (or to the left
in case of a negative vector length). The other
characteristics are the same as for normal errorbars. Currently, type 0 gives a simple vector starting
in the datapoint. Type 1 gives a vector that is centered in the datapoint, according to the 1st of the
two-element \fBpars\fP list: if that is e.g. 3 (or 1/3), one third of the vector will point in the
direction specified by the orientation, the remaining 2/3 in the opposite direction. The 2nd value in the
list indicates the relative length of the arrow-head that is drawn in this case: if the values is e.g.
5, the arrow will be approximately 1/5 of the vector's length (the two values mentioned are the default).
As mentioned, a negative vector length inverses the direction of the vector.
Types 2, 3 and 4 make use of the length (\fBlcol\fP) column to determine the vector's length; they thus
ignore the <length> parameter. Type 2 otherwise
behaves like type 0, type 3 like type 1. Type 4 is like type 3, but it uses the <length> parameter to
determine the size of the arrow's head. The difference between type 3 and 4 is thus that the former gives rise to
displays (sets) with variable arrow head sizes, whereas with the latter, all arrow heads (in a set) are of
the same size.
.TP
.B -VisualType <name>
Specify a type of visual (StaticGray, GrayScale, StaticColor, PseudoColor, TrueColor, DirectColor) to
be used by preference. See under \fB-MinBitsPPixel\fP.
.TP
.B -wns[0|1]
A debugging option: WarnNewSet. Causes a message (warning) to be printed on stderr whenever a new set is
started. Under normal circumstances, this is not very interesting. However, the input parser often hickups
on erroneous syntax, with the side-effect of creating a new set (with garbage in it). This can happen
for XGraph command syntax (e.g. trying to enter a list of text lines after a \fB*VERSION*\fP statement instead
of a \fB*VERSION_LIST*\fP statement), or with incorrect (missing ']', ...) or truncated (insufficient read buffer)
ascanf code. In that case, the \fB-wns\fP option helps to trace where this occurs. Note, however, that line numbers
are only guaranteed for seekable input files (not compressed, no pipes).
.TP
.B  \-x <unitname>
This is the unit name for the X axis.  Its default is "X".
.TP
.B \-x_ul[1] <x>,<y>
Place the X unitname at <x>,<y> . This can also be done by Shift-clicking with the
.I 3rd mousebutton
at the desired location. The optional
.B 1
indicates a transformable coordinate-pair.
These coordinates can be changed through the Settings Dialog: when 
.B X
is selected in the selector-box,
the first two fields of the UserLabel-coordinate-entry fields show the X and Y coordinates.
.TP
.B \-XGBounds
Toggles whether or not (default false) the definition of the bounding-box is included
in an XGraph dump. When true,
.B -lx l,h
or
.B -LX l,h
(when the "User" box in the Settings Dialog is set) and
.B -ly l,h
or
.B -LY l,h
statements are included in the XGraph dump.
These statements will have
.B l,h
equal to the values in the Setting Dialog's "Bounds" fields.
.TP
.B -XGDump_PrintPars
Dump the PostScript printer settings to XGraph dumps too. This includes dimensions, fontnames and pointsizes,
X11 window size if the preserve aspect option is selected, scaling, placement, orientation and markersizes.
.TP
.B -XGraph
When given as the first argument (and only then), make xgraph restart (execv(3)) itself immediately, through the startup script
\fBXGraph.sh\fP. This script (see below) allows certain options that have effect only on the commandline to be given
in an XGraph dump (script) file. Any \fB-XGraph\fP options given after (and including) the 1st are ignored; all other options are
passed to the child. \fB-XGraph\fP options happening in the input (your fault, not xgraph's :)) are not ignored, but fire an
error. The same behaviour can be evoked by invoking xgraph as \fBXGraph\fP
.TP
.B -Xincr_factor <f>
.TP
.B -Yincr_factor <f>
.TP
.B \-{x,y}step <value>
Controls the increment rate of labelling of {x,y} axis (default value: 1)
These arguments affect both the normal axes increment, and the
increment of the ValCat categorical axes (settable via -ValCat_xstep and -ValCat_ystep).
.TP
.B  \-y <unitname>
This is the unit name for the Y axis.  Its default is "Y".
.TP
.B \-y_ul[1] <x>,<y>
Place the Y unitname at <x>,<y> . This can also be done by Shift-clicking with the
.I 2nd mousebutton
at the desired location. The optional
.B 1
indicates a transformable coordinate-pair.
These coordinates can be changed through the Settings Dialog: when 
.B Y
is selected in the selector-box,
the first two fields of the UserLabel-coordinate-entry fields show the X and Y coordinates.
.TP
.B -y_vert[1]
Draws the Y unitname (label) vertically, that is, rotated over 90 degrees. Since X11 doesn't 
have builtin support for rotated text, this feature is only supported in PostScript output
(where one can rotate a font together with the line it is aligned on/to). In the X window, the
text will be printed horizontally, with outline(s) showing where/how the string will end up
when printing. One may want to set \fB-mindlegend\fP also to ensure that a label aligned vertically
left of the Y axis does indeed show up in the requested space.
.TP
.B \-zero <epsilon>
treat epsilon as 0 if the data range is larger than this value
.TP
.B  \-zg <colour> (ZeroColor)
This is the colour used to draw the zero grid line. Translated to a psychonometrically corresponding gray
value in the PostScript dump, unless the \fBPS RGB\fP mode is selected.
.TP
.B -zw <width>
This determines the width used for drawing the zero grid line (or the ticks at the zero position(s)).
Since these zero lines are special, they are drawn in the grid width + zero width.
.PP
.SH CAVEAT(s)
Command line arguments used to override settings in the inputfiles, except for options passed through
\fB*ARGUMENTS*\fP. This had the unwanted side-effect that \fB*ARGUMENTS*\fP were overridden by earlier
issued brethren. This notably caused problems when defining default settings in the xg_init.xg file.
It is not guaranteed that all arguments no longer display this behaviour.
.PP
.SH FORMAT COMMANDS
.I xgraph
recognises several Format options in its inputfile. All these start with an opcode at the beginning
of a new line; a word in capital letters between *s. A number of these commands were initially
implemented to provide compatibility with the MultiPlot programme I had on my Amiga home workstation
(a 2000, back in 90/91). I never saw a true reason to devise a better scheme - I like the idea of
saving to ascii files that are readable even without the programme at hand, or can be generated from
a simulation (or data-recording) programme. Some of the commands were renamed since - always maintaining
backwards compatibility. Of course, XML did not exist yet when I started working
on this particular file format - and I don't know whether I would have chosen it if it had. (It is not 
so very readable, and there seems to be a substantial bit of overhead - programming and space.)
And it is easy to ignore (and warn about) unknown opcodes
(e.g. when parsing a file generated with a newer XGraph version). To me, the only alternative would have been to do
everything in PostScript - but it is not my intention to compete with a well-known AI programme :)
The currently known opcodes, loosely sorted alphabetically:
.TP
.B *ENDIAN*<n>
You will not usually need to use this field yourself. It is used by XGraph to keep track of what kind
of endian the machine that generated the current file is/was. Only interesting, but then also
very important, to know when the file contains binary data, which is always stored in the byte-order
of the machine were a file is generated. \fBn\fP is 0 (or \fIbig\fP) for machines with "normal" order, that is, in which
the most significant byte is the leftmost one (big endian), and thus "comes out" first when reading byte-by-byte.
(Or: assigning "wine" to a long would yield the constant 'wine'.) \fBn\fP is 1 (or \fIlittle\fP) for machines
with reversed order, like Intel x86 processors, VAXes, and some old (?, non-Power) IBM mainframes. See also the note
on x86 FPUs below. Other types have existed (PDPs...), but it is unlikely to encounter them anymore.
.TP
.B *BUFLEN* <len>
Increases the size of the buffer's used for reading and parsing data up to
.B maxlbuf=<len>
bytes. If no data has been encountered, the current file is re-read with the new
.B maxlbuf
value.
.TP
.B *VERSION_LIST* <string1>
Starts a block of text (expanding until the first empty line) containing version information. This information
is stored in (appended to) a window-specific version list buffer, that is printed as a new \fB*VERSION_LIST*\fP block
at the head of a next XGraph dump. The \fB*VERSION*\fP also appends information, with the difference that VERSION_LIST
only appends strings not yet appearing in the current version list.
Inside the list, a single \fB*PINFO*\fP on a line of its own is replaced by the current process information.
.TP
.B *VERSION* <string>
This introduces some version information that, together with the current diskfile, the current filename
and the current linenumber is stored in the version list. Diskfile refers to the named file that the
input comes from, and the current filename is either equal to that name, or set with a \fB*FILE*\fP command.
The line number is approximative only. An empty command causes the current date to be recorded as information.
.TP
.B *SET_INFO_LIST* <string1>
Similar to the VERSION_LIST field, except that it applies to individual sets, and that it appends unconditionally.
When points are discarded of a set that already has an info field, the list of discarded points is added to that
field, with a time/date stamp. An empty \fB*SET_INFO_LIST*\fP statement (followed by an empty line...) will 
erase any text already associated with the set.
.TP
.B *DPRINTF* string
Use <string> for formatting of double floating point values to be output. Conventions as described in the
printf(3) manpage apply. Some additional options include the printing of fractions (with a separate option,
or by including a \fB\/\fP character in the format string), and the printing with a specified number of
significant digits. When e.g. specifying the string \fB%!4g\fP (the \fBg\fP actually doesn't matter), 1.0555
will print as 1.056; 10.555 as 10.56; -100.555 as -100.6, etc. Values smaller than 1e-3 and values with
an order equal to or larger than the requested significance are printed in scientific notation. However,
200.0 will be printed as 200, and 0.000 as 0. If this is not acceptable, use \fB%!!4g\fP (%!!ng).
It is also possible to print all doubles in an endian-independant hexadecimal form, of the type 0x<high>:<low>,
where high and low are both 8 byte longs. This format can be read back in by the lowlevel ascanf routines,
and will ensure that all precision is preserved (as with binary dump), using at most 19 bytes (and often less, against
16 for a binary printout), in a textual/printable format. To activate this mode, use the \fB%dhex\fP formatting opcode.
This parameter can also be accessed via the \fB$ValuePrintFormat\fP internal ascanf string variable, via e.g.
\fIprintf[`$ValuePrintFormat,"%!4g"]\fP.
Omitting the string parameter selects a format string that will print the full resoluton (platform-dependent).
.TP
.B *AXVAL_DPRINTF*string
Specify a string to format axes values. See the discussion under \fB*DPRINTF*\fP.
.TP
.B *AXVAL_MINDIGITS* n
When no specific format for the axes values has been specified, XGraph uses an internal heuristic. This
formats numbers in either scientific notation with \fBn\fP decimals, or in decimal notation with \fBn\fP or \fBn+1\fP
decimals. \fBn\fP defaults to 2. When fractions are allowed, the fraction corresponding to the number being printed
will be used when it results in a string not longer than the "orthodox" format.
.TP
.B *Set* n,T [(N)]
This command is used only to compare the specified setnumber
(\fBn\fP) with the current setnumber, while reading data. A mismatch indicates a (possible) change
of the inputfile, which *may* mean that some arguments specifying set-lists may have become invalid.
It also allows to maintain the correct linking of UserLabels, so even when generating an XGraph file yourself,
you do well including this command.
\fBT\fP keeps trace of the total number of sets (determined on the fly while dumping, so not necessarily
underestimated :)), and is used only for progress-display while reading from a pipe (where no file size/position
is available).
The optional \fBN\fP gives the real setnumber when a dump is made of a collection from which sets are excluded
(this option is not interpreted in any way).
.TP
.B *TITLE* <title>
define a plot title. For sets, the opcode \fB%X\fP is substituted by the current X column; \fB%Y\fP by the
Y column; \fB%E\fP by the error column; \fB%F\fP by the set's filename;
\fB%N\fP by the set's name as shown (also) in the legend; \fB%P\fP by
the number of points, \fB%R\fP by "raw" or "ripe" depending whether raw data or processed data is show for the
set; \fB%S\fP by the setnumber; \fB%V\fP by the number of points currently visible; \fB%CX\fP by the set's X column entry in the
\fB*COLUMNLABELS*\fP table; \fB%CY\fP idem for the set's Y column entry (and so on with \fB%CE\fP, \fB%CV\fP, \fB%CN\fP; use
\fB%Ce\fP for a conditional representation of the 'error' column).
For the global title strings, these set-specific opcodes are interpreted for the first drawn (-T title) and last drawn (-t title)
set.
In addition, there is the opcode \fB%[name]\fP that will include the name, value(s) or code of the fascanf variable/array/procedure
OR environmental variable \fIname\fP - if it exists.
Embedding the titlestring in backquotes will cause it to be replaced by the expanded/parsed string, without
the quotes.
.I xgraph
will show all titles of the datasets being shown on subsequent lines as long as they are not a repetition of (equal to) the previous
line. The \fB-AllTitles\fP option can be used to deactivate this filtering; this option can also be accessed by <Mod1>-clicking
on the [No tit.] button in the Settings dialog.
Control-Clicking
inside the title area of the plot will pop up a small (well,
depends on the
.I dialogFont)
showing the titles. This can be handy in case of
a small graph window, or large
.I titleFont.
.TP
.B *XLABEL* <x-axis label>
specify the label for the X-axis. When a
.I \+
is appended to the label command, the axis-label is concatenated to a previously
specified label. The same opcodes are recognised as defined for the \fB*TITLE*\fP strings; the opcodes pertaining to sets are
interpreted for the first drawn set (e.g. %CY evaluates to the first drawn set's Y-column label).
.TP
.B *YLABEL* <y-axis label>
specify the label for the Y-axis. When a
.I \+
is appended to the label command, the axis-label is concatenated to a previously
specified label. The same opcodes are recognised as defined for the \fB*TITLE*\fP strings; the opcodes pertaining to sets are
interpreted for the first drawn set (e.g. %CY evaluates to the first drawn set's Y-column label).
.TP
.B *COLUMNLABELS* [new]  <column>,label
Constructs a table that associates a label string to column numbers.
The optional \fBnew\fP option first deletes
any existing associations. The association is specified on the lines following the keyword, and terminated by an empty line. Each
line defines a single column to label association, formatted as \fBcolumn,label\fP. All text following the comma is
taken as the label (a string) associated with the \fBcolumn\fP, which may be an expression.
This table can be used e.g. in set legends, to show in the legend what is plotted against what, with opcodes. For example:
\fBY column %CY vs. X column %CX, errors=%CE, Nobs=%CN\fP. It can also be used in the title(s) and the axis labels (*XLABEL*,
*YLABEL*). For the global labels (axis, -t and -T title), these opcodes are interpreted for the first drawn set (axis labels
and -T title) or for the last drawn set (-t title).
.TP
.B *LABELS* [new]
This constructs a table similar to the (global) one constructed by \fB*COLUMNLABELS*\fP, except that it is set-specific (and it
overrides this global table). The format is different: it is such that it should function in combination with the \fBx-plot\fP and
\fBX-plot\fP scripts (that "cut" specific columns from the input before passing it to xgraph). Thus, the \fB*LABELS*\fP command
expects a line of label strings, one for each column, separated by the current data-separator (by default a TAB character, and
anything but a space). A newline also starts a new label, but this would of course undo the compatibility the the x-plot and
X-plot scripts. The command reads up to the first empty line. Caution: Do not put (escaped) tab characters in the labels!
When column labels have been defined (either through *LABELS* or through *COLUMNLABELS* or again through the Settings dialog),
selecting columns in the Settings dialog becomes easier. In that case, the buttons in the corresponding entry fields are activated
and open a popup menu that shows the column labels, so that one can choose based on that information, rather than having to
enter a number.
This data can be retrieved and modified through the \fBSetColumnLabels\fP function.
.TP
.B *?LABEL_TRANS*
specifies the corresponding (X or Y) label when
.I raw_display
is not in effect.
.TP
.B *XYLABEL* <x-axis label>
specify the label (XUnits) for the X-axis, or maybe (if in a "Y" (i.e. 2nd) column)
the label for the Y-axis.
.TP
.B *YXLABEL* <y-axis label>
specify the label (YUnits) for the Y-axis, or maybe (if in an "X" (i.e. 1st) column)
the label for the X-axis.

Both commands also store the label per set. They can also be specified as
.B *Xlabel* *Ylabel* *XYlabel* *YXlabel*
(i.e. the "label" part in small letters), in which case the label is only stored per set,
and is not included in the "global" axis-label. Per-set Y-axis-labels can be shown in the
legend-box, instead of the fileName (e.g. with the
.B -lb
option)
.TP
.B *FILE* <filename>
specifies a filename, and makes sub-divisions in one file. When requested, xgraph shows
these names in the legendbox, "linking" sets with the same filename. Such
.I groups
can be changed with the "split" button in the Settings Dialog. A filename can also be
changed. In this way, a common property (e.g. "N=1") shared by a number of sets can be
graphically indicated. The name shown for a group is always the name of the last
set in a group. Hence, to make a new filename visible, "split" at the next set.

When the filename given is different from the current filename,
xgraph assumes it's reading a new file. Thus,
.B *FILE*
statements in a (concatenated) file have same result as specifying the different parts as individual
files on the commandline. When filename is empty
or equal to the current, only a new subdivision is made.

When given as
.B *file* <filename>
the new (file)name is set, but no (sub)division is made. This is like changing the filename
through the Settings Dialog without "split"ting. Its main use is probably to correctly
save (changed) filenames in an XGraph dump.
.TP
.B *N* <integer number>
specifies the number of observations made per point in the current set. This is used
when the
.B -stats
option has been given to calculate per-set statistics, and by the 
.B overlap
and
.B *AVERAGE*
algorithms. It defaults to 2 (the minimum that can yield an average and standard deviation).
This value can be accessed through the 4th "multipurpose" field (actually intended for showing
UserLabel coordinates) in the Settings Dialog.

\fINote:\fP When xgraph has been compiled with the \fBADVANCED_STATS\fP flag set to \fB1\fP (this can be verified by checking
the syntax for the \fBNumObs\fP \fIfascanf\fP function: with \fBADVANCED_STATS==1\fP, this is
\fBNumObs[setnr[,index]]\fP), this value is also copied into a per-point value. Average sets
store the true number of observations in the per-point value (which cannot be changed), and the average
number of observations (which can be changed through the Settings Dialog as mentioned above) in the per-set value. This
latter value is saved when an XGraph dump is made.

When this same, pompously named, flag \fBADVANCED_STATS\fP is set to \fB2\fP, an additional "column-specifier" becomes
available, next to the xcol, ycol and ecol specifiers. In this case, the per-point number of observations is taken
from the specified column, which is of course a bit more practical. The settings dialog will have an additional
input field in this case. This setting is currently the default. When no ncol is specified, or when it is a
negative number, the average value (see \fB*N\fP) is used for all points in the set.
.TP
.B *INTERVAL* N
Specifies an interval at which points in a set are drawn. If N=10, every 10th point is drawn, the rest is not
(nor transformed). When \fBXGStrip\fP is selected in the Hardcopy Dialog, only the points actually shown are
dumped to \fBXGraph\fP or \fBSpreadsheet\fP output, otherwise an \fB*INTERVAL*\fP statement is included
in such output.
.TP
.B *ADORN_INT* N
Specifies an interval at which points are adorned with markers, errorbars and/or vectors, etc, if so requested. The
1st and last points are always adorned. This option has no effect on the drawing of error-regions, since these
are more global structures. 
.TP
.B *LEGEND* <set_name>
specify the name of a set. Legends can be spread among multiple lines by embedding
a newline (\fB#x0a\fP, \fB#xn\fP or the standard \fB\en\fP) at the desired place(s).
The same opcodes are defined as in Title texts: \fB%X\fP is substituted by the current X column; \fB%Y\fP by the
Y column; \fB%E\fP by the error column; \fB%F\fP by the set's filename;
\fB%N\fP by the set's name as shown (also) in the legend; \fB%P\fP by
the number of points, \fB%R\fP by "raw" or "ripe" depending whether raw data or processed data is show for the
set; \fB%S\fP by the setnumber; \fB%V\fP by the number of points currently visible; \fB%CX\fP by the set's X column entry in the
\fB*COLUMNLABELS*\fP table; \fB%CY\fP idem for the set's Y column entry (and so on with \fB%CE\fP, \fB%CV\fP, \fB%CN\fP).
In addition, there is the opcode \fB%[name]\fP that will include the name, value(s) or code of the fascanf variable/array/procedure
OR environmental variable \fIname\fP - if it exists.
Embedding the string in backquotes will cause it to be replaced by the expanded/parsed string, without
the quotes.
.TP
.B *LEGTXT* legend text
Same as *LEGEND* command: with this variant, all text after the *LEGTXT* statement upto
the first blank line is concatenated (with embedded newlines). If this set already had its
name set, \fB*LEGTXT*\fP appends to the previous name, otherwise it sets the new name (i.e.
renames, erasing the default setname).
.TP
.B *ASS_NAME* <index>::string
.TP
.B *ASAS_NAME* <index>::string
Labels one of the \fBfascanf()\fP statistics respectively angular statistics bins; \fBindex\fP defines the bin number,
\fBstring\fP is the label. When the bin number specified is larger than the current maximum, the fascanf arena is expanded to fit, which
entails a reset of all information present in that arena.
.TP
.B *ASSOCIATE* [<expressions>]
This statement associates the results of the evaluated fascanf \fBexpressions\fP (as in a \fB*EVAL*\fP command) with
the current set. Set-associations are arrays of floating point numbers that can be queried with fascanf functions (discussed
below). Multiple \fB*ASSOCIATE*\fP commands append; not specifying any expression removes the current associations. Caution
is thus needed when generating associations with data saved in XGraph format by external applications: associations assigned
to a set that remained empty will show up in the next set (before that set's associations), unless an empty command is
inserted before each \fB*ASSOCIATE*\fP command (consider this a feature :)). This command
can have side-effects on the ascanf buffers because it increases the maximum number of arguments when needed (see \fBMaxArguments[]\fP).
.TP
.B *VALUEMARKS* [ON] [RAW] [FULL]
When one of the shown opcodes is passed with this command, each point can have a textual label that shows the
co-ordinates (values) of that datapoint. The \fBON\fP token toggles the display of the label. The other two
determine whether these labels show the raw, untransformed/unprocessed data (\fBRAW\fP), and whether the
error/intensity/orientation is included (\fBFULL\fP). The format is slightly different between sets plotted
as histograms (barplots), and other sets. In the former case, the X co-ordinate is not shown; in the latter
case, the whole label is enclosed in parentheses. The label is shown centered above the (transformed) datapoint,
or under it when the Y co-ordinate is negative. The \fB-overwrite_marks\fP and \fB*ADORN_INT*\fP settings
also apply to the displaying of these labels.
.TP
.B *BARPARS* brb,brw,brt
Sets set-specific values for barbase, barwidth and bartype. See the discussion of the commandline arguments
\fB-brb\fP, \fB-brw\fP and \fB-brt\fP. Specify \fBNaN\fP for either \fBbrb\fP and/or \fBbrw\fP to unset
the set-specific value(s), and use the global values under commandline control.
.TP
.B *ERROR_POINT* <nr>
When <nr> is not -1, it specifies the datapoint in the current set which will show
its error (or the average error) or orientation (in vector mode). If larger than the number of points in the set, only the last
point of the set will show its errorbar. A value of \fB-2\fP displays on the errorbar on the first (= lowest point nr.)
point that has a non-zero error, a value of \fB-3\fP only on the last point with a non-zero error. A value of \fB-4\fP
displays the bars on both first and last points with non-zero error/orientation. When \fB-5\fP, those first & last points
are drawn in highlighting opposite to the set's highlighting; with the rest of the error/orientations drawn normally.
Can be set/changed through the Settings Dialog, via the 3rd UserLabel-coordinates-entry field ....
NB: this setting is ignored in intensity mode.
.TP
.B *ERROR_TYPE* <t>[,<width>]
Specify the error type <t>. For the available types, see elsewhere in this document. The width specifies 
the errorbar's (or triangle's or box's) width. As with barplot bars, a positive value specifies an
absolute width, a negative value an automatically determined width, and NaN means use the default (see
under -brw).
If not specified, or NaN, the default value is used.
NB: this command affects not only the current set, but also all sets that do not have a specific error-type specified.
.TP
.B *ARROWS* B|E|BE [orn1[,orn2]]
\fBB\fP: draw an arrowhead at the beginning of this trace; \fBE\fP: draw one at the end of the trace;
\fBBE\fP: draw both. For this, the trace's first or last segment with non-zero length is found, and
the arrowhead is drawn using the orientation of that segment. If no such segment exists, the trace
is actually a point, and no arrowhead(s) drawn. \fINB\fP: this routine doesn't always draw the same
arrow as a human would... To remedy this, the orientation(s) can be specified as an angle in degrees. 
No specification, or a value of \fBNaN\fP means to use the automatic orientation for that arrow. These
orientation values can be changed from the Settings Dialog; the computed or specified values are shown;
setting them to some number fixes the orientation to that value, setting to \fBNaN\fP re-activates
automatic orientation.
\fB*ARROWS*\fP without arguments turns off the arrowheads.
.TP
.B *POINTS* <nr>
Specifies a number of points to initially allocate when starting reading a new set. Normally,
xgraph initially allocates 128 points, increasing the allocation when necessary. When a
set is finished, the memory occupied by unused points is given back to the system, an the
initial allocation size is updated with the number of points in the current set. That is,
xgraph expects the next set to have as many points. The *POINTS* statement can prevent numerous
reallocations when reading in huge sets, and prevents unnecessary memory allocation. (These
advantages apply only for the first set.) XGraph dumps contain *POINTS* statements whenever
a set has a different number of points than the previous. On loaded systems, the increased
efficiency can result in faster response and less swapping.
.TP
.B *BINARYDATA*
This flag marks the start of a section with the datacolumns dumped as binary. The format consists of one field per datapoint
(corresponding to a line in the ASCII format):

<N><val1><val2>..<val N-1>

In which \fB<N>\fP is a 16bit short indicating the number of values following, and \fB<val i>\fP is by default a IEEE double (8bytes on most
platforms - xgraph uses the C \fIdouble\fP throughout). A section with binary data is terminated by the sequence

<zero>\\n

Where \fB<zero>\fP is a 16bit zero (0 columns following...), followed by a newline. In a binary section, no other commands are
expected (= : they shouldn't be there!), but they can immediately follow the terminator (e.g. a \fB*SPLIT*\fP command). The first
number of columns (\fB<N>\fP) specified in a section redefines any previous number of columns specified for the set! If a field
specifies less columns than this values, the remaining columns are set to 0; higher numbered columns are ignored (=> give rise
to read errors which can cause xgraph.!). Note however that the binary writing routines can (and will) generate occasional newlines in the output. This may lead to incompatibilities across platforms with different line-ending protocols... On Windows/MSDOS, this can be avoided by selecting opening "binary mode" files, which is what xgraph does (even if it doesn't run under DOS ;^)).

Binary I/O can be substantially faster (and doesn't loose precision), at the loss of some flexibility (no editing possible,
(almost) no error correction or even messages), and possibly larger files (that compress less good - at full precision, a
gzipped ASCII dump is slightly smaller than the binary dump). Note that when reading files from a different platform
(e.g. an Intel PC) may require the use of the \fB-SwapEndian\fP flag to correct "endianness".
.TP
.B *BINARYDATA* lines=<l> columns=<c> size=1|2|4|8 [swap-endian=-1|0|1]
.TP
.B *BINARYDATA* l=<l> c=<c> s=1|2|4|8 [se=-1|0|1]
With this form of binary, "free input" can be read. Starting from the line below this command, a binary dump is
expected consisting of <l> lines of <c> columns of floating point numbers of \fIsizeof(float)\fPs (4) or \fIsizeof(double)\fPs (8)
bytes long. When the optional flag \fBswap-endian\fP is \fB1\fP, xgraph will reverse the order of the bytes of each number
read to accomodate for different machinetypes. When the flag is missing, or when \fB-1\fP, the setting specified with the
command line option \fB-SwapEndian\fP is used.
As of 19990629, this "free format" is also the format used when dumping a binary XGraph file. In most cases, that is: when
points are (to be) discarded from a set, or a set is to be split, this set is dumped in the other, more robust (and slower..)
fashion.
The output \fBsize\fP/precision can be set through the \fI-DumpBinary\fP option and/or via the print dialog.
As of 20080724, XGraph also supports 16bit and 8bit integers as storage format (the \fB2\fP and \fB1\fP size switches above).
It will make use of the \fB*EXTREMES*\fP information to translate to and from floating point values. Note that there is
little guarantee that no information will be lost during the conversion - and NaNs and Infs are not
supported in these integer formats.
.TP
.B *Cxye*x,y[,e,...]
Statement that tells xgraph how the 2 or 3 columns data are to be interpreted, if the
.B -Cauto
option has been given. Only the first 2 or 3 arguments matter.
Xgraph always expects 2 or 3 columns of data. These can of course be taken from a larger set,
e.g. with the
.B x-plot
or
.B X-plot
commands discussed below. These commands make a selection of columns using the
.I cut(1)
(called by the plot-cut command from the distribution). The cut-selection passed to cut
with the
.B -f
option, is inserted before the other output (i.e. the data). Since cut always preserves the
order of the columns (i.e. cut -f 30,20,10 results in output with the columns 10,20,30), xgraph
can infer from the cut-selection which column should be interpreted as x, y, or error.
.TP
.B *COLUMNS* N=<NCols> x=<xcol> y=<ycol> e=<ecol> [n=<ncol>] [L2=<setnr>]
Specify for the current set only the number of columns it will have, and the numbers of the
columns with X, Y and Error values. Note that the \fBplot-cut\fP utility strips these commands, so
a customary \fB-Columns\fP argument has to be passed! The optional \fBn=<ncol>\fP sequence is read
only when compiled with \fBADVANCED_STATS==2\fP (the current default). This specifier indicates from which
data column the number of observations per point is to be taken. When missing, or when \fBncol<0\fP, the global/average
value specified through \fB*N\fP is used for all points in the set.
The optional \fBL2\fP option permits to link this set to another set, e.g. to provide another view on that set's data.
.TP
.B *SPLIT* <reason>
When \fB-splits_disconnect0\fP has been specified, this command tells XGraph to lift the pen between the previous
and the current point, introducing a gap/discontinuity (no effect of course on a scatterplot...). When
\fB-splits_disconnect1\fP (the default), split a non-empty dataset, creating a new one starting with the data immediately
below the
.B *SPLIT*
command. The
.B <reason>
for splitting is appended to the legend of the new set, which is inherited from the
legend of the split set (appending takes place once all data is read). A
.B *SPLIT*
command given at the start of a new set only appends the <reason> to the new set's
legend. See also
.B \-disconnect.
\fINote:\fP this command has nothing to do with the Settings Dialog's "split" option. This
latter button allows to create/split-up groups of datasets. The *SPLIT* command splits
a dataset, and can be used only when reading the data from file.
\fINote 2:\fP sets can also be split at runtime, with the fascanf \fBsplit\fP command. This
command splits \fBat\fP the current point, just like the interactive, mouse-driven \fI"cut-mode"\fP
(see below), which it does not interfere with (i.e., a split indicated with the mouse cannot be
undone with a \fIsplit[0]\fP in a transformation). A \fIsplit[1]\fP causes a \fB*SPLIT* tcut\fP command
to be inserted in the next XGraph output (when dumping processed values!), a mouse-driven split
inserts a \fB*SPLIT* mcut\fP command, regardless of whether raw or processed values are being dumped.
.TP
.B *XAXISDAT* <MajTic>(unsupp) <SubDiv>(unsupp) <axmin> <axmax> <axlog> <dum> <more>
.B				<more> =
number of lines to skip
.TP
.B *YAXISDAT* <MajTic>(unsupp) <SubDiv>(unsupp) <axmin> <axmax> <axlog> <dum> <more>
.B				<more> =
number of lines to skip

These commands can also be used to change the bounds of the axis or axes from a script file. In that case,
the autoscaling must first have been switched off.
.TP
.B *GLOBAL_COLOURS*
Define global colours. This reads lines up to the next empty line, expecting a format \fBopcode=colour-spec\fP, one
per line. \fBopcode\fP can be one of \fIblack, white, bg, fg, bdr, zero, grid, hl\fP, touching respectively the
definitions of black, white, the background, the foreground, the border, the zero-lines, the grid, and the highlight
colours. Using this command implies customisation, which is (probably.. ;-)) to be preserved: the next XGraph
dump will therefore store these global definitions \fBand\fP the individual set-colour definitions.
.TP
.B *PROPERTIES* 1 <errorFlags> <AxSpec> <margin>(unsupp)
.I Global settings.
.B <errorFlags> =
0: ticks, nobox; 1: grid, nobox (default); 2: ticks, box; 3: grid, box. 10,11,12,13
equal 0,1,2,3 with zerolines.
.TP
.B *PROPERTIES* colour=<colour> flags=<type> linestyle=<linestyle> mS=<IGNORED>
.B lineWidth=<linewidth> elinestyle=<error-linestyle> marker=<marker> elineWidth=<error-linewidth>
.B [markSize=<markerSize>] [cname="<colourspec>"] [hl_cname="colspec"]

.I Set-specific settings.

.B <type>
is specified as a 16bit hexadecimal number:
.I 0xXXXXXXXX
with the bits set as followed (starting from the
.I least significant
bit) (between parentheses, the commandline option with the same, global effect is given):

.I bit 0:
set if scatter (
.B -nl
)

.I bits 1,2:
.I 00=
no marks;
.I 01= -p, 10= -P, 11= -m

.I bit 3:
set if barplot (
.B -bar
)

.I bit 4:
set if marks (-m) overwrite (
.B -overwrite_marks
)

.I bit 5:
set if this set's legend is to be shown (
.B -show_legend
)

.I bit 6:
set if this set's errors are not to be shown (
.B -noerr
)

.I bit 7:
set if this set is to be highlighted

.I bit 8:
set if this set is to be skipped by \fB*DATA_PROCESS*\fP transformations (\fIraw\fP).

.I bit 9:
set if the set is marked. Unmarking (i.e. when the bit is not set) is done only when reading
data into an existing window.

.I bit 10:
Set when this set is never to show a line in the legend, just a marker when the set has markers.

.I bit 11:
Set this bit to exclude this set from autoscaling, i.e. to make it "float". NB: when set, points
are clipped against the windowborder, and not within the axes!

For backwards compatibility, the following
.I decimal
values are also possible:
.B <type> =
0: line; 1: scatter (-nl -m); 2: scatter,line (-m); 4: bar (-bar -nl -m)

.B <linestyle> = 1:
solid line (idem for
.B <error-linestyle>).
.B <error-linestyle> < 0:
use 
.B <linestyle> (similarly, \fB<error-lineWidth>\fP<0 means use the current (new)
\fB<linewidth>\fP).
Other values give other line-styles...

\fB<marker>\fP is used to specify the number of the marker, if distinctive markers are used (\fB-m\fP).
To specfify a specific marker, use a number >= 1. Values <= 0 are ignored; when saving an XGraph dump,
markers assigned by default are saved as negative numbers (just for your information).

The optional \fBmarkSize\fP is used to specify a set-specific marker size (the "radius"!). When absent, the global default
defined by the option \fB-PSm\fP is used. A \fInegative\fP set-specific marker size can be given to
define the markers' size in "world" co-ordinates. This is probably useful only when using the intensity
plot option to generate 3D plots where the 3rd dimension is coded as intensity. In this case, setting
the markers' size to -1 times the inter-point distance ensures that they touch each other seemlessly
(well.. in PostScript output..; round-off errors will certainly occur in screen output).
When the values in the error column are interpreted as marker sizes, the \fBmarkSize\fP value acts as
a scalefactor on the size values, if it is not a NaN or Inf.

The optional \fBcname\fP construct can be used to specify a set-specific colour (name or RGB value). Doing
so implies that this colour is important, and that it is to be preserved when next making an XGraph dump.
Caveat: an invalid colourspecification is ignored, causing the set to be drawn -- and dumped.. -- in/with
its default colour. When a colour has been changed runtime, its new setting will be save only by selecting
"XG RGB" manually in the Print Dialog. \fBcname\fP is ignored if \fB-IgnoreCNames\fP has been given as
an argument, making it possible to re-link (or maintain the linkage of) the set-colours to the
current foreground colour (when in \fB-monochrome\fP mode!).

Similarly, the optional \fBhl_cname\fP construct specifies a set-specific highlighting colour, other than the
default colour set with the \fB-hc\fP commandline option. Labels linked to this set will be highlighted with
the same colour. If this set's title is displayed, it will be highlighted in the same colour too, provided no
other set with the same titletext, and different or no highlighting has been drawn before (..!).

The somewhat illogical order of parameters is due to historical reasons - i.e. for backwards compatibility.
It is possible to give only the \fBcname=""\fP and/or \fBhl_cname=""\fP fields if only a specific colour is
desired.
.TP
.B *SCALEFACT* <XScale> <YScale> <ErrorScale>
specify file-wide scale factors
.TP
.B *SCALFACT* <XScale> <YScale> <ErrorScale>
specify set-spec. scale factors
.TP
.B *EXTRATEXT*
Starts a comment section that extends up to the next empty line
.TP
.B *ECHO* [stdout|verbose]
Same as \fB*EXTRATEXT*\fP, except that the text is echoed on the standard error (or standard output if the
\fBstdout\fP flag is given), and
not included in the comment section. The opcode \fB*FINFO*\fP immediately after the *ECHO*
opcode, or on a line of its own outputs some information about the file currently being read.
Similarly, the opcode \fB*PINFO*\fP generates some information about the current XGraph process,
arguments, input files, etc.
If the \fBverbose\fP flag is given, output is suppressed \fUunless\fP \fB-debug\fP or \fB-sV\fP has been specified
(debug or scriptVerbose mode is active).
.TP
.B *POPUP*
Same as \fB*ECHO\fP, but the information is sent to a popup window and to standard error.
.TP
.B *ELLIPSE* <X> <Y> <X-radius> <Y-radius> <#points> [rotation]
Believe it or not.
.IR xgraph
.B is
a utility for plotting data. This command generates a closed ellipse of
.B <#points>
points at location
.B <X>,<Y>
and with radii
.B <X-radius>,<Y-radius>
potentially rotated of \fBrotation\fP degrees (with positive == counterclockwise).
It does so by calculating the requested number of points, and not by
inserting a graphics command.
.TP
.B *ARGUMENTS* <commandline arguments>
gives (additional) commandline arguments (see above). It is likely that
some arguments have an effect only when specified on the real commandline. The following properties/options
are applied to all sets following and including the current set:
.I lineWidth, -m/-p/-P, -nl, -bar, -triangle, -polar, polarBase.
.TP
.B *PROCESS_HISTORY*<exp>
Add <exp> and all lines following the statement (upto the first empty line) to the history of executed expressions that
is "consultable" as a popup menu in the settings dialog. A \fB*PROCESS_HISTORY*\fP statement alone (newline immediately
after the asterix) can be used to reset the history. Append a '@' (as a last character before an eventual newline)
to any <exp> to prevent it from being included (practical for very long statements that would make the menu too wide).
.TP
.B *CLEAR_COMMENTS*
Clears the comment buffer.
.TP
.B *LOAD_MODULE* [export][auto][nodump][comment]
.TP
.B *UNLOAD_MODULE* [force][all][export][comment]
.TP
.B *RELOAD_MODULE* [force][export][auto][nodump][comment]
This command allows to load dynamic modules (shared libraries). It reads up to the next empty line, interpreting each
line as a filename of a module to be loaded via dlopen(3). A module filename can be a complete pathname, or partial
one. In that case, if the file does not exists "as is", xgraph will look in ~/.Preferences/.xgraph, before letting
dlopen() search in the system defined shared library path. Libraries can be unloaded in a similar fashion, using the
command \fB*UNLOAD_MODULE*\fP. A module can be reloaded with the \fB*RELOAD_MODULE*\fP command. Note that unloading
a module may have undefined effects on compiled ascanf code making references to symbols defined in the module! 
XGraph makes an attempt at keeping track of which parts of which compiled code references which loaded functions, and
to remove these references when the library is (force) unloaded (this will of course change the code's behaviour...).
Nevertheless, it is quite likely that the programme will crash with a segmentation violation or bus error when there were
problems with this registry.
Therefore, modules of which
entries are in use are not unloaded by default, unless the \fBforce\fP flag is given to either *UNLOAD_MODULES* or *RELOAD_MODULES*
Additionally, all procedures that reference symbols in a library being unloaded will be deleted when the \fBforce\fP flag has
been given. When the \fBall\fP option is given, all currently loaded modules are unloaded; the following lines are then
ignored.
A reload may or may not load the same symbols at the same address.
Also note that the module
filenames must be the same across invocations: an intially loaded \fI./lib.so\fP will not be reloaded as \fIlib.so\fP!
Currently, there is only support for libraries that extend the ascanf language by adding additional function definitions,
and libraries which provide "generic support". For the latter, it is probably a good idea to load them with the \fBexport\fP
flag, such that their symbols are seen by other modules that may be loaded later. Else, these modules must have been
"marked" at compile time as needing a specific dynamic support library by linking them specifically with this/these
library/ies. The \fBexport\fP flag (which must come after the \fBforce\fP flag for the \fB*RELOAD_MODULE*\fP command)
internally adds the \fIRTLD_GLOBAL\fP flag to the dlopen(3) invocation.
The \fBauto\fP flags indicates that this library should be unloaded as soon it is detected that it is no longer used. Currently,
this only makes sense with \fIascanf\fP libraries; checking is done while discarding compiled expressions.
See dm_example.c (dm_example.so) for an example.
Consequently, module loading commands are only exported to XGraph dumps when DumpProcessed is not selected; the \fBnodump\fP flag
also has the effect of not exporting a particular library.
Dynamic modules can also be loaded by loading them as any other file (on the commandline, etc.).
These features are available only when xgraph has been compiled with the XG_DYMOD_SUPPORT flag.
Failure opening a library from with a commands file will cause the remainder of that file to be skipped!
NB: trying to open an executable file cause xgraph to crash on my linux system (glibc 2.1.3; this appears to be a bug
in dlopen(3))!
As of 20080901, module names can be specified without the platform-specific extension (this text still refers to \fI.so\fP
libraries). The loader will attempt to load libraries with a number of different extensions (.dylib, .so, .dll) if the
specified name doesn't load at once.
.TP
.B *DM_IO_IMPORT* io_module [datafile]
.TP
.B *ASK_DM_IO_IMPORT* Message::io_module[::datafile]
Generic mechanism for IO to/from external formats. <io_module> is a dynamically loadable module of the \fBDM_IO\fP type,
which provides routines for importing and exporting. (Currently, only importing is implemented.) Importing is done
in transparent fashion, i.e. if the imported data were found in 'native' format at the place of the import command. Thus,
it will be stored in (appended to) the current dataset, etc. The data is read from <datafile>: in case this parameter is missing,
it will be read from the current file. It is thus possible to just prepend the command tag with the appropriate IO module to
an external datafile (ex: an xml file.)
The \fB*ASK_DM_IO_IMPORT*\fP command functions similarly, except that it presents the user with a dialog, showing the <Message>,
giving an indication of which module will be used, and giving the possibility to change the default <datafile>.
For both commands, it is allowed to "preload" the IO module using \fB*LOAD_MODULE*\fP: this is even necessary when the module
relies on internally defined ascanf variables to control aspects of its behaviour. Note that when \fB*LOAD_MODULE*\fP was
used to load the IO module, an explicit \fB*UNLOAD_MODULE*\fP may be necessary to prevent the module loading command
from being exported to an XGraph dump of the resulting dataset.
XGraph comes with a few example importers. The only one of general interest is \fBCSVio\fP, which automates the process of importing
CSV ascii files (only tab-separated, at the moment). It determines the number of available columns, will interpret the 1st line as
column labels if consisting only of strings, and allows to limit the import to specific columns of interest.
Data loaded in this fashion will have the name of the file containing the DM_IO_IMPORT statement associated with them, \fUnot\fP \fB<datafile>\fP. There may be additional metadata stored in the receiving set's info string, but this depends on the IO module.
.TP
.B *IF* <expression>
.TP
.B *ELSE* | *ELIF* <expression>
.TP
.B *ENDIF*
.TP
Conditional reading/parsing. When the expression of the *IF* statement evaluates to True, read up to the next matching
*ELSE* or *ENDIF*
statement, or to end-of-file. When the expression is False, the file is scanned (without parsing) upto the next matching
*ELSE* or *ENDIF* statement (or end-of-file), after which evaluation restarts. These conditional statements can be
nested. NB: indentation of \fI*flags*\fP is possible, but only tab characters are allowed!
An *ELSE* followed by an *IF* statement can be shortened into an *ELIF* statement.
.TP
.B *CONDITIONAL_EXTRATEXT* <expression>
Starts a comment section that extends up to the next empty line if \fBexpression\fP evaluates to True.
This is equal to an \fB*EXTRATEXT*\fP command preceded by an \fB*IF* <expression>\fP command.
.TP
.B *READ_FILE*<path>
.TP
.B *Read_File*<path>
.TP
.B *read_file*<path>
Insert the file specified by <path>. If <path> starts with a '|' as
.I its first character,
the remainder is interpreted as a pipe to read from. The input may
contain data, commands (e.g. a filter definition), or comments (i.o.w.,
anything acceptable as xgraph input). The \fB*Read_File*\fP version includes only one copy of
an include-file per "parent" file -- thus, an included file can include itself, and a next
file to be read can include another copy. The \fB*read_file*\fP version includes only one copy
in total.
If \fIpath\fP is the name of an ascanf variable (or an expression evaluating to one) that has a string associated
with it (or is a stringpointer), then this string will be used.
.TP
.B *2ndGEN_READ_FILE*<path>
.TP
.B *2ndGEN_Read_File*<path>
.TP
.B *2ndGEN_read_file*<path
Cumulative commands that actually store the different read file commands described above, to be executed when an XGraph
dump of the current graph/data is read by (another) xgraph. Practical in combination with the \fBPrintOK[]\fP function
or \fB-printOK\fP commandline argument (dumping as XGraph, to "PS Preview", with \fB-DumpProcessed1\fP) to chain processing
command files on data. See \fB*2ndGEN_STARTUP_EXPR*\fP for the behaviour/inheritance.
.TP
.B *ADD_FILE*<path>
Similar to 
.B *READ_FILE*
but specifies a file/pipe to be read after reading (and closing) the current file. This way,
recursive inclusion can be simulated, independent of the limit on the maximal number of open files
(and neither by the maximal number of datasets, so care must be taken... unless you want to investigate
the maximum capacity of your machine!). This feature only works with files specified on the commandline!
.TP
.B *SCRIPT_FILE*<path>
Similar to 
.B *ADD_FILE*
but this command specifies a file/pipe that may contain scripting commands (described below) that necessitate
a window to be open. If issued in a file read on the commandline, it is included after opening the 1st window.
If issued in a file included at runtime, it is included after that file has been completely
included. Thus, one can not specify two files to be included in the same file.
This command is limited by the maximum number of open files (unlike \fB*ADD_FILE*\fP.. so each
of these commands has its applications and limitations ;-)).
Often, files contain sets of commands that are valid only when a window is opened (and active). When included from
the commandline (without the \fB-f\fP option), they are useless, and may even have undesirable side effects. To avoid
that, one can test for this situation, and if necessary require the current file to be read as a script file by including
the following lines at the head of the file:
.sp 1
.nf
*CONDITIONAL_EXTRATEXT* ActiveWin
\fB*SCRIPT_FILE* *This-File*\fP
*POPUP*
It only makes sense to include this file when a window is open and active!
It has been installed as a *SCRIPT_FILE* for you.

*CONDITIONAL_EXTRATEXT* ActiveWin
*EVAL* exit[1]

*IF* =[ActiveWin,-1]
*EVAL* ActiveWin[0] @
*ENDIF*
.fi
The first block installs the current file (\fB*This-File*\fP; only interpreted by \fB*SCRIPT_FILE*\fP) as a
scriptfile, and shows a popup dialog informing the user. The 2nd block (which must perform the same test...)
instructs XGraph to terminate parsing the file for the moment. The last block tests if some clever person set
the active window to the root (or calling terminal's) window. If so, it is set back to "no active window". This
is currently necessary for a reason I do not yet understand (aka a bug somewhere). The purpose of setting the
active window to the root window is of course that that makes it possible to forcedly parse a script file protected
like the above without opening any windows, e.g. to check syntax.

.TP
.B *ASK_READ_FILE* <message text>[::<default>]
Interactively query the user for a filename to be entered, to be included afterwards. The \fIREAD_FILE*\fP part (anything
after the \fI::\fP) can
be specified as described above under \fB*READ_FILE*\fP; the interactive behaviour is as described for
\fB*ASK_EVAL*\fP.
.TP
.B *DUMP_FILE*<path>
In a sense the reverse of \fB*READ_FILE*\fP. Dumps the current state into an XGraph dump. \fB<path>\fP follows the same
conventions as the filename specification in the hardcopy dialog: a leading '|' initiates an inter-process pipe, and
a ".bz2" or ".gz" extension generates a bzip2'ed or gzipped output file; ".rar" a RAR archive.
.TP
.B *STDOUT*[new::]<path>
.TP
.B *STDERR*[new::]<path>
Change the standard output (error) stream to the file specified by \fB<path>\fP. This file is opened in append
mode unless the \fInew::\fP flag is given.
Currently, pipes are not supported. When <path> is missing, XGraph tries to reconnect to the terminal
(/dev/tty).
.TP
.B *ULABEL* x1 y1 x2 y2 set=<set> transform?=<flag> draw?=<flag> lpoint=<flag> vertical?=<flag> nobox?=<flag> [lWidth=<w>] [type=<t>] [cname="colspec"]
.TP
.B *ULABEL* x1 y1 x2 y2 set transform? draw? pnr vertical? nobox? [cname="colspec"]

.B label-text
Defines a UserLabel.
.B (x1,y1)
define the arrow-side of the label (indicated
with a dot; the point of interest).
.B (x2,y2)
indicate the position of the
text-box (identical in appearance to the legend box; no box [frame] is drawn when <nobox> is True).
The two points are connected by a line drawn in the same style as the axes.
.B set
specifies the setnumber this label is linked to, or -1 for a general label. A value
of -2 indicates that the label is shown only when \fBall\fP \fImarked\fP sets are
being shown; similarly, a value of -3 for all highlighted sets. Values of -4 and -5
mean to display the label when none of the marked respectively highlighted sets are
being shown. This field is corrected for the set's actual serialnumber when data has been
read from the file, or when a \fB*Set*\fP statement has been encountered, and when there's a
match with the current or previous set's serialnumber (this does not work when files are concatenated
before being read!). \fBpnr\fP specifies the point in the set to which the label is linked. When
this value is >=0, the label acts as meter always showing the point's X, Y and error/orientation/intensity
(xcol, ycol, ecol) values, as long as the text contains the opcode \fB#n: \fP (a space behind the colon, and \fBn\fP
equal to \fBpnr\fP). This is the default behaviour when a label is linked to a specific point. Changing
the text through the Settings Dialog sets \fBpnr\fP to -1, causing the text to become static.
The opcodes described for the titleText can also be used in labels.
The optional \fBcname="colspec"\fP defines an X11-format colour for the current
label. Two special values exist: \fIdefault\fP gives the default appearance, \fIlinked\fP indicates
to dynamically use the colour of the set the label is linked to.
The text is read from the following lines, upto the first empty line. Special lines:
\fB*TITLE*\fP, \fB*FILE*\fP and \fB*LEGEND*\fP (on a line of their own) are replaced
by respectively the set's current title, file or legend --- if the label is linked
to a set, of course... This expansion currently only works while reading from file, but can
of course be done via a preview of an XGraph dump.. (i.e. enter a label "*TITLE*", preview
the XGraph dump, \fIet voila..\fP).
UserLabels can be edited in the Settings Dialog. They are listed
(in reverse order; i.e. the first entered label last) behind all sets. I.o.w, the
last defined UserLabel becomes item nr. 6 if there are 6 data sets. The co-ordinates and other parameters
can be edited (accept with TAB or cursor), as can the text. UserLabels can be removed
by deleting their text. Via the Settings Dialog, a UserLabel can be linked to
a set (number). This way, it is only shown when the set is selected. Linking can be done
also by keeping the \fBControl\fPkey depressed when entering a label with the mouse: it is
then linked to the nearest set.
The optional
.B transform?
argument (0 or 1) indicates whether or not the coordinates given can be subjected to
runtime specified transformations
.I (*TRANSFORM_[XY]*
or
.I *DATA_PROCESS*).
In an XGraph dump, labels linked to a set are dumped directly following the set; the remainder are
dumped at the end of the file.
The \fBlWidth\fP argument allows to specify a line width to be used for drawing the arrow and box lines; it defaults to the
current axis line width. The \fBtype\fP argument selects the label type: \fBRL\fP ("regular label") for a classical text label; \fBHL\fP for a simple horizontal line and \fBVL\fP for a simple vertical line.
User labels can be queried, modified and/or created through the \fBGetULabel\fP and \fBSetULabel\fP ascanf functions in
the \fIutils.so\fP dynamic module.
.TP
.B *VECTORLENGTH* <exp> (obsolete)
Specifies the length of the vectors for this and following sets, drawn when in vector mode. See under
\fB-vectors\fP.
.TP
.B *VECTORPARS* <type>,<exp>[,pars]
Specifies the length of the vectors for this and following sets, drawn when in vector mode. See under
\fB-vectorpars\fP.
.TP
.B *AVERAGE* [ScattEllipse|Y[-<option>] [I]] s1 s2 ... sn
This command causes an average over sets
.B s1, s2 ... sn
to be stored in the current set. When the \fBScattEllipse\fP flag is given, an "ellipse of scatter" is calculated "around"
the displayed points (see under key \fB<Mod1>-<Shift>-[O)]\fP).
When the \fBY\fP flag is not given, averages are calculated point-wise: for each point
.I i,
the X-coordinates of the sets "having" that point are averaged. The Y-coordinates are also averaged,
each with weight
.I num_obs_set / (1 + error[i])
(for
.I num_obs_set,
see the
.B *N*
description). The X-coordinates in point i of the "average set" thus reflect the average X[i], and the
Y-coordinate and error (st. deviation) the weighted-average Y[i] (with its standard deviation). The same
set of sets cannot be averaged twice.

When the \fBY\fP flag is given, behaviour is different. In this mode, only the Y coordinates are averaged (\fIY-average\fP),
yielding an average Y value for \fIall\fP X coordinates displayed (or the \fBoriginal\fP data for those points
that have a unique X coordinate); and the average set is sorted with respect
to increasing X. To this end, temporary space is allocated to hold \fI(N * P[n])\fP statistics bins (with \fIN\fP
the number of displayed sets, and \fIP[n]\fP the number of points in set \fIn\fP). Thus, this is a somewhat expensive
operation.

Behaviour with the \fBY-<option>\fP flag is similar, with exception to the sorting of the X coordinates, which depends on
\fB<option>\fP. When <option> is \fBXsrt\fP, behaviour is identical as when the \fBY\fP flag is given without; \fBNsrt\fP
specifies that no sorting of X coordinates is to be performed, and \fBXIsr\fP and \fBIXsr\fP specify sorting on X value
with the point number of the first occurrence of each X value as a secundary key, respectively sorting on point number, with
the X value as secundary key. Not all of these are expected to be of any use...

The additional \fBI\fP flag instructs xgraph to include interpolated values in an Y-average. To this end, it first collects
all X values, and the average Ys that go with them. Then all sets included in the average are scanned for the collected Xs:
if a set does not contain a certain X, but it does contain two Xs (with consecutive indices/point-numbers) that "surround"
the given X, a linearly interpolated Y and Error are calculated (where the error is calculated as
\fI(Ea * Na + Eb * Nb)/(Na + Nb)\fP, with \fIE\fP the error and \fIN\fP the number of observations in point \fIa\fP and \fIb\fP
respectively).

In an XGraph dump, "average sets" are either dumped as an \fB*AVERAGE*\fP
command, or as a regular set (depending on the flag /fBDumpAverage/fP).
The default setName of an average set is "XY-Average of sets ..." or "Y-Average.." (depending on the presence
of the \fBY\fP flag, which is also included in the setName); the fileName and Y-axis-label contain the
values of the included sets. The title of the new set is constructed as the per-character average of all
(different) titles of the included sets (concatenating them all would easily yield too long titles). These
default values are only assigned if no values were specified before. There is no support for the use of transformed
data in the file-based version (because this is implemented to make a snapshot of the data as currently shown - the
transformations are not evaluated while averaging).

\fINote\fP: X averaging and/or sorting is not very compatible
with use of a \fBlog_zero_x\fP value in logarithmic mode, as the sorting algorithm will use the real X (i.e. 0). As a workaround,
you can - in interactive mode, runtime that is - define a \fB*DATA_PROCESS*\fP \fIifelse[=[DATA[0],0],LZx,DATA[0]],DATA[1],DATA[2]\fP, and use one of the averaging varieties that use the transformed data.
.TP
.B *INTENSITY_COLOURS* use|<N>,red-expr,green-expr,blue-expr
This command calculates a colour table of \fBN\fP entries (where N can be an expression), or instructs to
\fBuse\fP (or recalculate) a previously specified one. The ascanf variable \fB$IntensityColours\fP will
export the effective number of colours allocated. The remaining three expressions
give values for the red, green and blue components, each of which should be between 0 and 1.
During evaluation of these expressions (after each invocation of
*INTENSITY_COLOURS*), the current index (between 0 and \fBN-1\fP) is contained in the variable \fB$DATA{0}\fP (or the
functioncall \fBDATA[0]\fP). These colours are used when a set is shown in "intensity" mode, that is, when the error-column
is interpreted as a "depth" or "intensity" value. The set should be drawn with markers of any sort, which will be drawn
in a colour taken from the intensity map, which is mapped onto the complete range of intensity (error..) values of all sets
(currently) drawn in intensity mode. As of this
writing, no index/legend is shown. When no map has yet been installed, a default, 64-entry grayscale map is made. On my
O2 with its default 8bit PseudoColor visual, I can get about 160 grayscale values, or 140 colour ("rainbow") values:
.sp 1
.nf
*EVAL* DEPROC[RainBow,progn[
 ifelse[=[$DATA{0},0],progn[DCL[red,0],DCL[green,0],DCL[blue,0]],
  ifelse[=[$DATA{0},sub[NN,1]],progn[red[1],green[1],blue[1]],
   progn[
    dum[div[mul[1,sub[$DATA{0},1]],sub[NN,2]]],
    red[sub[1,mul[dum,dum]]],
    green[mul[4,dum,sub[1,dum]]],
    blue[mul[dum,dum]],
   ],
  ],
 ],
 return[red],
]] @
.fi

# grayscale (160-level version of the default colourmap):

.sp 1
.nf
*INTENSITY_COLOURS* DCL[NN,160],
 div[$DATA{0},sub[NN,1]],div[$DATA{1},sub[NN,1]],div[$DATA{2},sub[NN,1]]
# rainbow:

*INTENSITY_COLOURS* DCL[NN,140],
 RainBow, green, blue
.fi

If more colours are required, give the \fB-MinBitsPPixel\fP argument when first invoking. But note
that the PostScript output not necessarily conveys that information to the printer or a follow-up
application!

This colour coding is shown in a legend. This intensity legend is drawn by default centered under
the X axis, and shows the colours in the map, and the current range of intensities, or the range
specified with *INTENSITY_RANGE*. Its width is maximally equal to the width of the plotting
region. The legend can be switched off and displaced like the "normal"
legend (when the Caps key is locked). Its position can also be entered directly like the legendbox's
position. The 2 corresponding input fields in the Settings Dialog show the intensity legend's
co-ordinates for sets that are not show in the legendbox (else, the fields show the legendbox's
co-ordinates), and that are in intensity mode. 
The commandline options pertaining to the intensity legend are similar to
the ones for the set legend, with "intensity_" prepended.

.TP
.B *INTENSITY_COLOUR_TABLE* [new]|[use]
Begins a list (table) of colourspecifications (names or RGB values), read until the first empty line. With the
optional \fBnew\fP, any existing list is deleted first, otherwise, new specifications are appended to the
existing list. The \fBuse\fP option instructs to (re)use a previously defined list.
.TP
.B *INTENSITY_RANGE* auto|<min>,<max>
Specify the range for the intensity colourmap set by \fB*INTENSITY_COLOURS*\fP. When the argument \fBauto\fP is given,
the complete current range of intensities in a window is mapped onto the complete colourmap. This is the default
behaviour. When \fBmin,max\fP are specified (these may be expressions), these are used instead - for all windows (as
the colourmap is also used for all windows).
.TP
.B *VAL_CAT_[XYI]* [new]   <val>,category
Define a \fIvalue to category\fP mapping for the X or Y axis, or for the \fBI\fPntensity legend.
The optional \fBnew\fP option first deletes
any existing mapping. The mapping is specified on the lines following the keyword, and terminated by an empty line. Each
line defines a single value to category, formatted as \fBval,category\fP. All text following the comma is
taken as the category (a string) associated with \fBval\fP, which may be an expression.
For the intensity legend, there is an option (\fB-all_ValCat_I\fP) which indicates that all categories should
be shown. In this case, the widths of the individual colour entries in the legend will depend on the category
name widths.
.TP
.B *VAL_CAT_[XYI]_FONT*
This command specifies a set of custom fonts for the corresponding category list. It must be followed on the lines below
the command by \fBX=\fP\fI<Xfontname>\fP, \fBPS=\fP\fI<PSfontname>\fP and \fBPSSize=\fP\fI<PSPointSize>\fP. 
If the (PostScript) font is a non-text font (e.g. Symbol), also include \fBPSReEncode=0\fP to prevent it from
being reencoded in the PostScript output.
The goal is to be able to use special (glyph) fonts to specifically "enumerate" one or both axes. Note: a non-standard
PostScript font can be included in a PS dump with the \fB-ps_s_inc\fP argument. Also note that an invalid X fontname
causes the whole fontspecification to be ignored (thus, a print will use the same fonts as the screen version).
To avoid this from happening, an alternate X font can be specified with the
opcode \fBX2=\fP\fI<alternate Xfont>\fP. This alternate font will be used in case the primary font is not available.
.TP

The next commands are available only when a window is active:!
.TP

.B *ACTIVATE* <winid>|<Window:Serial:Number>
Activates the window referenced by \fBwinid\fP, which has previously been returned by a call to \fBActiveWin[]\fP (ascanf function).
Alternatively, a reference triplet as shown in a graph window's title bar can be specified.
.TP
.B *CLONE*
Only available when a window is active. Clones the active window, equal to typing 'D' into that window.
.TP
.B *GEOM* <X geom expr>|<ascanf expr>
Only available when a window is active. Changes the X11 geometry of the active window. The \fB<X geom expr>\fP
is any expression that is acceptable for X's geometry parser (generally, WxH+X+Y). The second form,
\fB<ascanf expr>\fP is an expression that will yield either 2 or 4 numbers, from which an X geometry
string will be constructed (either WxH or WxH+X+Y). This second form allows e.g. to use the internal
variables \fI$CurrentScreenWidth, $CurrentScreenHeight\fP or functions \fIActiveWinWidth, ActiveWinHeight\fP
(not to confound with the variables $ActiveWinWidth and $ActiveWinHeight!) to adapt a window to (portions
of) the current screen. In this case, a position \fBat\fP the right/lower screen edge (that should be
indicated as -0) can be specified as \fB-0.1\fP, since all these numbers will have to be converted to
integers anyway...
.TP
.B *TILE* <down|up> [vertical]
Tiles the visible (= non-iconified) windows \fBup\fP or \fBdown\fP the stack, and optionally
in \fBvertical\fP direction only, like the tiling commands \fBt\fP, \fBT\fP, \fB^t\fP and \fB^T\fP.
.TP
.B *QUIET* [expr]
Quiets the handling of certain error conditions. By default, many errors during a redraw cause a modal dialog to popup, blocking
further progress. Often, however, such errors turn out to be transient conditions, e.g. when xgraph's idea of a
window's drawing area is not perfectly uptodate. The \fB*QUIET*\fP command causes the error messages concerned
to be displayed in the title bar, without blocking to wait for user intervention. Giving the command without the
optional expression turns on this option, and allows 100 consecutive errors to occur (in a given window) before
a modal dialog is popped up. When an expression is given, and it evaluates to a non-negative number, this
"flexibility" margin is set to the resulting value. When it evaluates to a number <= 0, the option is switched off.
The same switch will also reduce the number of warning popups that appear during the evaluation of \fB*EVAL*\fP
and related commands.
.TP
.B *SILENCE* <expr>
Only available when a window is active. Silences the current window, depending on the value of the expression.
Nothing is changed to the contents of the window, and (almost) no error messages are generated. 
.TP
.B *UPDATE_FLAGS*
Only available when a window is active. Copies the window's current window-specific setting into the set
of global variables controlled by command line options. Automatically performed before inclusion of a file
after startup.
.TP
.B *UPDATE_WIN*
Only available when a window is active. Copies the global settings (controlled by command line arguments) into the
active window's settings. Automatically executed after inclusion of a file (after startup).
.TP
.B *PROCESS_RESULTS_DRAWN*
Replace the raw data by the results of processing applied, including final and definitive elimination of discarded
points. This has approx. the same effect as passing the processed data to a new
xgraph process, except for the splitting of datasets. This command doesn't generate an immediate window-redraw to avoid
unnecessary processing. NB: for a reason as yet to be found, some form of window-redraw may be necessary to "confirm" (?!)
the results. This redraw can be issued after deleting all processing code (by including noprocs.xg, for example). The
fastest option is to issue a \fI*PROCESS_SET*\fP ALL command.
Note that in its initial version, this command would "touch" sets with the raw flag set. It no longer does.
.TP
.B *MARK_DRAWN*, *UNMARK_DRAWN*, *DRAW_MARKED*
Identical to typing the \fBm\fP, \fB<Mod1>-m\fP and \fBM\fP commands.
.TP
.B *SHIFT_DRAWN* START|LEFT|RIGHT|END
Reorders sets. The sets currently drawn in the active window are shifted respectively to the start; 1 position to the
left; to the right; and to the end. Shifting preserves the relative order within the sets being shifted, as long
as the outermost set in the direction of shifting (i.e. the first or last) can still shift. Shifting is performed
by (repeatedly) swapping sets and is thus relatively expensive. The diverse routines do, however, guarantee that
only one redraw (one for each window) is generated, after the final swap has been performed. A positive side-effect
of the use of swapping is that each window will continue to show the sets it displayed before the shift, even
though the numbers of these sets will have been changed.
.TP
.B *RAW_DISPLAY* [0|1]
Set or unset displaying of raw data.
.TP
.B *DRAW_SET* [TITLE|LEGEND|ALL|REVERSE|ASSOC|EVAL] <set_nr>|<pattern>|<exprn>
.TP
.B *MARK_SET* [TITLE|LEGEND|ALL|REVERSE|ASSOC|EVAL] <set_nr>|<pattern>|<exprn>
.TP
.B *PROCESS_SET* [RESTORE] [TITLE|LEGEND|ALL|REVERSE|ASSOC|EVAL] <set_nr>|<pattern>|<exprn>
Draw, mark or process the selected sets.
The \fBTITLE\fP and \fBLEGEND\fP flags take string patterns that are matched against the sets' titles
resp. legends. When the pattern starts with the token \fBRE^\fP, re_comp(3) patterns are matched against the complete title
resp. legend. Otherwise, the pattern may be a substring. \fBALL\fP selects all sets, \fBREVERSE\fP reverses the current
selection. \fBASSOC <exprn>\fP (where <exprn> evaluates to an array of \fBN\fP values) allows selection of sets which have the
the \fBN\fP (first) associated values equal to those given in the exprn array.
The \fBEVAL\fP flag allows the evaluation of a general 1-element ascanf expression the result of which is taken as a Boolean
(yes/no) value. For this expression, the \fI$CurrentSet\fP and \fI$numPoints\fP variables are set according to the
dataset under consideration.
In the absence of any specifiers, a set number is expected.
The \fB*PROCESS_SET*\fP takes an additional optional opcode that should be specified before the others; RESTORE. This
command in fact only applies whatever processing/transformation is defined on the requested sets, but is implemented
as a special case of the \fB*DRAW_SET*\fP command. By default, it will leave the draw_set information in the state\
it put it in. Thus, a \fB*PROCESS_SET*\fP command immediately followed by a redraw is identical to a \fB*DRAW_SET*\fP
command. With the RESTORE opcode, this sequence of commands will not alter which sets are displayed, and which are not -
only (possibly) how they are displayed. NB-1: the RESTORE opcode undoes any DrawSet[] commands that
your processing/transformation code might emit. NB-2: the PROCESS_SET command is conceived to speed up batch processing
that involve multiple transformations (e.g. a smoothing script followed by *PROCESS_RESULTS_DRAWN* followed by
a resample script). This is why it does not by default restore the draw_set information.
.TP
.B *WAIT_EVENT* [key]
Waits for an event to occur in the active window. Carefull with the space bar: this is the halt command that also
stops the reading of a file. And \fB*WAIT_EVENT*\fP does not discard the "unlocking" event....
During the waiting, the settings and/or hardcopy dialog can
be used without problems: even redraws (requested from those dialogs..) 
seem to be acceptible. When the additional flag \fBkey\fP is given, only keypress events are accepted.
.TP
.B *ICONIFY*, *DEICONIFY*
Apply to the active window.
.TP
.B *DRAWN_TITLES*, *DRAWN_LEGENDS*
Print the titles resp. legends of the drawn sets onto the standard error.
.PP
Unknown opcodes/commands are ignored with a warning message. An attempt is made to continue parsing at the
next following line that has good chances of not being part of the unknown opcode. During this attempt,
each line being rejected (and finally, accepted) is print out on the terminal, so that eventual action in
the file can be undertaken.
.PP

.SH PROCESSING & ARITHMETIC: functions and variables.

XGraph is capable of evaluating arithmetic expressions with a syntax that is a mix between Lisp, C and Mathematica.
These expressions,
can consist of functions (or routines), variables or procedures; they are parsed by the fascanf() family
of internal routines (also referred to as ascanf, which is also used as the language's name).
Historically, this functionality evolved from a fascanf() routine
that was intended to read arrays or one or more numbers. Quickly, I realised that this functionality could be
extended to include simple expressions, e.g. to calculate PI or some power of e, and that this would be quite
pratical indeed. It all started from there...
An fascanf() function has the form
.I [*][!][-]name[arg1,arg2,...,argN]
where
.I argN
is the number of arguments (settable with the \fBMaxArguments[]\fP function; default 256) for the function
.I name.
and \fI[-]\fP represents the optional sign. \fI[!]\fP is an optional negation sign, which works like C's '!'
operator (!0.1234 == 1). \fI[-]\fP and \fI[!]\fP are mutually exclusive. The \fI[*]\fP operator indicates that
the result of the operation should be stored in the first argument, which should be a variable.
A special case is the form \fI?name\fP; the \fI[?]\fP operator (prefix) requests the last value returned. When this
prefix is used, all arguments (and their potential side-effects!!) are ignored,
and the last calculated value (from an invocation without the prefix) is
returned.
Arguments can be numbers (doubles), other functions, or declared variables/labels/arrays or procedures. A variable/label
.I foo
is declared with the statement
.I Declare[foo,init[,"description"]]
or more compactly,
.I DCL[foo,init[,"description"]].
These statements in fact generate a new function with name
.I foo
and a value with either the result of the evaluation of the expression
.I init
or a unique, increasing counter value (i.e. a label).
Note that
.I foo
is all input up to the first comma, skipping over matched braces. A previously unknown name is entered
in the function table, while known function names are rejected. A '-' before \fIfoo\fP is interpreted as a sign on
the (new) value of \fIfoo\fP returned by \fIDCL[]\fP, and is thus not part of the new variable's name.
A variable's value can be changed using the statements
.I Declare[foo,newval]
or
.I foo[newval].
In both cases,
.I newval
is returned as the result of the expression (possibly with the sign specified before \fIfoo\fP).
The latter statement is slightly faster.
The expression
.I foo
is treated like any other number (i.e. no function is called).
Sometimes, it is interesting to be able to declare and initialise a variable but only when it does not exist yet (imagine re-
reading a script file after tweaking the variables declared in it). For this, use \fBDCL?[foo[,val]]\fP function. This function
does nothing when foo already exists, but otherwise declares it an optionally sets it to val.

The value of variables and arrays can be set with a shorthand notation, <var>[expr] (see also elsewhere). When such an
expression is being compiled, and <var> does not exist, XGraph will rewrite the expression to DCL[var,expr], and thus
declare the variable <var> (which can become an array when <expr> is a list). However, it will do this only when <var>
is not represented at all. This means that variable names that start with a number \fImay\fP be recognised as a number.
In that case, no automatic declaration takes place, and, worse, there is no warning that can be given. However, the lack
of a feedback message that a new variable \fIhas\fP been created may be taken as an indication that such a thing happened,
in case of (seemingly) missing variables.

Arrays are a little different. Originally, an array was declared (and initialised) with the syntax \fIDCL[foo,N,v1[,v2,..vn][,"description"]]\fP, where
\fIN\fP is the size of the array, \fIv1\fP is the value to be stored in the 1st element, and the optional \fIv2\fP to
\fIvn\fP are the values to be stored in elements 2 through \fIN-1\fP. \fIN\fP can be a value <0, in which case as many elements
as necessary to store \fIv1\fP...\fIvn\fP are allocated. (Declaring an array in a compiled expression currently
gives rise to an error-message that can be ignored.) An element \fIi\fP can be accessed with the syntax \fIfoo[i[,newvali[,..newvaln]]]\fP, where the optional \fInewvali\fP is a new value to be stored in element \fIi\fP, and \fI,..newvaln\fP the new values
to be stored in element \fIi+1\fP through \fIn-1\fP. This syntax always returns the latest value of the first element
(\fIi\fP) accessed. Referencing an array without indexing (as in \fIfoo\fP) returns the value of the latest element accessed
(default: element 0). Passing \fB-1\fP as index returns the number of elements \fBN\fP in the array; index -2 taken to be an alias
to the last accessed index (thus, \fIwhiledo[isNaN[foo[$loop]]], foo[-2,13]\fP sets the first non-NaN element in foo to 13).
The syntax \fBfoo[N,v]\fP has the effect of setting all foo's elements to \fBn\fP, unless \fB$AllowArrayExpansion\fP is True (in which case the array is expanded as required).
Arrays can be expanded by specifying a new, bigger \fIN\fP, but contraction must be handled by
calling \fISetArraySize[&foo]\fP...!
As of "version" 20040304, it is also possible to convert a scalar into an array, using the \fBSetArraySize\fP function. This makes
it possible to evaluate code that will unconditionally create an array if it doesn't exist, but not touch the contents of an
existing array with that name (a statement like \fIDCL[name,1,0]\fP always has the side-effect of setting the referenced
element to the specified value). Note that this can also be obtained by using the \fBDCL?\fP function. Also note that care has
to be taken currently that the conversion has taken place before compiling code using the converted array -- otherwise, the compiled
code will wrongly assume to be dealing with a scalar!
As of version 20080809, arrays can point directly to a dataset's column. All operations are supported on these arrays, except
resizing (do this by resizing the dataset pointed to...). In other words, these arrays make it possible to read and write directly
into dataset data, thus eliminating the need for copying values around via temporary arrays. To create these arrays,
first define an array variable, and then initialise it using \fBLinkArray2DataColumn\fP.

Currently, xgraph supports only 1 dimensional arrays; for 2D arrays, datasets have to be (and can be) used through
the routines \fBNewSet[[points[,columns]]]\fP (returns the new set's index), \fBAddDataPoints[setnr,val1,val2[,...]]\fP
and \fBDestroySet[setnr]\fP. Or the indexing routine \fB2Dindex[x,y,Nx,Ny]\fP can be used to index a 1D array.
There also exists an arbitrary-dimension indexing routine, \fBnDindex[x,y[,z,..],Nx,Ny[,Nz,..]]\fP (see below). However, for 2D
arrays, the specific form is somewhat faster (linux-PIII, twice, 20010215; a bit, 20020410:
loops[100000],elapsed,for-toMAX[0,loops,2Dindex[1,2,3,4]],verbose[elapsed], elapsed,for-toMAX[0,loops,nDindex[1,2,3,4]],verbose[elapsed] ).
Finally, there are also the MXY and MXYZ routines that give access to internal 2d and 3D arrays (see below).
It should be noted, however, that arrays are capable of storing both scalars and pointers; it is thus possible to construct
2 or more dimensional arrays (e.g. \fIDCL[foo,-1, {1,2,3}, {4,5,6}, `"abc"]\fP would give a 3x3 array, with the 3rd row a 3 element string... These are however not easy to access (\fI@[ foo[1], 1]\fP would give 5). And there is no allocator function (yet) that
will allocate a new variable (array...) when it is invocated (\fBDCL[]\fP does the allocation at compile time; already existing
variables are only updated/reinitialised).


Arrays and variables/labels are \fBdouble\fP (8bytes) by default. Prepending a \fB'%'\fP to the name of an array makes
it an \fBinteger\fP-array (4bytes on most modern 32bit machines).

For both variables and arrays, the value (of the last accessed element) can be set to the value computed by a function
if the variable/array is the 1st argument to that function, and a '*' is prepended to the function's \fIname\fP (i.e. \fI*name\fP).
This doesn't make sense with all functions, but can be useful to increment a variable's value without an extra
assignment, e.g. \fI*add[foo,1]\fP instead of \fIfoo[add[foo,1]]\fP. On a 200Mhz O2 (TM etc.), the former expression takes
about 3.25e-5 seconds to evaluate, against 4.1e-5 s for the latter.
This storage operator worked for arrays too, e.g. \fI*MAX[foo[i],x]\fP.
\fINB\fP: in versions before \fI20020617\fP, there was a bug in this feature when the same
array occurred in the argument list to the function that the storage operator was applied to! E.g.
\fI*MAX[foo[i],foo[j]]\fP would store the max of the 2 values not in \fIfoo[i]\fP, but in \fIfoo[j]\fP (in general, in the
last element that was referred too... thus \fB*MAX[foo[j],foo[i]]\fP \fBwould\fP have the desired effect....). As of v. 20020617,
this bug has been corrected.

A small number of variables are pre-defined. These are variables (also available as functions) which refer to e.g. the
current setnumber, pointnumber, etc. Using them in loops can significantly increase processing speed - but it is of
course not a good idea to try to change their value or even delete them.. (which isn't even allowed). There are also
some variables with control switches governing processing behaviour (somewhat easier than using CLI arguments). Obviously,
the value of these variables can be changed, but they can't be deleted. Since they can be changed, they show up
in the "show variables" dialogs. User-defined variables starting with a '$' have identical properties.

Variables, arrays and procedures can be deleted with the command \fBDelete[name]\fP. If \fBname\fP is \fB$AllDefined\fP,
all variables/../.. are deleted (or \fB$AllProcedures\fP to delete just all procedures);
if \fBname\fP is \fB$UnUsed\fP, only unused items (only variables and arrays when
\fB$UnUsedVars\fP) are deleted (with <=2 assignments and
<=2 reads and not linked in a compiled expression),
otherwise a variable, array or procedure with name \fBname\fP is deleted if found.

In addition to these variables, there is the fixed 
.I MEM
array, which has as many elements as the number of allowed function-arguments.
.I MEM[n,expr]
sets item
.I n
to the value of expression
.I expr;
.I MEM[n]
retrieves its value. Similarly, a 2D array
.I MXY
can be allocated with dimensions R,C with the statement
.I SETMXY[R,C]
which actually reallocates the array. Therefore (large) arrays can be de-allocated with
.I SETMXY[0,0]
. Items can be set with
.I MXY[i,j,expr]
and read using \fIMXY[i,j]\fP. Specifiying -1 for either \fIi\fP or \fIj\fP will set the
corresponding range (rows or columns) to the value specified. Finally, the form \fIMXY+[i,j,expr]\fP
will increment the value at i,j with <expr>; in this case, the result of the last evaluated increment
is returned.

An identical mechanism exists for a 3D array: \fISETMXYZ[R,C,S]\fP, \fIMXYZ[x,y,z[,val]]\fP and \fIMXYZ+[x,y,z[,val]]\fP.
This may one day evolve (transparently) into a SETMXYn / MXYn arbitrary dimension mechanism...

The possibility of specififying a sign by prepending a '-' before a name is new, and may not (yet) always act
as expected. It is (twice!) faster however than the expression \fImul[-1,name]\fP.

Xgraph also knows procedures. Procedures are defined with the syntax
\fIDEPROC[name,code[,"descr"]]\fP, where \fIname\fP is the procedure's name by which it can later be referenced, and \fIcode\fP is
the expression to be compiled and associated to \fIname\fP. An optional description can also be
specified: it has to be between \fI"s\fP. The invocation \fIDEPROC[name,code]\fP must precede
an invocation of \fIname\fP "solo", but both return the same value: the value of the expression \fIcode\fP, which
is evaluated instead of the "solo" invocation, or which is evaluated in addition to the compilation done by
a \fIDEPROC\fP invocation after the initial declaration. (Use \fBDEPROC*\fP to immediately evaluate the code; use \fBDEPROC-noEval\fP or \fB*EVAL*\fP
statements with DEPROC as the 1st function to prevent immediate evaluation!).
Evaluating \fIname\fP instead of \fIcode\fP is only slightly slower --- it requires some
additional internal processing. Procedure are dumped in order of definition, and as non-immediate evaluation (DEPROCs),
whereas variables are dumped in FILO fashion.
Procedures used not to take arguments, and this is still the case. That is, there are no local variables as in higher
(or lower, whatever.. :)) level programming languages. There is however support for a parameter-passing scheme as that
used in e.g. the Bourne or C shell. There exists an array, \fB$\fP that contains the values that were evaluated
in the (fake) argument list to the procedure. Thus for a procedure foo, calling foo[1,2] will provide the values 1 and 2
in the 1st 2 elements of that array, but calling foo without parameters will cause $[-1]==0 (the array length).

A special kind of procedure can be defined with the syntax \fIASKPROC[name,code[,"description"]]\fP (thus by using
ASKPROC instead of DEPROC). This is a bit like using \fB*ASK_EVAL*\fP vs. \fB*EVAL*\fP: the procedure
thus defined is not executed directly upon activation, but posts its code in a dialog instead. This allows for
modification of the code, e.g. making it possible to record specific features for each set. This can be done with 

.sp 1
.nf
*EVAL* ASKPROC[
     record-features,
     progn[return[1], has-featureA[$CurrentSet,1], has-featureB[$CurrentSet,1]],
     "Set the appropriate feature-values to 1 or 0 as required:"
] @

*DRAW_AFTER*
     ,,
     ifelse[ =[1,NDrawn],
          # only do this when a single set is drawn...
          set-accepted[
               # if we enter feature-values, accept the set, else,
               # (if we cancel the dialog!), reject it.
               ifelse[ record-features, 1, 0 ]
          ],
          0
     ],,
.fi

Currently, the modifications of the code are stored, thus always presenting the latest "version" upon the next
invocation. This code is compiled and stored, but there is currently no way of invoking the compiled code directly
(without posting a dialog), nor is there a possibility to conditionally post the dialog.

There is no generic mechanism to edit expressions within XGraph, using a (powerful) editor. There is some editing potential
in the input field of the Settings Dialog, but this only allows to directly access the various toplevel processing expression
hooks. There is also a way to edit an \fB*EVAL\fP expression using such an input field (\fIEN\fP function in the Settings Dialog,
\fI<Mod1>-f\fP key command in an XGraph window). Scalars and arrays can be edited quite easily with this functionality. Procedures
can be edited with the \fBEditPROC[name]\fP command. This command first dumps the procedure definition to a temp. file, then
opens this file in an editor (taken from the env.var \fB$XG_EDITOR\fP, or \fIxterm -e vi\fP otherwise), and re-reads the temp. file
when that editor quits. You can put other expressions (declarations, etc) before and/or after the procedure definition, in a single
list limited by the current MaxArguments value (see below). NB: the editor should not do a fork, but only return when the editing
is finished - otherwise, an unchanged file would be parsed... EditPROC[] can be called from a compiled expression (it does nothing
during the compile), but I do not really see the use of that... The return value is that set by \fBreturn[]\fP - note that that function
does not intterupt the execution of the remainder of the list expression (as in Lisp)!

It is possible to obtain the "address" of a variable, array or procedure.
As in C, an address is obtained by prepending
a \fI&\fP to a name. As all ascanf() data, that address is "packed" in a double (=8 bytes..) floating point value, and
consists of 2 4-byte words: the variable's type+ 0x12345600 and the actual (4 byte) address to the internal structure describing
the variable. Hopefully, the first word is valid only for 2nd words that are valid addresses (i.e. that don't
cause a crash when they're being accessed for reading..). \fBNB-1\fP: be careful in the use of these variables. I can't
think of a way this mechanism would allow accidental overwriting of internal data that is not a result of a
badly programmed (internal) ascanf routine. But don't use them for operations other than assignment or parameter-passing:
any rounding off will probably render them useless. \fBNB-2\fP: don't count on storing pointer values between xgraph
invocations. XGraph promises not to change the address of a variable runtime (unless it is Deleted by the user.. which
is not my responsability), but it can't promise that a variable will occupy exactly the same memory locations as
in a previous invocation (they're stored in linked lists..). Therefore, it is possible to declare a \fIpointer variable\fP:
\fBDCL[&ptr,&target]\fP creates a variable tagged as containing the address of another one. When containing a
valid pointer, such a variable will be printed as \fIptr== &target\fP, or saved as \fBDCL[&ptr,&target]\fP (and
that's the whole interest to it.. but at least this allows pointer variables to be restored across invocations). Support
for \fIpointer arrays\fP may follow in a later release. The validity of pointers can be checked by the function
\fBCheckPointers[p1[,p2,..]]\fP which checks the validity of its arguments, which should all be
pointers (it will return the number of valid pointers). Note (also) that prefixing an '&' to an expression takes
the address of that expression, without evaluating it any further. Thus, whether \fIfoo\fP is an array or a function,
the expression \fI&foo[a,b]\fP yields the address of the object \fIfoo\fP, and does not evaluate \fIfoo[a,b]\fP, avoiding
any side-effects (setting element a to value b, or any kind when foo is a function) that this evaluation might
cause (notably syntax errors!). The implication of this is that it is not possible to take the address of an
element of an array - only the array's base-address can be taken! On the other hand, one can store pointer variables in array
elements. To get to the \fIn\fPth element of the array pointed to by \fIfoo[m]\fP, you will need the \fBDCL\fP function:
\fIDCL[ foo[m], n[,newval]]\fP. If \fIfoo[m]\fP points to the scalar variable \fIbar\fP, that
same statement would be equivalent to \fIbar[n]\fP - i.e. set \fIbar\fP to \fIn\fP (\fInewval\fP is ignored in this case).
To read a scalar indirectly: \fIDCL[ foo[m] ]\fP.
This mechanism is not for implementing multidimensional arrays, but to allow the passing of pointers to procedures. Note however
that when saving the variables in an XGraph dump, such an array will not necessarily be saved after all the variables/procedures
it depends on are dumped!
See also the \fBAscanf_Lazy_Address_Protection\fP in the \fIRESOURCE\fP section.

The prefix \fB`\fP (backquote) has a meaning similar to '&'. The address is taken, and, if the target is a variable, a flag
is set to indicate that the variable's usage/description should be used by those functions that support this (the various
printing functions only, for the moment). Thus: \fIDCL[foo,10,"Foo equals"], Dprint[`foo,foo]\fP prints \fIFoo equals 10\fP
(with a tab separating 'equals' and '10').

If a string or array is needed for one occasion only, there is no need to declare a global variable to contain that string of
array. There is support for automatic strings and arrays, i.e. variables that can be "declared" implicitly in an expression.
This is not to be confused with the automatic declaration of non-existing variables! To pass a string(pointer) to a function,
simply put a string in place of a stringpointer. That is, one can do \fISetColour[set_nr,`cname,"purple"]\fP instead of
\fIDCL[newcolour,0,"purple"], SetColour[set_nr,`cname,`newcolour]\fP. Similarly, one can
\fISetColour[set_nr,`cname,{exprR,exprG,exprB}]\fP instead of \fIDCL[newcolour,-1,exprR,exprG,exprB], SetColour[set_nr,`cname,&newcolour]\fP. Notice that the array is delimited by curly braces, and the string by double quotes. Also note that the 2nd argument
to the example function, \fIcname\fP, is an existing variable, and not an automatic variable. It would be possible to pass
an automatic one, but this is not a clever idea. Automatic variables like the ones shown are in fact stored in an internal
table (independent of the table containing the global functions and (user-defined) variables), with a name that is the string "value" or the array expression-list. Thus, the internal variables name and its value(list) are supposed to be identical; if they
are no longer, unexpected results are bound to occur. This is because internal variables are not declared each time they are
referenced. They are of course created when first referenced (either while compiling or evaluating an expression). Then they
persist until the last compiled expression that references them is destroyed. Meaning that if they are not referenced in a
compiled expression, they will persist until the programme quits, or until you \fIDelete[$InternalUnUsed]\fP (note that
this command deletes \fBall\fP unused internal variables, both automatic and user-defined!).
Automatic strings never change their "value". Arrays may. Imagine \fISetColour[set_nr,`cname,{ran,ran,ran}]\fP. Each time
you evaluate such an expression, you'd expect a completely random colour to be assigned to the specified set - and a different
colour at each evaluation. Thus, the array's expression list (\fIran,ran,ran\fP in the example) is compiled, and stored within
the automatic array variable. When it is not a list of constants (like {1,1,1}), or when optimisation for constants-lists is not
allowed, this compiled "automatic expression" is evaluated each time the automatic array is referenced.

XGraph has the same notion about boolean values as the C language has: any value that is not 0 is synonym for 'True', whereas
0 is 'False'. There is one difference however: a boolean is still a value (or number), so the IEEE value \fINaN\fP (not a number)
is considered 'False' (although it actually ought to be NaB, "not-a-boolean"...). As a result, \fI!NaN\fP (NOT not a number) gives...
1. However, \fIInf\fP is a number, infinitely huge, but still a number, and thus, for Boole's purposes, no different from 1 or -64.

XGraph has an option to maintain a registry of ascanf objects (variables, functions, procedures, etc).
This has no external application and may have a cost, but some plugins (dynamic modules, notably importing modules used with the
\fB*DM_IO_IMPORT*\fP command) depend on it to check for pre-existing definitions of the variables they export. If for example you
intent to set parameters controlling importing behaviour, make sure to activate the registry first, either through 
the ascanf call \fBregister-Variable-Names[1]\fP, or with the \fB-registry\fP commandline argument.
(As of 20100610, there should be no more need to manipulate this setting at runtime.)

A short description of some of the functions and variables follows. This list is maintained in a rather sloppy way: many
functions and variables are only described in the programme itself. New entries are mostly added in chronological order,
as I add them to the programme (and after satisfactory debugging).
.TP
.B =[x,y]
.TP
.B =[&array1,&array2]
Compare 2 scalars, or 2 arrays on an element-per-element base (over the smallest of the 2).
.TP
.B add[x,y[,z,..]] (sub,mul,div)
.TP
.B add[&dest_array,&array1,&array2]
Add (subtract, multiply or divide) the arguments passed. When the 2nd form is used (all 3 arguments are pointers
to arrays), the operation takes place element-wise on the arrays, with the result being stored in the destination
pointer (dest_array) which is resized to the size of smallest of the 2 operands. Otherwise, the sum (subtraction,
multiplication, division) of the arguments passed is calculated. In the case of division, +-x/0 yields +-Inf,
0/0 yields the value set by \fBzero_div_zero\fP.
.TP
.B DCL[name[,val][,"description"]]
.TP
.B DCL[arrayname,N,val1[,val2,...valN][,"description"]]
.TP
.B DCL[%integer_arrayname,N,val1[,val2,...valN][,"description"]]
.TP
.B DEPROC[name,code[,"description"]]
.TP
.B DEPROC-noEval[name,code[,"description"]]
.TP
.B DEPROC*[name,code[,"description"]]
See the introduction above.
.TP
.B IDict[<expressionlist>]
Xgraph has an "external" dictionary on which all functions are stored, and all "normal" variables, arrays, etc. There is
also an internal dictionary. This one is used for storing automatically created variables. The main difference between
the 2 dictionaries is that the internal one is not saved in XGraph dumps. All entities defined within the scope of the
\fIIDict\fP function are also stored on that internal dictionary. Within its scope, the other functions
acting on variables (Delete, EditPROC,...) will also
apply to the internal dictionary. Note that entries on the internal dict are masked (shadowed) by homonyms on the
external dictionary!
.TP
.B AccessHandler[&watch_object,&target_object[,val1[,val2[use,ref-value[,dump[,change]]]]]]
A rudimentary "callback" mechanism, also useful for debugging. Whenever a value (new or old) is stored in the value register of
\fIwatch_object\fP, this event is registered through <target_object>. The action taken depends on the type
of \fItarget_object\fP. When a variable, it is set to \fBval1\fP, or 1 if no parameters are specified. When
an array, \fBval1\fP references an element in that array (-1 for "last_index", which is also the default), and
\fBval2\fP the value to be stored. When a procedure, it is called.
And when a function, the 2 optional parameters are passed as the 2 arguments to the function, defaulting to
[1,0]. It is rudimentary because of this relatively restricted parametrising scheme, relying on a global variable (array)
to pass on (additional) information to the callback handler. This array, \fB$HandlerPars\fP (the name allows potential
use for future additional handlers), contains in its first 2 elements val1 and val2 as given (or NaN if not given),
the 3rd element contains a pointer to the touched variable (&watch_object), the 4th and 5th the current and previous
values, and when watch_object is an array, the 6th element is >=0 and contains the index of the accessed
element. The 7th element contains a pointer to the access handler itself, while the 8th contains the level - the sub-expression
number that caused the handler to be invoked.
The optional <use,ref-value> argument pair can be used to have the handler invoked only when the watched object's value
is equal to the <ref-value> (<use> must be 1 for this). Other options: <use>==2: handler called when <ref-value> is larger than <watch_object>'s value;
<use>==-2: handler called when <ref-value> is smaller than <watch_object>'s value.
The optional <dump> argument (a boolean) can be used to request a sort of stack trace dump: when known, the invoking sub-expression,
the toplevel expression (with intermediate values) it is part of, and the context in which this expression was evaluated are dumped to the standard error.
The optional <change> argument (a boolean) can be used to have the handler invoked only when the watched object's value
has changed. To this end, the internal "old value" is update by AccessHandler[]. The <change> flag can be combined with the
<use,ref-value> settings!
Note that <target_object> can have an access handler associated with it, too. If this is the case, it will naturally be
invoked. I have the feeling that this can come in handy - it should be possible to gain some processing speed by doing
specific tests internally/implicitly instead of via (nested) ifelse statements. However, there is *no* check against
recursive invocation!!
Despite this relative clumsiness, this mechanism can be directly useful to
e.g. trigger a redraw when a certain variable's value is updated: \fBAccessHandler[&foo,&redraw,1]\fP, or
to ensure (re)initialisation of certain otherwise non-changing variables,arrays, etc: \fBAccessHandler[&foo,&ReInitialise,1]\fP ...
\fBifelse[ReInitialise,progn[\fP\fI# Initialise whatever can be done once only\\n\fP\fB ....,ReInitialise[0]],0]\fP.
NB: there is currently not
a single update routine for the value register (let us say to save on some functioncalls). This implies that
there may be update events that don't trigger the callback, notably of many of the internal '$' variables
($CurrentSet, etc.). On the other hand, setting a callback on a variable that changes at most indirectly as
a result of user's actions seems questionable to me. As for now, "static", unchangeable $ variables don't
allow access handlers. Unfortunately, it is not (yet) possible neither to set a watch on an array element.
Note also that setting an access handler to an output-redirecting function (like \fBcomment[]\fP and \fBpopup[]\fP)
will also redirect the access handler related output (at least for the examples mentioned).
.TP
.B compile[expr]
Compile and evaluate \fBexpr\fP. When \fBexpr\fP is evaluated through a \fB*EVAL*\fP, compilation is automatic
in case a loop-construct is involved, and no Delete command occurs in the same expression (this might delete
variables needed in the compiled expression before it is evaluated!).
.TP
.B compile-noEval[expr]
Compile, and don't evaluate \fBexpr\fP. A somewhat mysterious name for a construct that allows syntax-checking of
\fBexpr\fP. Routines with effects that should occur only in the right scope/evaluation (and not when initially
compiling a transformation, or defining a procedure) (should) have been written to only check the syntax of their
call during compilation. Thus, this routine can e.g. be used to define a procedure without afterwards immediately
evaluation it.
.TP
.B Defined?[name]
Checks whether or not \fBname\fP is defined. This works for user-defined objects and for internal functions.
.TP
.B ifelse[test,true_expr,false_expr]
A conditional statement that returns the evaluating-result of either {true_expr} or {false_expr} depending
on the evaluated value of {test} (non-zero or zero respectively). Only the test and "returned" expressions
are evaluated (lazy evaluation)!
.TP
.B switch0[ref,case1_expr,expr1[,case2_expr,expr2,..,..,caseN_expr,exprN[,default_expr]]]
.TP
.B switch[ref,case1_expr,expr1[,case2_expr,expr2,..,..,caseN_expr,exprN[,default_expr]]]
An implementation of C's switch(){ case... } construct that permits to avoid nested ifelse statements. For starters,
{ref} and {case1_expr} are evaluated, and a match is searched between {ref} and the subsequent {case?_expr}s. When
a match is found (say, {caseI_expr}), the corresponding {exprI} is evaluated, and its result returned. When no match
is found, and there is a "trailing" expression {default_expr}, this one is evaluated and its result returned. Again,
only the necessary expressions are evaluated, although one can argue that too much work is done in the case that all
case_expr are "static" (i.e. numbers or determined function-calls). The number of the selected/requested case is
accessible via the \fB$case\fP variable (the first one being number 0). This makes it possible to return the number of
valid cases (excluding the default!) by including a last switch that would \fBreturn[$case]\fP.
NB: as of 20050111, the \fBswitch\fP routine attaches a special meaning to case expressions which are array pointers.
In that case, and if the reference (test) value (the 1st argument) is not also an array pointer, a hit occurs when the
ref. value occurs in one of the case arrays. This makes it possible to make several cases share identical code without
having to duplicate it, as in C.
.TP
.B CheckNow[[interval]]
While doing processing, the \fIX11\fP event queue is checked/processed once every \fBinterval\fP (default: 1000)
evaluated expressions. This function forces a check, an optionally changes the interval. The usual "STOP" commands
(the space bar, ^X) also interrupt any (looped) processing.
.TP
.B MaxArguments[[N]]
Query or set to \fBN\fP the maximal number of arguments an fascanf() function can handle. This also defines (and resets if N is
larger than the current maximum!) the
number of slots of the \fBMEM\fP function, and the number of (angular) statistics bins. Default is 256. This call should always
be executed at toplevel scope, to prevent re-allocating data used by higher-level scopes!
.TP
.B curve_len[set[,index]]
Xgraph calculates for each curve and at each point (X,Y) the length of the segment (X_1,Y_1) - (X,Y) : thus, at
every point the discrete integral upto that point over the curve is known. The total length of the curve
is thus accessible as \fBcurve_len[$CurrentSet,sub[numPoints[$CurrentSet],1]]\fP, which is identical to
\fBcurve_len[$CurrentSet]\fP (with \fB$CurrentSet\fP the number of the current set). NB: all points are taken into
consideration. Therefore, a single NaN will cause a NaN result... I might someday decide to take only non-NaN points
into consideration, but this does not have high priority. NB2: XGraph stores the transformed result - the to-be-plotted
(X,Y,Error) - in a separate buffer; this allows the possibility of a QuickMode in which the results from a previous
transformation are plotted. However, discarded points are stored as NaNs in this buffer, to prevent them from being
plotted. Therefore, \fIcurve_len\fP is not available in QuickMode when points have been discarded. To use this routine
in that particular situation, switch on the "discarded point shadows" (\fB-DPShadow\fP option, function \fIDPShadow\fP).
.TP
.B error_len[set[,index]]
A similar calculation is performed on the errors (E co-ordinates, or orientation in vector mode). This is useful
mostly in vector mode, when the 3rd column (\fB$DATA{2}\fP) is interpreted as an orientation (see under \fB-vectorpars\fP).
In this mode, the discrete integral is performed over the absolute difference between the orientation ("error") between
2 points. A difference larger than half the current radix (e.g. 180 for radix 360) is an effect of the jump occuring
from, say, 359 to 1 degrees (an actual difference of 2deg!) -- it is thus corrected to the real difference. The resulting
value represents the total change of orientation.
In non-vector mode, the total change of error is calculated, which is probably much less useful!
.TP
.B QuickMode[[val]]
Query or alter QuickMode.
.TP
.B DPShadow[[val]]
Query or alter the "discarded point shadows" mode. In this mode, discarded points are rendered as low-contrast pixels. 
This mode must be set to be able to use \fIcurve_len\fP in QuickMode when points have been discarded. Set to a negative
value to avoid saving the option in XGraph dumps.
.TP
.B Print[[ret val]] , PrintOK[[ret val]]
Identical to the \fB-print\fP respectively \fB-printOK\fP commandline options. The 1st only has an effect when the printing
dialog is not already posted, the 2nd only has an effect the 1st time it is invoked. This is because they both generate
an immediate redraw of the active window, potentially causing to reinvoke themselves recursively. Some care should probably
be taken using these functions for any other output than dumping XGraph data to a new xgraph process ("XGraph preview"), with
the \fB-DumpProcessed1\fP option specified.
NB: because the immediate
redraw, invoking them within a verbose frame (as in \fBverbose[PrintOK[1]]\fP) causes any subsequent evaluations to be
verbose. This also applies to the \fBRedrawNow[]\fP function. All functions mentioned in this paragraph have an optional
argument specifying their return value; otherwise, they return the last returnvalue set with the \fBreturn[]\fP function.
.TP
.B RecurseLevel?
Level of recurse at which drawing is currently taking place. Always >=1 (unless executed in a *EVAL* statement [0], or
when no window is active [-1]). When auto-fitting is activated, the values are respectively \fB2\fP for \fB*DRAW_BEFORE*\fP
and \fB*DRAW_AFTER*\fP statements, and \fB3\fP for the \fB*DATA_PROCESS*\fP and \fB*TRANSFORM_[XY]*\fP families. When auto-scaling
is not active, the values are \fB1\fP and \fB2\fP respectively.
.TP
.B Silenced?
Determine whether the window is silenced (see \fB*SILENCE*\fP; almost always true..). With an optional argument, set
silenced mode. This can be very practical to prevent X-generated events from generating unwanted redraws during the
evaluation of precarious code (such as containing a MaxArguments statement).
.TP
.B SplineInit[<set_nr>,<indep_col_nr>[,<dups>=0[,<all>=1[,[interval,]`return_msg]]]]
.TP
.B SplineX[<indep>], SplineY[<indep>], SplineE[<indep>], Spline[<col>,<indep>]
.TP
.B SplineFinished
\fBSplineInit\fP calculates spline-coefficients and the \fBSpline?\fP routines return a "splined"
value based on these coefficients. When \fB<all>==1\fP (default), all the set's columns are splined; otherwise (when \fB<all>==0\fP),
 only the current X, Y and Error/orientation columns are splined. The independent variable of the coefficients is determined by the \fBindep_col\fP
argument; either a data column index (i.e. when >= 0), or internal data: -1 for using the point number, -2 for using the
cumulative curve length (the \fBcurve_len[]\fP routine), -3 for the "error length" and -4 for the sum of the latter 2. The SplineInit
routine needs ordened independent data, increasing without duplicates. Sorting is handled internally, and the \fBdup_handling\fP
argument specifies what to do with multiple independent values: 0 (default) averages the dependent values per duplicate independent
value, 1 takes the 1st dependent value, and 2 takes the last.
The <interval> argument specifies at what interval the original data is to be sampled;
    0 or 1 means that every sample is to be used. The 1st and last point are always included;
a negative value means that an attempt will be made to distribute any error in the last segment evenly over all segments
(if that error [numPoints % interval] >= interval/2).
The optional `return_msg contains the message(s) generated\n"
NB: the 'discard' state of any discarded points is ignored!
\fBNaN\fP values: NaNs are handled in 2 ways. NaN values in the middle of the original Y values are replaced with a ramp (linear
gradient) between the surrounding samples. This is the most parsimonious solution: "splining" means we'll be doing intrapolation,
and there where samples are missing, the best assumption we can make is that whatever was measured changed smoothly (and linearly)
between the surrounding available measures. The internal copy of the original data will receive a linear gradient, which will ensure
that the splined values will exhibit a smooth transition across the 'corners' of the gap. One can restore the NaNs (the gap)
afterwards if so desired. NaNs at the beginning or end of a series are more annoying: no assumptions can be made here. Therefore,
the current implementation excludes leading and trailing NaNs from the spline coefficient calculations: the corresponding 
coefficients will be NaNs themselves. Thus, values "splined" where the original data had leading or trailing NaNs will be NaNs.
This is different from values splined where there were "internal NaNs". This approach also means that it is not possible to
extrapolate beyond the range of original X values -- which is usually not a good idea anyway.
Restoring NaNs could be done by something like:
.sp 1
.nf
	SplinedX[i, SplineX[x]], SplinedY[i, SplineY[x]], ...
Apply2Array[ &SplinedX, 0, 1, lambda[progn[
	 # find the original X values closest to a splined X value
	ArrayFind[&OriginalX, $[0], &lidx, &hidx],
	 # if either of the corresponding original Y values is a NaN, make the splined value a NaN too.
	ifelse[ OR[ isNaN[OriginalY[lidx]], isNaN[OriginalY[hidx]] ],
		SplinedY[$loop, NaN],
	],
]] ]
.fi
.TP
.B rfftw[<input_p>,<output_p>[,<power_p>[,nan_handling]]]
Do an FFT (using rfftw from the FFTW library) of the array pointed to by \fB<input_p>\fP
storing the transform in \fB<output_p>\fP and optionally the power spectrum in \fB<power_p>\fP
All must be double arrays; if necessary, <output_p> and <power_p> are resized to the size of the input array (input_p->N),
even though <power_p> will have only input_p->N/2+1 relevant elements. NB: xgraph uses rfftwnd_one..(), a multidimensional
transform with Nx=1 to do the real 1D DFTs. Thus, <output_p> will contain 2*(input_p->N/2+1) elements, arranged as
an array of complex numbers: output_p[0] has the real part of the DC component, output_p[1] the imaginary part 
(which should be 0), etc.
For the meaning of the \fBnan_handling\fP argument (\fIfourconv3\fP only!), please see the inline help.
.TP
.B inv_rfftw[<input_p>,<output_p>[,<normalise>]]
Do an inverse FFT (using rfftw of the FFTW library) of the array pointed to by \fB<input_p>\fP
storing the transform in \fB<output_p>\fP, optionally normalising <input_p> first (division by input_p->N).
All must be double arrays; <output_p> is resized to input_p->N if necessary.
.TP
.B convolve_fft[<data_p>,<mask_p>,<output_p>,direction[,<data_spectrum_p>[,<mask_spectrum_p>]]]
Do an FFT based (cyclic) convolution or deconvolution (direction==0) of the array pointed to by <data_p> with
mask <mask_p>, storing the output in <output_p> (will be resized). If specified, the data's FFT spectr.
will be stored in data_spectrum, and the mask's spectrum (for a mask with the same widh as the data is
long) will be stored in <mask_spectrum>. When <mask_spectrum> is initialised, <mask_p> may be 0 in
subsequent invocations (as long as neither mask, nor the length of <data_p> changes): this saves
1 FFT transformation.

These routines need the FFTW library, which must be installed and linked in. They use the FFTW_ESTIMATE and
FFTW_USE_WISDOM features to obtain optimal/optimised performance (but the first transform may be slow). The
gathered "wisdom" is stored in \fB$HOME/.Preferences/.xgraph/fft_wisdom\fP or in the file specified by the env.variable
\fBXG_WISDOM\fP. NB: that file contains platform specific data!
.TP
.B InitFFTW
Initialise the FFTW library. This consists of reading wisdom (gathered platform-specific information about fast
ways to do FFTs) from either the file specified by \fB$XG_WISDOM\fP or \fB~/.Preferences/.xgraph/fft_wisdom\fP. When this
routine has been called, FFTW routines used will use the flags FFTW_MEASURE|FFTW_USE_WISDOM to assure the fastest
execution times (except for maybe the first call). Without a call to this routine, the flags used will be
FFTW_ESTIMATE|FFTW_USE_WISDOM (estimate a fast algorithm; see the FFTW documentation for the meaning of these flags).
In addition, when XGraph has been compiled with the \fBFFTW_DYNAMIC\fP option, a call to InitFFTW is obligatory to
load the fftw shared libraries - without such a call, the functionality is not available!
.TP
.B CloseFFTW[complete]
This routine saves gathered new wisdom to file. When the optional argument \fBComplete\fP is true, FFTW internal
ressources are de-allocated, and a new call to \fBInitFFTW\fP will be necessary to again benefit from the
use of wisdom.
.TP
.B $fftw-planner-level
A variable that specifies the level of 'thoroughness' in finding a (sub)optimal execution scheme.

These routines are all contained in an auto-loading library, fourconv.so . That library is written for FFTW 2.x (2.1.5 at
this writing). There is a newer FFTW version, 3.0.5 currently, that is significantly faster (after a significantly slower
FFTW_MEASURE planning stage). A compatible library version lives in fourconv3.so, that should not be loaded simultaneously 
with fourconv.so (name clashing will result). \fB$fftw-planner-level\fP is heeded only in fourconv3.so .
If you want to use FFTW 3.x, preload fourconv3.so instead of letting xgraph auto-load fourconv.so when needed.
In a near future, fourconv3.so will very probably replace fourconv.so as the default auto-loading library.

.TP
.B convolve[<data_p>,<mask_p>,<output_p>,direction[,nan_handling]]
Does a direct convolution, as described under \fBconvolve_fft\fP. Currently, the ends are automatically padded with to the first
and last value, respectively.
For the \fBnan_handling\fP argument, please see the inline documentation.
Note that for deconvolution, the FFT based version is used! The direct version is not slower in many cases!
.TP
.B SavGolayInit[<set_nr>,<filter-halfwidth>[,<order>=4[,<deriv_order>=0[,pad=0[,padlow[,padhigh[,&coeffs]]]]]]]
.TP
.B SavGolayX[<counter>],
.TP
.B SavGolayY[<counter>],
.TP
.B SavGolayE[<counter>],
.TP
.B SavGolay[<col>,<counter>],
.TP
.B SavGolay2Array[<dest_p>,col[,start[,end_incl[,offset]]]]
.TP
.B SavGolayFinished
An implementation of a Savitzky-Golay smoothing filter, taken from the Numerical Recipes. This filter does the
smoothing by a pointswise fit to a polynomial of order \fB<order>\fP in a window of \fB<filter-halfwidth>\fP
to both sides. The order gives the highest conserved moment of the inputdata. The fit is
calculated as a convolution with the data (hence, this is a "smart" form of moving-window averaging).
The \fB<filter-halfwidth>\fP should be positive, and the \fBorder\fP may maximally be twice the halfwidth. Both
conditions are imposed. \fB<deriv_order>\fP specifies the order of the derivative desired: (default) 0 for a
smoothed function, \fB1\fP generates the 1st derivative, \fB2\fP the second, etc, of the inputdata. \fBderiv_order\fP
is bounded by \fBorder\fP. To obtain the correct value of the derivative, the results should be scaled (multiplied) by
a factor \fBderiv_order * dX ^ -deriv_order\fP (where \fBdX\fP is the timestep).
Smoothed values are calculated for all \fB<set>\fP's columns, which can be retrieved through
\fBSavGolayX\fP, \fBSavGolayY\fP, etc, which take a point-index (\fBcounter\fP in [0,\fBnumPoints[<setnr>]\fP]) as
an argument. \fBSavGolay\fP allows explicit column specification, and \fBSavGolay2Array\fP copies a
filtered column \fB<col>\fP into the array specified by the pointer \fB<dest_p>\fP (see \fBDataColumn2Array\fP).
After use, internally allocated storage (a lot, esp. for large sets since FFTs are involved) can
be released with \fBSavGolayFinished\fP.
To diminish convolution edge-effects around the initial and terminal datapoints, the first and last values can be spread
leftward and rightward respectively over \fB<pad>\fP if positive, or over \fBfilter-halfwidth\fP if negative. If
\fB<padhigh>\fP and/or \fB<padlow>\fP is/are given, these are used instead of the last resp. first values. By
default, no spreading/padding is done. Still, it is probably better to discard
the first and last \fBfilter-halfwidth\fP filtered datapoints. Furthermore, as a rough guideline, one can say that
for a \fBorder=4\fP filter, features (peaks) preserved have a full width at half of maximum (FWHM) of approx. 
\fBfilter-halfwidth\fP and higher. Hence, set the halfwidth to the smallest FWHM that is to be preserved to be
on the safe side.. For convenience, a null-filter mode can be selected by setting \fBfilter-halfwidth\fP, \fBorder\fP and
\fBderiv_order\fP all to 0: thus, the filter passes the input data without alteration.
The filter in fact convolves the data with a mask determined by the derivative, order and half-width. This mask can be
retrieved as an array in the optional \fBcoeffs\fP argument to SavGolayInit (must be an array).
.TP
.B $SS_Ignore_NaN
A flag that (currently) affects only ascanf's use of statistics bins - all of them. When set, NaN values are ignored, whether
the data added is NaN, or whether data * weight is NaN. This may become a general switch, and a bin-specific version may
appear in the future.
.TP
.B $SS_StatsBin[&variable,exact[,exprs...]]
Convert a pointer to an existing scalar or array variable to a scalar or array statistics bin (statsbin). The \fIexact\fP argument
determines whether or not "exact" statistics (see \fBSAS_exact\fP) are performed.
Additional values given with the
<exprs> (one or more expressions!) are stored in the newly created statsbin (see also \fBSS_Add\fP).
Additional calls will only set the \fBexact\fP flag on the already existing statsbin, and add the expressions.
The routine returns the number of items
stored, or -1 upon failure.
A pointer to the resulting $SS statsbin can be given as the 1st argument to all other SS functions instead of a
bin number. The expression \fBstatsbinvar[expr]\fP is a (slightly faster) shorthand for \fBSS_Add[&statsbinvar,expr,1]\fP.
Statsbin variables are an addition to the two internal arrays (both MaxArguments long) that
are available for (scalar and angular) statistics. A statsbin variable has as a value the value that the last
operation made on the statsbin variable returned.
When \fIvariable\fP is an array, a statsbin array of the same dimension is created (the current contents of the array
are lost!). Adding data to an element in the statsbin array is done indirectly: first, the desired element is set
with \fBnDindex\fP or its alias \fB@\fP; the variable can then be used as a scalar statsbin, with all "I/O" connected
to the requested element. E.g.: \fI@[&ssa,1],v[SS_Add[&ssa,20]]\fP equals \fIv[SS_Add[@[&ssa,1],20]]\fP equals \fIv[@[&ssa,1,20]]\fP
(note that \fB@\fP actually returns \fI&ssa\fP when called with only the index argument). \fI@[&ssa,-1]\fP returns the
number of elements (N) in the array; \fI@[&ssa,N,2]\fP adds 2 to all elements; \fI@[&ssa,-2]\fP is redundant. This is not
yet implemented for $SAS (angular) statsbins.
Currently, statsbin variables declarations are saved in XGraph dumps, but their contents are not (as with the contents
of the statistics bins arrays).
.TP
.B SS_Add[n[,expr[,weight]]]
Add a value (given by <expr>) to the statistics bin specifified by <n>; <n> may be a pointer to a $SS statsbin variable.
The value is stored with a weight given by <weight>. A missing expression causes the specified bin or statsbin variable
to be reset; when \fIn==-1\fP, all statistics bin are reset (this excludes the statsbin variables!). Returns <expr>. If <expr>
is a pointer to an array, all elements of that array are added, and the last element's value is returned.
.TP
.B SS_exact[n,value]
Set exact statistics for bin <n> (or for all ascanf bins when <n>==-1), as opposed to using the global variable
\fP$SS_exact\fP (see below). The latter causes all samples to be stored for all statistics bins, not just those
used by the ascanf statistics routines. This can cause a huge difference in memory needs! Changing the "exactness" of a bin
causes it to be reset. (To illustrate: using \fB$SS_exact[1]\fP, on 395 sets of 20 elements, and some 13 ascanf bins,
without specifying the sample size led to 121+ Mb core image; using individual exactness, and specififying the sample size
to less than 8Mb...)
.TP
.B SS_SampleSize[n,value]
Specify and re-allocate 
the number of samples bin <n> (or all, if <n>==-1), and set it to be exact.
If not specified, a dynamic re-allocation scheme will be used,
that can be too pessimistic (currently never more than 128 values over-allocation). <value> <= 0 causes de-allocation of 
previously allocated memory, and unset the exactness of the bin. Any changes cause a reset.
.TP
.B $SS_exact
When true, individual samples are stored with the regular statistics bins (SS_Mean). In this case,
median, average or absolute mean deviation can be queried, and the standard deviation is calculated
using a corrected two-pass formula (to correct for errors in the mean; see the Numerical Recipes 14.1).
Note that the median doesn't use the weights specified (for the moment); in all other cases (and regardless
of the value of $SS_exact), weights are scaled (normalised) with a factor \fB<N>/ <sum of weights>\fP.
.TP
.B SS_Median[n]
.TP
.B SS_Quantile[n,prob]
.TP
.B SS_Adev[n]
Give the median resp. the quantile at probability <prob> resp. the average or absolute mean deviation
for statistics bin <n> when \fB$SS_exact==1\fP or the bin
is exact.
.TP
.B SS_FTest[n1,n2]
Does an F test to compare the variances in stat bins <n1> and <n2>. $SS_exact must be set, or both bins exact. The F value
is stored in the static variable \fB$SS_F_Value\fP. The function returns the probability that the variances
are equal. A prob. of 2 is returned upon (any) error, in which case the F value is set to -1.
.TP
.B SS_TTest[n1,n2]
.TP
.B SS_TTest_uneq[n1,n2]
.TP
.B SS_TTest_paired[n1,n2]
.TP
.B SS_TTest_correct[n1,n2,f-prob_max]
T tests on stat bins <n1> and <n2>, return the probability that the means in those bins are equal ("significance").
$SS_exact must be set, or both bins exact. The T value is stored in the static variable \fB$SS_T_Value\fP.
\fBSS_TTest[]\fP assumes
equal variances, else use \fBSS_TTest_uneq[]\fP, and \fBSS_TTest_paired[]\fP does a paired-sample test provided
\fBn1 == n2\fP. Error handling is identical to that of \fBSS_FTest[]\fP. The \fBSS_TTest_correct[]\fP routine
does an f-test first, and depending on whether the result obtained is smaller than the specified maximum (\fBf-prob_max\fP),
it does either the unequal or the equal variances test. Note that all but the matched sample versions are also available
in versions which accept a pair of mean and \fIstandard deviation\fP; these are called \fBT-Test\fP, \fBT-Test_uneq\fP,
\fBT-Test_correct\fP and \fBF-Test\fP. \fBT-Test_correct\fP also accepts a pair of arrays as the input data to be compared;
in that case, mean and variance are determined from these, heeding the setting of \fI$SS_exact\fP.
\fBn1\fP and \fBn2\fP may be integers indicating the desired stat bins, both may be pointers to $SS statsbin variables,
or \fBn1\fP may be a pointer to a $SS statsbin *array*, and \fBn2\fP a pointer to an array of at least 2 elements, indicating
the elements in \fBn1\fP to compare.
.TP
.B $SAS_Ignore_NaN
A flag that (currently) affects only ascanf's use of statistics bins - all of them. When set, NaN values are ignored, whether
the data added is NaN, or whether data * weight is NaN. This may become a general switch, and a bin-specific version may
appear in the future.
.TP
.B $SAS_StatsBin[&variable,exact[,radix,offset,convert,expr1[,exprs...]]]
Convert a pointer to an existing scalar variable to an angular statistics bin (statsbin). The \fIexact\fP argument
determines whether or not "exact" statistics (see \fBSAS_exact\fP) are performed.
Additional values given with the
expr1,<exprs> (one or more expressions!) are stored in the newly created statsbin, in a way controlled by the
<radix>, <offset> and <convert> arguments (for explanation, see below, \fBSAS_Add\fP).
Additional calls will only set the \fBexact\fP, \fBradix\fP and \fBoffset\fP flags
on the already existing statsbin, and add the expressions.
The routine returns the number of items stored, or -1 upon failure.
A pointer to the resulting $SAS statsbin can be given as the 1st argument to all other SAS functions instead of a
bin number.
The expression \fBstatsbinvar[expr,convert]\fP is a (slightly faster) shorthand for
\fBSAS_Add[&statsbinvar,expr,1,radix,offset,convert]\fP (where <radix> and <offset> are the values associated with the
statsbin variable).
See also the description of \fB$SS_StatsBin\fP.
.TP
.B SAS_Add[<bin>,<value>[,<weight>[,<radix>[,<offset>[,convert]]]]]
Add a <value> to the angular statistics bin specified by <bin>; <bin> may be a pointer to a $SAS statsbin variable.
The radix and offset of the bin can be specified, as described under
\fB-radix\fP and \fB-radix_offset\fP. Note that the \fB<offset>\fP argument doesn't have much interest in the calculation 
of the statistics!
Both the \fBradix\fP and the \fBoffset\fP arguments are "sticky": the last value set remains in effect until the next
change (\fBradix\fP is set to 2pi when 0).
The \fBconvert\fP argument does on an individual basis what the \fB$SAS_converts_angle\fP variable does
globally (see below). A missing expression causes the specified bin or statsbin variable
to be reset; when \fIn==-1\fP, all angular statistics bin are reset (this excludes the statsbin variables!). Returns
<value>. If <value> is a pointer to an array, all elements of that array are added, and the last element's value is returned.
.TP
.B SAS_exact[n,value]
Set exact angular statistics for bin <n> (or for all ascanf bins when <n>==-1), as opposed to using the global variable
\fP$SAS_exact\fP (see below). The latter causes all samples to be stored for all angular statistics bins, not just those
used by the ascanf statistics routines. This can cause a huge difference in memory needs! Changing the "exactness" of a bin
causes it to be reset.
.TP
.B SAS_SampleSize[n,value]
Specify and re-allocate 
the number of samples bin <n> (or all, if <n>==-1), and set it to be exact.
If not specified, a dynamic re-allocation scheme will be used,
that can be too pessimistic (currently never more than 128 values over-allocation). <value> <= 0 causes de-allocation of 
previously allocated memory, and unset the exactness of the bin. Any changes cause a reset.
.TP
.B $SAS_exact, $SAS_converts_angle, $SAS_converts_result
These are variables controlling the behaviour of the SAS_Add_Data function. \fB$SAS_converts_angle\fP and \fB$SAS_converts_result\fP
variables control whether or not input respectively output values are converted into the range \fB<-radix/2,radix/2]\fP. The
\fB$SAS_exact\fP variable selects the algorithm used. When 0 (not "exact"), separate sums are determined over the negative and
the positive values added. The mean angle is then determined as the arctangent of (the sum of the sine of the average pos. angle plus
the sine of the average neg. angle) divided by (sum of the cosine of the av. pos. angle plus the cosine of the av. neg. angle); the
standard deviation is determined as if the values were actually scalars. 
When SAS_exact, angular statistics use a (more) exact scheme. In this case,
each value added is stored in incremental registers for cosine 
and sine of this value, plus in an array keeping track of all
individual values added (converted according to \fB$SAS_converts_angle\fP).
The weights are applied to the sine and cosine. The mean
angle is then determined as the arctangent of the average sine value divided by the
average cosine value. The standard deviation is determined as the square root of the
(sum over all values of the squared difference of each value minus the mean angle) divided
by (the number of values [N] minus 1) (i.e. the definition of stdv). The difference of value minus
mean angle is taken as the minimal difference, i.e. the minimal angle between these two angles.
Each individual squared difference is multiplied by its individual weight times N/(sum of weights).
.TP
.B $ReDo_DRAW_BEFORE
Set if the *DRAW_BEFORE* statements contain necessary resets to be executed before doing
any other processing - e.g. *DATA_PROCESS* statements are executed more than once
under certain conditions, like re-initialisation when the number of points in a curve changes as
a result of runtime discarding of points. It also determines whether or not the *DRAW_BEFORE* is
executed again after an auto-(re)scale generated (silent) redraw. The execution of the *DRAW_AFTER* statement does not depend
on this flag.
.TP
.B $Really_DRAW_AFTER
Set if a *DRAW_AFTER* command should be executed as the really last thing in a window redraw. For non-autoscaled
windows, the only difference is that the window will have been drawn (also on screen ;-)), and its titlebar updated
showing all relevant information (including timing info, thus the DRAW_AFTER commands are not timed). When autoscaling,
this is also the case, which thus means that the commands are executed after the real redraw, instead of after the
silent internal redraw used to determine the scaling bounds.
Set this variable if the DRAW_AFTER commands are e.g. to prompt for user action based on what the graph shows...
.TP
.B CheckAssociations_AND[n,val[,val,...]]
Check whether all values \fBval\fP specified are associated with set \fBn\fP's list of associations.
.TP
.B CheckAssociations_OR[n,val[,val,...]]
Check whether one of the values \fBval\fP specified is associated with set \fBn\fP's list of associations.
.TP
.B CheckAssociation#_OR[n,ass_nr,val[,val,...]]
Check whether set \fBn\fP's association number \fBass_nr\fP has a value listed in the value-list \fBval[,val,..]\fP.
(There is evidently no AND version of this function..!)
.TP
.B getAssociation[n[,nr]]
Retrieves association number \fBnr\fP of set number \fBn\fP. If \fBnr\fP is not given, return the number of associations.
.TP
.B Associate[n,ass_nr[,val,..]]
Run-time variant of the \fB*ASSOCIATE*\fP command. This command allows setting the number of associations
to a given value (<ass_nr> > 0 and no value-list passed), deleting all associations (ass_nr=0 and no values
passed). When a value-list (val1[,val2,..]) is passed, these values are stored starting at location (association)
number <ass_nr>: when <ass_nr> == -1, they are appended to the current list. Expansion is handled where
necessary (contraction must be performed by passing the desired size, and no value-list).
.TP
.B AddDataPoints[setnr,val1,val2[,...]]
Add (append) a row of data to the specified set. In the simplest case, this takes the form \fBAddDataPoints[setnr,X,Y]\fP.
At most \fBncols[setnr]\fP values are heeded; the rest are ignored.
.TP
.B numPoints[[setnr[,new]]]
Without arguments, returns the maximum number of points in all currently existing sets. With a single argument,
returns the number of points in that set. The optional <new> argument allows to resize the set (add rows). This must be a positive
number. New dataslots are initialised to 0. A special case is \fInew=0\fP. In that case, only the sets "number of points"
state is set to 0, but the actual storage areas are not touched. This allows a fast (and safe) "rewind" to an empty set, to
start adding points (with AddDataPoints[]) from position 0. Note that special care must be taken with this option: a set
without points is normally ignored while drawing (and thus, processing). In addition, the \fBSkipSetOnce\fP is set.
Thus, the "best" way to use this rewind possibility
is to issue the rewinding statement in the DATA_INIT, and add all points in the DATA_FINISH statement (which will be executed
immediately after the DATA_AFTER for point 0), taking care to also call \fBSkipSetOnce[<set>, 0]\fP.
.TP
.B ncols, ncols[n[,N]]
The first form returns the number of columns of the current set, the second form the number of columns
in set # <n>. The optional 2nd argument <N> allows to change the number of columns of a specified set.. Newly
added columns (all \fBnumPoints[n]\fP lines long) are initialised to all 0s. The value of N is clipped to
3 as a minimum value; reducing the number of columns can affect windows displaying those columns!
.TP
.B DataVal[set,col,i[,newval]]
Returns the (raw) value stored in line <i> of column <col> in set <set>, or sets it to <newval>.
.TP
.B SHelp[pattern]
Finds functions, variables and procedures whose name or description match \fB<pattern>\fP and pops up
a window listing them. The output is similar to the output produced by the Settings Dialog's [Fnc]
button, except that array values and procedure code are listed.
.TP
.B verbose[expr]
.TP
.B no-verbose[expr]
Causes verbose (or non-verbose...) processing of \fBexpr\fP, showing the (sub)expressions being parsed, and the results.
Also useful to view array contents: to view all elements (instead of the standard max. 48+3), do
\fBverbose[array[-1]]\fP. Can also be set with the variable \fB$verbose\fP.
.TP
.B popup[expr]
Creates a popup window with the output generated by \fBexpr\fP. All output that normally goes to stderr is redirected,
and afterwards shown in a window. To show only output generated with e.g. \fIprintf[2,...]\fP, put the \fIpopup\fP
call inside a \fIno-verbose\fP scope: \fBno-verbose[ popup[ printf[2, ...] ] ]\fP. This eliminates the otherwise
displayed function calls, results, levels, etc. and shows only the output generated by the printf statement.
.TP
.B last_popup[[expr]]
Pops up the dialog generated by the last popup[] function. The arguments only serve to
determine the function's return value/side effects. As with all popup windows, the time and date
of posting are stored in the title's description, accessible by control-clicking on the title.
.TP
.B $popup_verbose
When set, verbose mode is activated within the scope of a popup[] command.
.TP
.B $compile_verbose
When set, verbose mode is activated when compiling an expression.
.TP
.B $UseConstantsLists
When set, the compiler checks for argumentlists consisting of constants (numbers) or
variables or "last indexed array-element readouts". These lists may be 2 levels deep,
that is, a double variable assignment may occur: foo[bar[var]] is accepted. Such
lists are then evaluated without additional nesting of the evaluation stack, that is,
they are evaluated in the same context as the function that they are argument to. Some
examples of benchmarks (optimised expr. first, evaluated at the commandline with the \fB-IPN\fP
option). See the examples/benching.xg file for examples on the timing effects of this option.
NB: \fIfor-toMAX\fP is a for-to loop function that evaluates the termination condition (its 2nd argument) only
once, at the start of the loop.
.TP
.B comment[expr]
As \fBverbose[expr]\fP, but the results are added to the Info (comment) buffer.
.B $VariableInit
Determines how a variable is initialised if declared by DCL[foo];
0: initialise at 0;  >0: initialise with the number of so declared variables;
<0: initialise with a random number [0,1> (useful for checking dependence on initial variable values ;-)).
.TP
.B $ExitOnError
Normally, errors occuring during processing of (f)ascanf code/calls are not fatal, and are not ignored more
than necessary. When this variable is set, errors occuring during the processing of an input file cause the
remainder of that file to be skipped (as with the \fBexit[1]\fP command).
.TP
.B $ReadBufVal
A variable that contains the current numeric (floating point) value stored in the read buffer. This is
a rudimentary input mechanism that can come in handy to enter values via a key handler (see \fB*KEY_EVAL*\fP).
It is NaN when the buffer does not contain a value.
.TP
.B ClearReadBuffer
Clears the read buffer, just like a redraw request or hitting the Escape key would. The difference is that calling
this function has the effect that the next key that ought to be stored in the read buffer, is not stored. This
makes it possible to enter a value via a key handler, and immediately delete that value from the read buffer. The
ClearReadBuffer function returns the previous value of $ReadBufVal.
.TP
.B PopReadBuffer
Removes (pops) the last entered character from the read buffer. In a key handler, this allows to leave the read
buffer untouched (i.e. remove the character that invokes the handler).
.TP
.B ProcessSet[<setnr>[,<pnt_nr>]]
Invoke the processing associated with the currently active window (DRAW_BEFORE, the various DATA_xxxx,
SET_PROCESS, and DRAW_AFTER). Only processes point <pnt_nr> of the requested set(s), or all points
when pnt_nr is missing or equals -1. Process only set <set_nr>, or all sets when set_nr==-1. The main use
for this function is to cause \fBtr_xval\fP, \fBtr_yval\fP and the other functions returning transformed
values to return the correct values for the active window. (These functions in fact return the values also
used for drawing when a window is in QuickMode.) This makes it possible to dispose of the correct, actual
values when e.g. evaluating a KEY_EVAL expression in a window that was not the last to have been
redrawn.
.TP
.B $Sets-Reordered
A read-only variable that is set - for each and every window until that window has been fully redrawn - when
the order of the sets has been changed, or when sets have been added.
.TP
.B ShiftSet[<set>,<dirn>[,<extreme=0>[,[<redraw=1>]]]]
Shifts the selected set: left if dirn<0 (to start if <extreme>); right if dirn>0 (to end if <extreme>).
A redraw is done by default, unless <redraw>=0.
.TP
.B $SyncedAnimation
When true, do a (probably redundant) sync after all animating windows have been redrawn once.
.TP
.B $AllowSomeCompilingInitialisations
Defaults to 1. When set, variables and arrays that are declared (using DCL or Declare) while compiling
an expression are initialised with the value they would \fIprobably\fP get when the expression is
evaluated the 1st time (or evaluated without compiling). This is probably true when, e.g. in case of
a statement like \fBDCL[foo,<exp>]\fP, <exp> is a constant, or a list of constants. Why? Because the
compiler does not evaluate every expression as completely as the parser does, even though they are
actually one and the same set of algorithms. When compiling, an effort is (should be..) made to prevent
side-effects as much as possible (e.g. resizing arrays, permanent operations on datapoints,...). Thus,
a warning is fired when <exp> contains non-constant expression(s) (when $UseConstantsLists is set too!).
But, on the other hand, a statement like \fBDCL[array,N,val0]\fP would generate a warning about allocating
a 0-element array (even if N>0) when $AllowSomeCompilingInitialisations is not set...
.TP
.B QSortSet[set_nr, &value_procedure]
Does a quicksort on the specified set <set_nr>. The sort is based on a sorting value determined by <value_procedure>.
This procedure receives 2 arguments in the \fB$\fP array: the first is the set number being sorted, the second the
index to a point. The expected return value is the sorting value associated with that point. To sort a set in
order of ascending X value, return simply \fIDataVal[$[0], xcol[$[0]], $[1]]\fP. In order to sort in descending
order, negate that return value. The QSortSet routine returns the number of comparisons made by the internal qsort()
call. The actual sorting of the set's data points is done after that call, and is not done "in place". See also
\fBQSortArray\fP.
.TP
.B QSortArray[&array, &compar_procedure, &elemA, &elemB]
Do a quicksort of the array pointed to by \fBarray\fP, using the \fIqsort(2)\fP algorithm. The comparison
(on a pair-of-elements basis) should be done by the procedure pointed to by \fBcompare_proc\fP. Since
procedures don't accept arguments, the 2 elements to be compared must be stored in global variables
\fBelemA\fP and \fBelemB\fP, also passed as pointers to the QSortArray[] routine. A sort in order of
increasing value would be done by e.g. \fB DEPROC[ comparison_procedure, sub[elemA,elemB] ]\fP. The
routing returns the number of comparisons made. Note that calling this routine in a context where the
verbose flag is set (verbose[ QSortArray[...] ]) will generate a lot of output: the comparison_procedure
will also be evaluated verbosely (as always with procedures..). Access handlers are supported on all
variables involved. (NB: compar_procedure can also compare $[0] and $[1], but elemA and elemB
must still be specified).
NB: \fBcompar_procedure\fP may also be a pointer to a function that accepts 2 arguments;
passing \fI&sub\fP will do an incrementing sort (that is some 8x faster than passing
\fIlambda[sub[$[0],$[1]]]\fP instead).
.TP
.B nDindex[x,y[,z,..],Nx,Ny[,Nz,..]] or @[...]
.TP
.B @[&array,x[,y,..][,Nx,Ny,..][,newval]]
.TP
.B @[`string]
This routine (full name nDindex, abbr. \fB@\fP) does 2 things.
In its first form, it provides a way to address one-dimensional arrays as arbitrary-dimensional
arrays. It computes the location of the element (x,y,...) in an array of dimension (Nx,Ny,...) (at least 2 dimensions must
be given).

In its second form, this routine takes an array pointer as its first argument. In this case, it performs the same operation, but
returns the corresponding element/value from the array (<\fB&array\fP> can also be a pointer to a scalar value). In this form,
there is no constraint on the number of dimensions: a single indexing value is allowed (e.g. \fInDindex[&kk,2]\fP is equivalent to
\fIkk[2]\fP; note that no \fBNx\fP argument should be given in this case!). If the \fBnewval\fP argument is also specified, the
element/location referenced will be set to this new value. The goal of this routine is of course to provide a
generic tool for dereferencing pointer variables.

In its third form, it takes a single string pointer, and returns a hash value (calculated by the same algorithm as used internally
to hash the function table).
.TP
.TP
.B fopen[<filename>,`mode-string]
.TP
.B fopen[&fp,`filename,`mode-string]
Opens a file with mode given in mode-string (see fopen(2)). The name of the file is the string associated with
<filename> (which does not have to be a stringpointer; it can point to anything but a function). It is thus possible
to associate a file with a procedure. A previously opened file associated with the same variable is closed before
opening the new file. Upon success, <filename> is returned (i.e. the 1st argument), otherwise 0.
Upon success, <filename>'s value is also set to &filename or `filename (i.e. to the 1st argument passed).
NB: <filename> can be a temporary (local) stringvariable: \fIfopen[ `"foo.out", `"w" ], printf[`"foo.out", `"bla#xn"],
fclose[`"foo.out"]\fP is will create a file foo.out containing the word bla. Note also, however, that deleting a variable
closes any associated file.
Use a \fB|\fP as the very first character of the filename to open a pipe to a command.
In its second form, the calling convention is more like the C version of fopen(); the fp argument (a pointer to a variable)
receives the file opened as described above, and the filename is associated with it; a pointer to this variable is returned.
This form removes the need for an additional call to set the filename.
.TP
.B fflush[<filename>]
.TP
.B fclose[<filename>]
Flush or close the file associated with <filename>.
.TP
.B printf[<target>,`format[,arglist]]
This is a C/printf() like routine. It can print to file (<target>=1:stdout, 2:stderr), or to a stringpointer
(<target> must take the form `target).
target==0 (stdin..) is currently (silently) taken to mean stderr; target<0 is a way of quickly skipping the
printf statement.
When <target> has a file associated with it, that file is used, regardless
of whether <target> was specified as `target, &target or target (as long as the value as set by fopen[] has not been changed).
<arglist> can contain expressions evaluating to values or "plain" pointers, or
stringpointers (`stringvar; printed as string). The treatment of "plain" pointer differs according to the
context and the variable it points to. If that variable is an array, all elements of
the target array are printed, unless it the array pointer was an element of another array being printed. In that
last case, and for all other types of pointers, the name of the variable pointed to is printed.
NB: It used to be that if the plain pointer
pointed to a procedure, the procedure's source code was printed. This is no longer the case: use \fBProcedureCode\fP instead.
It is the caller's responsability to provide enough printf() valid formatting fields in all cases. In verbose mode, or when
compiling, the internal callback routine will provide an errormessage when there is a mismatch, but the code will still
run, potentially evoking a nasty crash. Note very well that checks are made only against valid xgraph formatting fields -
%s only! Other formats are not supported, and not checked for. Notably, take care that to print a \fI%\fP sign, you need
to put \fI%%\fP in the format string!
Values are printed as \"usual\" (using the format specified by *DPRINTF*). The implication is that
the printf() format-fields used (all of them!) should be those for string variables (of the form %s)!! There may come a
version that will allow per-argument specification of the format, and then there may not... Internally, this
routine stores all to-be-printed arguments in a single array of strings, that gets passed to vfprintf() or
vsprintf(). That is one reason why using the *DPRINTF* format is the easiest solution: this first prints
all arguments in separate strings. NB: printing to a string requires knowledge of the resulting stringlength
(the general strategy for routines that store information in a variable is to guarantee allocation of sufficient memory space,
and not to burden the user with this). This currently implies a separate call to vfprintf(), performing the
same printing action to the null device /dev/null. It is however currently the best way to assign a string to a variable
if one disregards the DCL[var,val,"newstring"] method. It also provides the only 2 ways to \fIfree\fP the string associated
with a variable: \fIprintf[`stringvar]\fP (i.e. the stringpointer as the only argument). Or
\fIprintf[`stringvar,`emptystringvar]\fP; in all other cases, a null string variable as 2nd argument is replaced by the
string \fI"<NULL>"\fP.
[see the example file \fIahandler-that-prints.xg\fP for an example of these issues, and how to use this routine in
an access-handler procedure to print useful information.]
.TP
.B $ (or $ArgList)
This is an array that contains the arguments passed to the current frame, and that is valid only in procedure
code. In a call
\fIverbose[ <a>, <b>, $, <c> ]\fP, elements 0 and 1 of the array will contain <a> and <b> respectively, but
element 3 will not yet contain <c>! Its use is intended for procedure code, where it *will* contain all the arguments
that were "passed" to that procedure. If \fIDEPROC[foo, verbose[$[0],$[1]]]\fP, calling \fIfoo[1,2]\fP
will print 1 and 2, etc. The number of arguments passed in this way is accessible as $[-1], so that if necessary,
global variables (or default values) can be used when the procedure was invoked without arguments. In a procedure that 
is called as an accesshandler to some entity, the $ array contains the arguments passed to that entity. This array
can also be referenced as \fB$ArgList\fP, but that is an alias that is not guaranteed to be preserved when the
resulting code is (pretty)printed or saved.
\fINote\fP: if a procedure is called with \fB&$\fP (a pointer to \fB$\fP) as its sole argument, the current value(s) of \fB$\fP
are passed to that procedure. This allows to call a procedure from within a procedure, passing it all arguments that were
passed without knowing their number, etc. It also executes faster.
.TP
.B SetColour[set,`cname[,new]]
.TP
.B SetHighlightColour[set,`cname[,new]]
Retrieve a set's (highlight) colour, and optionally choose a new colour \fIafterwards\fP (i.e. the value returned is
the value before the call). If the set's colour is one of the predefined attribute colours, SetColour[] returns the
attribute number. Otherwise, and also for the highlight colour, \fIcname\fP (which must be a pointer or a stringpointer);
is used to store the colourname. A pointer to cname is returned in that case. The returned highlight colour name is
the global highlight colourname in case the set does not have its own highlight colour.
\fInew\fP can refer to a new colour. It may be one of the predefined attribute numbers, or a stringpointer containing
a colourname. It can also be a pointer to an array with 3 elements. In case of a doubles array, these are interpreted
as the red,green,blue \fIintensities\fP (range 0-1); in case of an integer array, as a 0-256 red,green,blue triplet.
Nothing changes if that colour does not exist. For SetHighlightColour[], passing new<0 will restore
the use of the global highlight colour. If new is an array, the resulting colour specification (requested and obtained) are
stored in the description/usage field.
.TP
.B SkipSetOnce[set,boolean]
Skip this set from the moment the command is issued, until the next redraw. This makes it possible to not \fIdraw\fP
a set, but only use its data for other things with the regular \fB*DATA_PROCESS*\fP commands. (These are not
executed for sets that are not drawn because of DrawSet[set,0].) But note that this may interfere with the correct
functioning of the QuickMode. As long as no set cycling is done, nothing happens. But as soon as sets are
cycled (e.g. with the cursor keys), the now-displayed set may have its skipOnce field incorrectly set or unset.
.TP
.B SetBarWidth[set[,new]]
.TP
.B SetCurrentBarWidth[set]
SetBarWidth[] returns the actual set's barWidth, and optionally sets it to a <new> value. new=NaN means use the global parameter,
new<=0 means scale to the horizontal axis.
SetCurrentBarWidth[] returns the actual set's barWidth. When this value has been set to a positive value (new>0 for SetBarWidth[]),
the returned value is identical to <new>, or to the global width. When the bars are scaled, the value returned is the actual width of the
last drawn bar (i.e. the behaviour is not well defined for either a non-linear X-axis, or a set with a non-constant X-step).

A similar pair of functions exist for the error bar/box/etc width: SetEBarWidth[] and SetCurrentEBarWidth[]. The latter routine
returns the actual width of the first drawn error bar when this width has not been specified.
.TP
.B FitBounds[x,y]
XGraph provides an internal autoscaling function. It defaults to a "forward" behaviour. That is, a silent redraw
(of the whole graph, or only the data) is performed during which any defined processing is evaluated (except
for the TRANSFORM_? axes transformations). The "real" redraw that follows then makes use of these evaluated
results, and is displayed using the scaling based on the X and/or Y ranges found. This usually works satisfactory.
However, the result of the processing can depend on the scaling. For example, it is possible to use the current
X or Y minimal or maximal bounds in an expression. Also the current width of (error) bars can depend on the
graph's size and scale, as do the dimensions of text drawn with the drawing pens (these are given in world
or plot co-ordinates, not in pixels). This makes that one-step autoscaling is not possible; autoscaling will
converge to a stable solution (or not...) after a variable number of redraws. The differences in subsequent scaling
can be especially large when drawing to a PostScript device. Several options exist to remedy this situation.

The \fBFitBound[]\fP functions allows to 
do an immediate fit (autoscale) of the X (if x=True) and/or Y (if y=True) axes. The number of changes to the
scaling are returned. This routine only has effect when the window is not being fitted actually.
This routine is to be used with deliberation; it probably only has use in a \fB*DRAW_AFTER*\fP command (of a *DRAW_BEFORE*,
both can be executed "outside" of the builtin autoscaling function),
with $Really_DRAW_AFTER[1]. Even then, the scaling likely will not converge immediately to the final value, so an
expression like the following may be necessary:

.sp 1
.nf
*DRAW_AFTER*
	...,
	ifelse[ FitBounds[1,1], redraw[1], 0 ],
	... @
.fi

This statement will cause the window to be redrawn until the axes' ranges no longer change. The same effect can
be obtained through the internal autoscaling. By setting the \fB-fit_after\fP flag, the autoscaling is done
after completion of a redraw (no autoscaling precedes the first redraw). As long as changes in the axes' ranges
are detected, the window is redrawn (animated). When printing to a PostScript device, care is taken not to
output the intermediate stages; the redraws needed to converge the scaling are sent to the null device. If afterwards
the scaling proves to be unstable, the additional redraws are erased from the PostScript file if seeking is possible
(only when printing to file).

I am in the process of adding a precision limit to the process. This is a percentage of bounds change under which
the scaling is considered stable. The change percentage is calculated for each axis separately; the largest is
taken in case of combined X/Y scaling. For each axes, the percentage change of the lower and upper bounds are determined.
If these are of the same sign, the largest (in absolute value) of the two is taken as the combined change for the
axis. When they are of different sign, their sum is taken. Thus, 5 percent decrease of the low bound, and 5 percent
increase of the high bound combines to 10% total change, whereas 3 percent increase of the low and 5 of the high bound
combines to 5 percent total change. Currently, there is a fixed precision of 0.005 percent. In addition, XGraph maintains
a history of the change percentages of the last redraws (currently 15). When the average \fIchange\fP in the \fIchange 
percentage\fP over that number of redraws in both directions becomes larger than a tiny, negative number (currently, -0.005), 
the iterating fitting process is interrupted. This history is reset on a successfull fit.
.TP
.B $ValuePrintFormat
The printf(3) formatting string used for printing doubles in almost \fIall\fP cases where floating point variables
are printed. See the discussion under \fB*DPRINTF*\fP
\fBNB\fP: this was previously called $\fIDouble\fPPrintFormat!
.TP
.B $ValuesPrinted[2]
An array initialised by \fBprintf[]\fP; it contains respectively the number of printed values, and the number of %s fields
passed to printf[]. Normally, these two values will be equal.
.TP
.B $VariableLabel
This is a string variable, initialised to the null string. Its purpose is to label newly created variables, say with a
label \fIlabelled-set\fP (a text label, thus): \fIprintf[`$VariableLabel,"labelled-set"]\fP. All variables (scalars, arrays
and procedures) declared after this point will be labelled with this label, until it changes, or until it is reset to null 
with the command \fIprintf[`$VariableLabel]\fP. Those variables can then be deleted all together with the command
\fIDelete[$Label=labelled-set]\fP (unconditional; note no quotes here) or \fIDelete[$UnUsedLabel=labelled-set]\fP
(conditional; only if unused). To conditionally delete all unused variables remaining after parsing \fIfile1.xg\fP (note
that \fB*This-File*\fP gets substituted by the current file's path+name in \fB*EVAL*\fP expressions):
.sp 1
.nf
*EVAL* DCL[old$VL,0], printf[`old$VL,`$VariableLabel], printf[`$VariableLabel,`"*This-File*"] @
....
*READ_FILE* noprocs.xg
*EVAL* printf[`$VariableLabel,`old$VL], Delete[$UnUsedLabel=*This-File*] @
.fi
These labels are saved to XGraph dumps, and restored when this dump is next read into XGraph. Thus, labels are persistent across
save/restores, but only when \fB$VariableLabel\fP is not set when reading in a dump!
.TP
.B $LastActionDetails
This is an array that contains information about the last interactively performed action. The first element is an
action identifier, the remaining elements describe that action. Currently supported types:

\fB0\fP: no data available.

\fB1\fP: a datapoint or set(s) were displaced; the remaining elements contain: X-shift, Y-shift, <num-points>, <num-sets>.
The <num-sets> field is 0 when only 1 point was displaced.

\fB1.1\fP: a datapoint or set(s) displacement was undone; the remaining elements contain: - X-shift, - Y-shift, <num-points>, <num-sets>.
The <num-sets> field is 0 when only 1 point was displaced. NB: the shift values are now negated with respect to the undone action.

.TP
.B getenv[name[,eval]]
An interface to the shell's environmental variables (see also under Strings and Things). Searchs for a variable with \fIname\fP in
the environment. If a match is found, an attempt will be made to interpret its value as an ascanf expression, unless the <eval>
argument is False. The result of a valid expression will be returned, or otherwise the value of the variable (a string!).
.TP
.B ParseArguments[string[,string[,...]]]
Parse string(s) for command line arguments, as in \fB*ARGUMENTS*\fP. Arguments that specify set-specific settings
apply to new sets only, not to those yet in use.
.TP
.B lambda[exprs]
.TP
.B \l\[exprs]
.TP
.B SUBPROC[exprs]
These three commands are synonyms, and all do what Lisp's lambda expressions do: they create a temporary procedure
out of the expressions given by \fBexprs\fP, and "return" a pointer to that procedure. Thus, one need not define
a specific procedure in order to e.g. do some (one-time) sorting; putting the procedure code in the scope of the
(virtual) lambda function is enough. Of course, internally this boils down to exactly the same thing...
One can test for the presence of lambda functionality by checking for the presence of the \fBcall\fP function that it is
purely non-virtual.
.TP
.B call[&fptr[,exprs]]
Invoke the function or procedure pointed to by \fBfptr\fP, passing it the optional arguments given by \fBexprs\fP.
.TP
.B eval[expression[,compiled[,args]]]
evaluate \fBexpression\fP, which must be a stringpointer. \fBcompiled\fP is a flag
that indicates whether or not the expression should first be compiled to improve performace. It is possible to
specify additional arguments; these are available in through the \fB$\fP array.
The potential main interest of this function is to write and modify code "on the fly".
But don't try to redefine or delete code while it is being exectuted, e.g. by redefining a procedure in its own body.
As it is difficult to catch all potential instances of such situations, xgraph doesn't currently check for it at all. It will crash.
.TP
.B Apply2Array[&source, &target, [pass?,] &expr[, args]]
This functions applies an expression for each of the elements of the \fBsource\fP array. \fBexpr\fP must be a pointer
to either a function or a (lambda) procedure or an array. For each of the elements of \fBsource\fP, this function/procedure is called with
the actual element's value as its 1st argument (unless \fBpass?\fP is False).
Any additional arguments specified after \fBexpr\fP are passed as 2nd
and higher arguments. In addition, the \fB$loop\fP counter is set to the index of the current element. Note that that
loop value is only available in \fBexpr\fP's scope, not in the scope of the \fBApply2Array\fP call! To pass the index
as a 2nd (or higher) argument to \fBexpr\fP, use \fB&$loop\fP.
The result returned by \fBexpr\fP (typically set by \fBreturn\fP for procedures) is discarded when \fBtarget\fP is 0;
when \fBtarget\fP is negative, the result is stored in \fBsource\fP. Otherwise, \fBtarget\fP must be a pointer to a valid
array. \fBApply2Array\fP returns the last evaluated value (like the other looping functions).

\fBApply2Array[stride[,next_only]]\fP sets the stride used for (the) subsequent invocation(s).
The default is 1, meaning all elements
are 'visited' and in the order from 0 to N-1. For stride==-2, only every other element is visited, backwards from
N-1. And so forth. Stride==0 is silently corrected to stride==1.
.TP
.B Arrays2ValCat[which,&categories[,&values]]
Redefine the given value categories.
The \fIwhich\fP argument selects the category: 0=ValCat_X, 1=ValCat_Y, 2=ValCat_I. The \fIcategories\fP
must be a pointer to an array containing
the strings to be used as category labels. The optional \fIvalues\fP must be a pointer to an array with
the values to be associated with the labels in <categories>; if it is not specified, the string addresses
in <categories> will be used instead. If both arrays are specified, the smallest of the 2 determines the
(maximum) number of categories to be defined. The function returns the number of successful associations.
.TP
.PP

For a complete overview and - hopefully adequate - description of all available functions (and variables),
use the
.B -fascanf_functions
option, or hit
.B ?
in an XGraph window.
This pops up a menu of all functions. Hold down the \fBMod1\fP key to flush the cached menu, and rebuild
(refresh) it (to show uptodate information about variables). Clicking on a menu entry will copy the function's
(or variable's) name to the clipboard and close the menu (clicking always closes it). The menu can be
moved by depressing the \fBMod1\fP key with the pointer near the top or bottom of the screen (scrolling), or
by moving the mouse in the desired direction. In addition, the distribution contains a number of files with
examples of various complexity of use of this functionality.

Xgraph includes a simple compiler for this kind of expressions: the parser is capable of - instead of
actually evaluating each (sub)expression - generating a tree describing the expression. Each node
is either a number, a function-pointer with a certain number of arguments, or a variable/label. Evaluating
a compiled expression therefore comprises at most walking down a tree, evaluating possible subtrees to the current
node, and then calling the node's function, and returning the result. Any expression evaluated more than a few
(probable 3) times benefits (a lot) of this.

.SH PROCESSING & ARITHMETIC: commands

.I xgraph
reads its data using the
.B ascanf
family of functions. These functions read an array of doubles separated by tabs
("regular", columnar 
.I data
input) or commas (
.I *PARAM_/*DATA_
input; see below). Instead of doubles, expressions consisting of the functions, routines, variables etc. described
above can be given.
While generating
.I data
from within some (independent) application (say, a simulation programme), this functionality is probably of little use.
It has more use with the two following sets of commands. The
.I *PARAM_
commands can be used to generate graphs of (almost) arbitrarily complex parameter descriptions
.B x,y,e,t -> fx(t), fy(t), fe(t) .
The
.I *DATA_
commands can be used (or combined with the *PARAM_ commands) to define an arbitrary data processing filter.
Each X,Y and/or Error-value is mapped onto a value by this function (f):
.B f: x,y,e -> f1(x),f2(y),f3(e),
where (x,y,e) represents a datapoint.
Arbitrary axis-transformations can be specified with the
.I *TRANSFORM_?*
commands. They define functions
.B f(x)
and/or
.B g(y),
where (x,y) is an arbitrary point in the plane (e.g. the lower point of an error-bar).
The 
.B fascanf()
functionality can also be accessed from within the
.I Settings Dialog.
Where numbers are expected, the input is passed to
.B fascanf()
upon receipt of an "accept" (space(!) or TAB key, or cursor up/down (which also in~/de~crement
the resulting value)). Also,
.B *EVAL*
expressions can be entered.

Note that currently the interpreter of these functions is not fully re-entrant. That is, when XGraph has
different windows open, each of which has some run-time processing specified, concurrent redraws of 2 or
more windows can cause interference on the processing results. This is because information on the current
pointnumber, setnumber, the current raw data, etc. are passed in global variables instead of variables
associated with each window. This is currently remedied by preventing concurrent redraws of windows
which are not in raw_display mode. Any such window requesting a redraw when another one is being drawn ends
up in a queue flushed after the first one being (re)drawn is finished.

.TP
.B *PARAM_RANGE* min,max[,numpoints]
Specify a range for the 'self' function in the next
.B *PARAM_FUNCTIONS*
call. If
.B .numpoints
is missing, it is set to
.B (max-min).
.TP
.B *PARAM_BEFORE* expressions
Specify a line of expressions that are executed before the
.B *PARAM_FUNCTIONS*.
Allows common values to be calculated (
.B self
has valid values, see below) by storing them in the
fascanf() internal memory using the
.B MEM[n,val]
fascanf() function (default 256 slots).
.TP
.B *PARAM_FUNCTIONS* exp1,exp2,exp3
generate a set of
.B numpoints
points, with

.B x=exp1[self] ; y=exp2[self] ; error=exp3[self]

Here
.B self
ranges from
.B min
to
.B max
as specified by \fB*PARAM_RANGE*\fP. You can also use \fB$self\fP, a variable with a slightly different
behaviour than the \fBself\fP function.
.B exp1,exp2,exp3
are expressions understood by to the fascanf() routine that reads/parses the
input: either numbers or functions.
For an overview of these functions, specify the option
.B \-fascanf_functions.
The (text following the)
.B *PARAM_FUNCTIONS*
command is parsed by fascanf() for all requested points.
.IR Note:
occasionally, *PARAM_...* lines can get quite long (maximum allowed length:
.B maxlbuf).
In that case, they can be broken by putting a '\\' and an 'n' at the very
end of the line. This is interpretated as a command to insert a '\\n' at
that point in the scanline.
.IR This\ holds\ for\ all\ lines\ read
A somewhat more friendly manner is provided for the commands starting with
\fB*PA..*\fP, \fBAS..*\fP, \fB*DA..*\fP, \fB*SE..*\fP and \fB*DU..*\fP. For these
commands, a single '\\n' sequence immediately after the 2nd '*', and terminating that
line switches to "read until next empty line" mode. Thus, every line in scope need
not be postfixed with a '\\n'. This "line-joining" mode can also be activated by prepending
the command with an additional * (e.g. \fI**EVAL*\fP), and without the '\\n'. In both cases,
the command has to be the only thing on its line. This is the format that XGraph currently
uses in dumps. Use the \fB-help\fP commandline option to know which combinations of the 1st
2 letters are allowed to activate this mode.
As of version 20040225, a further small evolution applies. Appending an additional * to the
format described above (thus, say, \fI**EVAL**\fP) activates a mode in which all lines are joined until
the first line with a matching closing tag (\fI*!EVAL*\fP in this case). This is the format used in dumps now: it specifically
allows to include empty lines, for instance for readability in ascanf code.
.TP
.B *PARAM_AFTER* expressions
Specify a line of expressions that are executed after the
.B *PARAM_FUNCTIONS*.
.TP
.B *ASK_EVAL*[modal::]Message[::default expressions]
.TP
.B *ASK_PARAM_NOW*[modal::]Message[::default expressions]
Ask for expression(s) to be evaluated immediately, prompting with \fBMessage\fP. When there is an active
window, a small text-entry dialog is opened initialised
with the possibly specified default expressions. Otherwise, the terminal is used (and the default expr. are
shown between brackets). In the specified default expression, the opcode \fB${name}\fP is defined: it is
substituted by the value (or code) of the variable/procedure \fBname\fP. If \fBname\fP is an array,
its current value is used (this may change in some future release). When no ascanf variable/procedure is
found, the opcode is substituted by a match among the environmental variables, if one exists. This makes
it possible to pass code to the programme via environmental variables.
The \fBmodal::\fP flag selects a modal form of behaviour, in which events to other windows are ignored (and probably
lost). This can be practical to prevent redraws that would use incomplete or improperly initialised processing
code.
.TP
.B *EVAL* expressions
.TP
.B *PARAM_NOW* expressions
.TP
.B *EVAL_ALL* expressions
Specify a line of expressions that is evaluated when it is encountered. Normally these
expressions are not compiled (as opposed to the others). A lengthy, once-only calculation
can be accelerated significantly by compiling it: this can be done by passing the whole
expression to the function
.I compile[expr]
which compiles and evaluates it. This is automatic for expressions containing a loop-construct (for-to, for-toMAX,
while-do, do-while). Automatic compiling does
not take place when the expression contains a \fIDelete\fP command, or when 
the first function (the first word) is "DEPROC" (to prevent evaluation at definition of
procedures). The term PARAM_NOW has become somewhat confusing or counter-intuitive at least. It dates from the time that
the only processing possible was through the PARAM_FUNCTIONS mechanism describe above, to be executed at file-load time.
It is kept for backward compatibility.
In all \fB*EVAL*\fP expressions (including the *ASK_.. and *KEY_.. variants), the keyword \fB*This-File*\fP gets
substituted by the current file's name (full specified; use \fB*This-FileName*\fP to obtain only the file name, without the path).
The keyword \fB*Print-File*\fP gets substituted by the current printfile name. This
is either determined from the active window's current device setting, or else from the value passed with the \fB-pf\fP command
line argument.
The \fB*EVAL_ALL*\fP variant will cause the expression(s) to be evaluated in all currently open windows.
.TP
.B *KEY_EVAL* k::expressions
.TP
.B *KEY_PARAM_NOW* k::expressions
This command associates the key \fBk\fP with \fI*EVAL* expressions\fP.
\fBk\fP may be a hexadecimal number (starting with '0x'); a single ASCII character in the range 0-255; or
a key designation of the form \fIcccck\fP or \fIccccFn\fP
where \fIc\fP is either a space or one of \fIc, m, s\fP (the control, Mod1 and shift modifier keys respectively);
\fIk\fP is the intended key; \fIn\fP is a number from 1 to 12 (parsing is in the order indicated). (NB: I have not
yet figured out how to make all combinations possible. Currently, <Mod1>-> must be defined as "ms >", and I'm afraid
that this is the same thing as "ms ," (on US and UK keyboards)).
An empty *KEY_EVAL* k:: removes
the current association, and a *KEY_EVAL* on its own lists the current associations on standard output. The
associations can be saved in XGraph dumps (\fB-DumpKeyParam\fP option, or \fB[KeyParm]\fP button in hardcopy
dialog). It is possible to associate an expression with a key that already
has an XGraph internal meaning. In that case, the internal action is taken first, and the user-defined expression(s)
is/are evaluated afterwards. Assigning an expression to a key does not interfere with the storing of keys in 
the read buffer: "internal" keys are (mostly..) not stored, whereas all other keys are stored. A key expression
is evaluated only once per key press, independent of a number that might have been entered before. The current numeric
value of the read buffer is available through the \fB$ReadBufVal\fP variable. Here are some examples to select the
displayed sets' error type (none, or vector mode):

.sp 1
.nf
*KEY_EVAL* c  0::for-toMAX[0,$setNumber, snr[$loop],
 ifelse[DrawSet[snr],progn[
  ErrorType[snr,0], RedrawSet[snr,0],
 ],0],
],RedrawSet[-1,1] @

*KEY_EVAL*
 c  4::for-toMAX[0,$setNumber, snr[$loop],
  ifelse[DrawSet[snr],progn[
   ErrorType[snr,4], RedrawSet[snr,0],
  ],0],
],RedrawSet[-1,1] @

*KEY_EVAL*
 E::for-toMAX[0,$setNumber, snr[$loop],
  ifelse[DrawSet[snr],progn[
   ErrorType[snr,$ReadBufVal], RedrawSet[snr,0],
  ],0],
],RedrawSet[-1,1] @
.fi
.TP
.B *BOX_FILTER_INIT* expressions
.TP
.B *BOX_FILTER* expressions
.TP
.B *BOX_FILTER_AFTER* expressions
.TP
.B *BOX_FILTER_FINISH* expressions
.TP
.B *BOX_FILTER_CLEANUP* expressions
Defines a number of expressions that are evaluated on a point-per-point basis by the "filter-in-a-box" option
(see under \fB<Mod1>-B\fP). This code is \fBnot\fP saved in XGraph dumps!
The order of evaluation is as listed above, and corresponds to the \fB*DATA_PROCESS*\fP statements. First, the \fB.._INIT*\fP
statement is executed, once for each visible set -- when its first visible point is encountered. Then follow the \fB*BOX_FILTER*\fP
and \fB*BOX_FILTER_AFTER*\fP statements, called for each visible point. After the last visible point has been thus handled,
\fB*BOX_FILTER_FINISH*\fP is evaluated.
When all sets have been tested and possibly processed, the \fB*BOX_FILTER_CLEANUP*\fP statement is compiled (\fIonly at that time!\fP) and evaluated.
In all cases, $CurrentSet, $Counter, $DATA{0}, $DATA{1}, etc. are
set as if drawing the data in that particular rectangular window. The \fB*BOX_FILTER_CLEANUP*\fP statement is a little different:
as a cleanup command comparable to \fB*DRAW_AFTER*\fP. The aforementioned variables are left at their last values (these values are not really intended to be used other than for debugging purposes).
The BoxFilter functionality is also available through an ascanf function:
\fIBoxFilter[`fname, loX, loY, hiX, hiY[, setNumber[, pointNumber]]]\fP.
This function must be used with caution: it (temporarily) deactivates the protection against recursive \fB*EVAL*\fP invocation.
.TP
.B *INIT_BEGIN* [new]
.TP
.B *INIT_END*
These commands delineate a section of the input file that contains initialisation commands. This section, that contain
any valid input, is read and stored. The \fB*INIT_END*\fP command terminates this storage, and dumps the read lines into
a temporary file, that is then read and processed. This is the first evaluation of these commands. The stored section is also
saved in XGraph dumps; before the (possible) dump of the various \fIMEM\fP arrays, and the following declarations
of variables, arrays, procedures, etc. This allows the user (xgraph will never itself put commands in this section) to e.g.
declare variables in the internal dictionary before any reference can be made to them.
These commands are evaluated a second time during the first redraw of any newly opened window that inherited them, after the
installation any of the various possible processing and transformation expressions. This 2nd evaluation allows e.g. to initialise
variables that need that, and that for some reason don't have their place in (e.g.) the \fI*DRAW_BEFORE*\fP command.
The optional \fBnew\fP flag to the \fB*INIT_BEGIN*\fP command indicates that any initialisation code yet or still stored should be
deleted first; without this flag, the existing code is preserved and new code is appended to it.
The initialisation section is "immune" against \fI-skip_to\fP and \fB*SKIP_TO*\fP commands. That is, when such a command is active,
it is suspended when an \fB*INIT_BEGIN*\fP command is encountered, until the first \fB*INIT_END*\fP. The initialisation section
between those markers is then evaluated, and only then is the pending \fB*SKIP_TO*\fP continued. This makes it possible to
to put common initialisation commands at the start of an input file, and specify an offset in the file using e.g. the command
line option \fI-skip_to\fP.
Note that a \fI*FINFO*\fP opcode (cf. \fB*ECHO*\fP) will print the name and time stamp of the file containing the initialisation
section \fIonly\fP during the \fIfirst\fP evaluation. During the 2nd evaluation, this information is no longer available, and
the opcode will instead show the stats of the temporary file used to re-read the commands. Also, during the 2nd evaluation,
the \fB*VERSION*\fP, \fB*VERSION_LIST*\fP and \fB*SET_INFO_LIST*\fP are skipped, to prevent the same information from being
stored twice.
.TP
.B *STARTUP_EXPR* <expressions>
A prefix to any other command, causing it to be executed once only, after startup, during 
the drawing of the 1st window. Multiple such statements are executed in the order in which they
occur. For example, the statement \fB*STARTUP_EXPR**READ_FILE* bla\fP is equal to \fB*SCRIPT_FILE* bla\fP.
NB: Everything after \fB*STARTUP_EXPR*\fP is stored and evaluated verbatim; hence the lack of space in the
example above!
.TP
.B *2ndGEN_STARTUP_EXPR* <expressions>
An expression that will be converted into a \fB*STARTUP_EXPR*\fP statement when
dumping an XGraph dump of the 1st window (or its siblings), or the window currently active
(e.g. the window owning the Settings dialog through which a file is being included which contains
the statement).
.TP
.B *EXIT_EXPR* <expressions>
As \fB*STARTUP_EXPR*\fP, but is executed when xgraph is about to exit.
.TP
.B *DUMP_COMMANDS* <expressions>
Like a *2ndGEN_STARTUP_EXPR* command, but in this case each command is \fBnot\fP preceded by
a *STARTUP_EXPR* opcode. Thus, it is possible to include "direct" commands, i.e. commands that
do not "wait" until window-opening before executing.
.TP
.B *DUMPPROCESSED_SPECIFIC* <expressions>
Like a *DUMP_COMMANDS* command, but these expressions are dumped only when a "DumpProcessed"
dump is made. This allows e.g. undefinition of previously defined *STARTUP_EXPR* expressions.
Example: a script file can make sure it is re-included upon a next load of the data it was
applied to, by including a line \fB*2ndGEN_STARTUP_EXPR**READ_FILE* <scriptfile>\fP . However, when the processed
data is dumped, this is probably no longer necessary: the previous command can then be
removed by dumping an empty *STARTUP_EXPR* to the XGraph dump by saying \fB*DUMPPROCESSED_SPECIFIC**STARTUP_EXPR*\fP .
(Note that in this example we can't use a *2ndGEN_READ_FILE* as a *READ_FILE* command has
immediate effect, and 1) can thus not be removed from a queue and 2) may not be appropriate
for <scriptfile> as it may require the presence of a window.)
.TP
.B *PYTHON_SHELL* [<expr>]
.TP
.B *PYTHON_FILE* <filename>
.TP
.B *PYTHON* <python code>
.TP
.B *PYTHON2* <python code>
As of 2006, XGraph comes with hooks to the Python language. These are not yet well documented, but the information in the
Python.so (and Python.25.so, for Python 2.5) dynamic modules should be self-explanatory enough. Three name-spaces are exported:
\fBascanf\fP, \fBxgraph\fP and \fBxgraph.Pen\fP. The former contains hooks to XGraph's own ascanf language, the other to more general functions, including the pen drawing functionality.
Python code can be parsed through a few ascanf routines (among which \fIPython-Eval\fP, \fIPython-EvalFile\fP) and through the \fB*PYTHON_FILE*\fP and \fB*PYTHON\fP commands. The former causes a Python (source) file to be loaded (through \fIPyRun_AnyFile\fP), the latter runs the text following it through the Python parser (through \fBPyRun_SimpleString\fP).
\fB*PYTHON_SHELL*\fP opens an interactive Python shell in the same way as the ascanf function \fIPython-Shell\fP does. When xgraph is
attached to an interactive terminal and \fB<expr>\fP is absent or positive, an attempt is made to launch an embedded \fIIPython\fP
shell. In case the terminal is not interactive, a PyGTK console is tried. Finally, when \fB<expr>\fP evaluates to a negative value,
the \fIinteract\fP shell from the \fIcode\fP package is used.
In order to have the most reliable error reporting, and in order to have access to the source code from the interactive shell that
can be opened using \fIPython-Shell\fP, prefer the use of \fB*PYTHON_FILE*\fP.
As of 20080922, python files can also be loaded into the Python interpreter either via the \fB-python <file>\fP command line argument, or by prepending \fBpython::\fP to any filename (the latter files will be re-loaded when restarting the process).
Requirements: Python 2.3 or higher, numpy (0.9.4 or higher) and IPython if you want to use the interactive terminal.
As of 20120413 XGraph supports Python 3, which of course requires the Python code loaded to use the py3k syntax.
For convenience the \fB*PYTHON2*\fP opcode exists which signals an inline block of Python code in the older syntax, which
will be converted to the py3k syntax on the fly and without modifying the import file. Similar
transparent functionality does not exist for file-based import, but the Python plugin now prepends a version-dependent
directory at the head of the module search path. When importing from Python 2.x, modules are looked for first in \fB./py2k\fP; when
using Python 3.x, in \fB./py3k\fP . Similarly, if when reading a file with \fB*PYTHON_FILE*\fP, the file is not found at the
exact indicated location, a subdirectory \fBpy2k\fP or \fBpy3k\fP is inserted just before the filename.
.TP
.PP
.I Runtime processes:
.TP
.B *DRAW_BEFORE* <expressions>
This defines a set of actions to be performed once just before a window is to be drawn. No
datapoints are available through routines (like e.g.
.B DATA[]
) described below. It can be used e.g. to reset counters or the like. This statement can be accessed
via the Settings Dialog, using the acronym
.B BD
(since
.B DB
was already taken ...).
.TP
.B *DATA_PROCESS_DESCRIPTION* <description>
.TP
.B *DATA_INIT* <expressions>
.TP
.B *DATA_BEFORE* <expressions>
.TP
.B *DATA_PROCESS*|*data_process* exp1,exp2,exp3
.TP
.B *DATA_AFTER* <expressions>
.TP
.B *DATA_FINISH* <expressions>
These statements define global processes similar to the
.B *PARAM_...*
commands. These commands define point-per-point (runtime) processing of data read (or generated) in the following stages:
*DATA_INIT* (only for the 1st point per set) - *DATA_BEFORE* - *DATA_PROCESS* [- *SET_PROCESS*] - *DATA_AFTER* [- *SET_PROCESS*] -
*DATA_FINISH* (only for the last point per set). The set-specific (hence shared among all windows!)
\fB*SET_PROCESS*\fP processes are evaluated before or
after the (global) *DATA_AFTER* statement (see below). The other statements are executed in the order shown, with the
understanding that *DATA_BEFORE* and *DATA_AFTER* are executed \fIonly\fP if there is a *DATA_PROCESS* defined. *DATA_INIT* and
*DATA_FINISH* do not depend on this process! Note also that currently autoscaling checks for the presence of a *DATA_PROCESS*
(if present, a full silent internal redraw will be done), and not for the presence of *DATA_INIT* and/or *DATA_FINISH* statements.
Thus, if these statements do processing which influence the scaling ranges (e.g. delete points), it may be necessary
to add a stub \fI *DATA_PROCESS* $DATA{0},$DATA{1},$DATA{2}\fP.
The current data, and the user specified interpretation of the columns
(through the
.B -C
) option, are passed through the
.B DATA[n,val]
and
.B COLUMN[n,val]
fascanf() functions. The current X-value is DATA[COLUMN[0]] ($DATA{0}); current Y= DATA[COLUMN[1]] ($DATA{1}) and
current Error= DATA[COLUMN[2]] ($DATA{2}), with the COLUMN values in [0,2].
These slots are initialised only once per datapoint, and can thus be changed in one of the
three processing stages. \fIThis means that once an X/Y/Error value is determined, the corresponding DATA[] call
yields the new value\fP (if e.g. X and Y are to be interchanged, use \fBVAL[0,0]\fP and \fBVAL[1,0]\fP for X and
Y respectively, or use the $DATA{0|1|2} variables, which also retain there value). The current point number is passed in the
.B self
and
.B counter ($counter)
fascanf() functions (variable).
The first three values computed by the
.B *DATA_PROCESS*
expression are copied into the DATA[0..2] slots, and become - hence - the
new X,Y,E values. The other statements have no such direct effect.

When given as
.B *data_process*
(lowercase letters), these expressions are evaluated
.I once only
during reading the data (the use of \fB*DATA_FINISH*\fP is doubtful in this case...).
In the
.B Settings Dialog,
it is possible to enter run-time expressions that are evaluated on-the-fly for each
point each time it is drawn. This allows for some experimentation with (window-specific)
processing commands, that can later be copied into the datafile, or that depend on the complete data-sets
being available.
Enter
.B DB,
.B DP,
or
.B DA
in the setNumber entry-field for the different expressions. The entry-field doesn't allow fancy editing, but can be
copied (right-button) from and pasted into (middle button). These runtime processing variants correspond to the
.B *DATA_PROCESS*
(uppercase letters) form; they are
.I not
evaluated during reading the data. The description can also be given by putting *DATA_PROCESS_DESCRIPTION* on
a line of its own in a *ECHO* block. In that case, all following lines upto the next empty line are added
to the existing description (which may be emptied first).
.TP
.B *SET_PROCESS_DESCRIPTION* <description>
.TP
.B *SET_PROCESS* exp
Similar to a \fB*DATA_PROCESS*\fP statement, except set-specific. It's execution depends on the variable
\fB$disable_SET_PROCESS\fP (0 means don't execute), and on \fB$SET_PROCESS_last\fP which determines whether
the expression(s) are executed before (-1) the \fB*DATA_PROCESS*\fB statement,
before (0) or after (1, default) the \fB*DATA_AFTER*\fP statement (but always
before a *DATA_FINISH* statement).
\fB*SET_PROCESS*\fP applies only to the current set, and there is no way to change that to some other set. Therefore,
there exists an ascanf routine to remove, install or modify a set-specific process: \fBSetProcess[set[,process[,description]]]\fP.
.TP
.B *DRAW_AFTER* <expressions>
Similar to the
.B *DRAW_BEFORE*
statement, except that these expressions are evaluated just after a (succesful) redraw of a window (but before the
window's titlebar is updated). Possible uses are the collection of statistics, or illiciting a redraw. With the latter
option, animation is possible. Presently, there are two
.I fascanf()
routines for this:
.B redraw{[<exp>]}
and
.B CycleSet[#sets{,<exps>}]
(and its brethren), all of which return a value defined with the
.B return[<exp>]
routine. The
.B redraw
routine only causes a redraw for the present window to be scheduled (by setting the window's animation flag), and is thus
of use when some other processing generates new data on each redraw. The
.B CycleSet
routine has the same effect as typing a
.B <cursor left>
or 
.B <cursor right>
into the window: the only 1 set is showed at a time, stepping through the whole collection with
.B #sets
sets at each invocation. With this routine, an animation can be made by automatically drawing the sets in succession.
.TP
.B *ENTER_RAW_AFTER* <expressions>
.TP
.B *LEAVE_RAW_AFTER* <expressions>
Commands that are evaluated after entering or leaving raw display mode, respectively.
.TP
.B *DUMP_BEFORE*
.TP
.B *DUMP_AFTER*
A pair of expressions that are executed respectively before and after making an XGraph dump, a complete dump, that is.
Might be used to delete unnecessary variables and/or resize (huge) arrays to size 1 (the "before" expressions). I don't
see a direct usefullness for the DUMP_AFTER command, other than maybe resetting \fB$ValuePrintFormat\fP that had
been set to some precision-printing-format in DUMP_BEFORE. But then, who knows? :)

.PP
\fIRuntime transformation of the axes:\fP
These commands allow an arbitrary transformation of one or more of the axes to be defined. E.g. to use logarithmic
axes (also available "through a button"). These transformations work on X or Y co-ordinates of the elements of the
graph, e.g. the bottom of an errorbar, \fIbefore\fP the conversion to screen or paper co-ordinates.
.TP
.B *TRANSFORM_DESCRIPTION* <description>
.TP
.B *TRANSFORM_X* exp
.TP
.B *TRANSFORM_Y* exp
Specify an expression that allows some runtime transformation of X-values and/or Y-values (in both cases passed
in DATA[0] or $DATA{0}). These transformations take place at each redraw. This can also be entered runtime by entering
.B TX
or
.B TY
in the setNumber entry-field of the settings dialog.
.PP
With all runtime transformations, it can be desirable to disallow automatic transformation of the graph's bounds
(axis-numbers/ranges). E.g. when the transformation is of the type 1/x (inversion). This can be done
with the
.B -process_bounds
command-line option, or with the
.B proc
button in the settings dialog. With the 
.B raw
button in this Dialog (or by typing
.B R
in the window), one can switch of the transformations. This corresponds to the
.B -raw_display
commandline option. If not set, mouse-actions will be based on the actually shown axis-ranges. Making
zooming "automatic" (not requiring a "transformation-disabling") would require some means of finding the inverse function
of a general transformation in order to find the "untransformed" ranges corresponding to the selected ranges - this might
be done by a numerical search process (since a zoom will mostly be within the current axes-bounds, which are known).
Currently, if 
.B raw_display
is not set by the user, it will be set temporarily during zooming (slightly better than not setting it!), but the ranges
of the new window will still be different from those asked. An errorbox with a message to this extent pops up. As a safety
measure, special zooming options (immediate printing, closing the parent) will
.I not
be performed when
.B raw_display
is not set.
.PP
Note that by default, the ranges/numbers shown at the axes are based on both the
.B *DATA_????*
and the
.B *TRANSFORM_[XY]*
transformations. In other words, the ranges and numbers are determined after those transformations. It is possible
to "postpone" the
.B *TRANSFORM_[XY]*
operations untill after the determination of the ranges. The axes will then show the same numbers (the
.I "real numbers")
as when no
.B *TRANSFORM_[XY]*
operations are requested (only at different locations). This feature (off by default) is toggled by the
.B -transform_axes
commandline option, or the
.B "trax"
button in the Settings Dialog.

Note that this feature is incompatible with the builtin log/sqrt axis-transformations (activated by
.I -ln[xy]
resp.
.I -sqrt[xy])
that are expected to be evaluated in the end (which they are not when "trax" is unset). The same applies
to polar plotting. To prevent numerical disasters,
.B xgraph
refuses to plot when such an illegal combination is requested, instead showing an error-dialog, and possibly
opening the Settings Dialog. As of this writing, this problem can be circumvented for the builtin log/sqrt
transformations only, by including these operations as the last (outermost) of the desired
.B *TRANSFORM_[XY]*
functions. To this end, the
.I fascanf()
functions
.B (powX)
and
.B (powY)
give access to the values entered in the "powX" resp. "powY" entries of the Settings Dialog, or with the
"-powx", "-powy" commandline options.
.PP
Both the
.B proc
and the
.B raw
settings are inherited to child windows, as are the different transformations.
.I X11
event handling continues during
.I fascanf()
function processing (at the cost of some speed). Pressing
.B ^X
in the graph window generates a processing interrupt.
The frequency of eventchecking is controlled by the
.B AscanfCheckEvent
X-resource (with AscanfCheckEvent=0 meaning no checking) (int).
.TP

.PP
\fICursor processing:\fP
Some processing can be coupled to cursor movements. Currently, this can only be done when there is a Cross cursor (\fB-Cross\fP).
If you have such a cursor, and multiple windows open, the current cursor position is shown in all windows. That is, the position
of the pointer, in "real world" co-ordinates, in the active window is also shown in the other windows. If all windows show
the same view, nothing special can be remarked, but when their axes differ, well, then you'll see what I mean. Suppose you have
some datasets that consist of a time (t) trace, and an X and a Y trace - recordings of drawings, for instance. It is pratical, in
order to cleanup such data, to have different windows showing the (X,Y), (t,X) and (t,Y) traces. If you move the cursor in the
(t,Y) window, you'll see that the cursor cross's y position in the (X,Y) window nicely indicates the Y value you "select" in
the (t,Y) window. Without some processing, the same does not occur in the (t,X) window. A simple solution would be to do
with the same functionality as that available in (t,Y) window: using the cursor's Y position in the active ((t,X); the
source) to control its X position in the (X,Y) window. That is possible, with the following statement:

\fB*CROSS_FROMWIN_PROCESS*\fP \fIt_Y_window :: $DATA{1},$DATA{0}\fP

Where \fIt_Y_window\fP is a variable containing a reference to the source window you want (this can also be
any other window specification understood by *ACTIVATE*, etc). \fI::\fP is a separator that
tells where the window expression ends and the (2 element) processing expression starts. The variables \fI$DATA{0}\fP and
\fI$DATA{1}\fP contain the cursor's current co-ordinates.
This statement tells XGraph that when the pointer is in \fIt_Y_window\fP, and it is updating the cross in the window
\fIthat was the active one when the \fP\fB*CROSS_FROMWIN_PROCESS*\fP\fI statement was issued\fP, it should swap
the current X and Y cursor co-ordinates. Of course, you can also do more elaborate things, even retrieving the Y
co-ordinate of the point that is closest to the cursor. Just remember that the active window does not change during
the evaluation of the expression; the target window is currently not available to the processing module. Another
limitation is that you can only link each window to a single source window. The example discussed is developped further
in the example file \fIcleanup.xg\fP. This statement is exported only when the \fBAllWin\fP option is active (see the
discussion of the hardcopy dialog).

The pointer's current position can be queried using the function \fBQueryPointer\fP. It returns the co-ordinates in the
global (2 element) array \fB$PointerPos\fP. The datapoint nearest to any given real world (x,y) co-ordinate can be
found with:

\fBFind_Point[x, y, &set_return,&idx_return[,&X_return[,&Y_return]]]\fP
Here, (x,y) is the reference point. When a point was found (Find_Point returns True), \fIset_return\fP will contain
the set number the point belongs to, \fIidx_return\fP the point's index. The other variables, when specified,
will contain the point's X and Y co-ordinates. Note that these are in the co-ordinate space defined by the current
axes, that means, the transformed values, if transformations have been defined. The Find_Point function can generate
a window redraw if it finds that that is necessary.

.SH DRAWING COMMANDS

XGraph is a graphing programme, in case it needs to be repeated. Its vocation is to make graphs of data, possibly after
arbitrary processing of that data. And to warrant identical (or at least highly similar) output to PostScript printing
devices. For this, it proposes a large (and ever growing) repertoire of different "plot" types. But it is always possible
that among this range of plots, \fIthe one\fP you are looking for is not available. No worry, you can program it yourself.
Not by hacking in the source code (although that is what got me here, hacking in the original code by David Harrison to
add errorbars, if I remember correctly). Instead, there is a small range of drawing commands available, that should allow
you to extend the builtin range of plots. The autoscaling
take into account whatever you draw with the pens. It is thus possible to disable e.g. XGraph's builtin lineplot, and
reprogram it with pens. For example because you prefer to draw each point and linesegment in a different colour...
The data drawn with pens is not subject to \fB*DATA_PROCESS*\fP commands and the like - after all, it is likely generated
by these commands. It is however subject to builtin axes transformations (log, pow), and to \fB*TRANSFORM_?*\fP commands.

All calls described below expect an active window. In case of error, they return -1.

The drawing commands make use of (window specific) pens, that function much like PostScript functions. Only, PostScript doesn't
know pens:

.TP
.B SelectPen[n]
Drawing with a pen begins with selecting one. This is done with the SelectPen[] routine. The \fBn\fP argument determines
which pen is to be selected. A non-existing pen is allocated - and all non-existing numbers before it too. Thus, \fBSelectPen[10]\fP
when no pens are defined as yet, will define pens 0 through 9. Selecting a pen sets the \fIcurrent pen\fP, that remains
current until another pen is selected. The maximum number of points "in" the pen is returned.
.TP
.B PenReset
.TP
.B PenReset[n]
Generally, you will want to "rewind" a pen at the start of each window redraw. Otherwise, it will draw more and more...
You can either reset the current pen, or reset another, defined pen (this command can not be used to define new pens).
When n<0, all currently defined pens of the active window are reset.
All other pen-related commands operate on the current pen only. The pen's current position (before the call) is returned.
NB: this command only rewinds. It does no de-allocation of memory associated with the pen, or the points in that pen.
This will generally not be a problem, since typically each pen will redraw the same things (or more, if new data becomes
available), or at least the same order of operations (segments, text, etc) on each window redraw.
When at a certain point the same type of operation is always performed, operation-specific memory efficiency is
attempted.
.TP
.B PenNumPoints[[n]]
Each pen "contains" a list of positions or points that should be drawn ("visited"). When adding points, new points
are allocated as needed. PenNumPoints[] allocates <n> points, and future expansions take place with increments
of <n> points. The maximum number of points currently in the pen is returned. When invoked without arguments, the
number of output items (drawing objects, colour commands, etc) currently stored in the pen is returned.
.TP
.B PenFloating[boolean]
When boolean is True, this pen is not included in the autoscaling, when active. Returns the previous setting.
.TP
.PP

Pens are drawn before, while and/or after
drawing the datasets. Pens are drawn in a fixed order, always the one with the lowest serial number first. But this order
is also determined by the way pens are grouped relative to the datasets. By default, all are drawn before the data is drawn.
If you want anything else, you will need to ask for it:

.TP
.B PenOverWrite[boolean]
This pen should be drawn after all data. Returns the previous value.
.TP
.B PenBeforeSet[setnr]
This set should be drawn just before dataset <setnr>. It is drawn even when the set itself is not drawn (for whatever reason).
This overrides the PenOverWrite setting. Pass setnr<0 to remove the special behaviour. Returns the previous setting.
.TP
.B PenAfterSet[setnr]
This set should be drawn just after dataset <setnr>. It is drawn even when the set itself is not drawn (for whatever reason).
This overrides the PenOverWrite setting. Pass setnr<0 to remove the special behaviour. Returns the previous setting.
NB: a pen can be drawn before \fBand\fP after a set. Don't ask me what that might be useful for....
.TP
.B PenSkip[[pen_nr[,boolean]]]
Whether to skip drawing a pen for the current or next redraw.
When no arguments are given, set the current pen to be skipped. When pen_nr<0,
set all pens to be skipped, or as indicated by the 2nd argument. When pen_nr
is a valid pen number, only modify that pen. Returns the previous setting when
a single pen is modified, or NaN when multiple pens are involved; -1 on error.
PenReset resets this flag.
.TP
.B PenSetLink[[set_nr]]
PenSetLink[[set_nr]]: link a pen to the set <set_nr> and/or return the set it is currently linked to.
Specify a negative number or NaN to unlink the pen.
Linked pens are drawn only when the set they're linked to is drawn
(and they're not being skipped)
.TP
.B PenDrawNow
Draw the pen now. To be used with care. It ignores the PenSkip setting, so that can be used to prevent drawing
the pen twice. Since processing (except for \fB*DRAW_AFTER*\fP when $Really_DRAW_AFTER==1) is completed before 
drawing, the result is that the pen is drawn before all other pens. The pen number is returned.
.TP
.PP

Each position (point) can have its own attributes: linestyle, linewidth and colour
(of the segment before that point); marker style and marker size. Setting an attribute, is sticky: the new
value remains in effect for following points (like in PostScript), until it is changed again. Changing an attribute has the
effect that all buffered line segments are drawn.

.TP
.B PenLineStyleWidth[style,width]
Determines the linestyle and width (both are initially 0). The conventions applying to dataset line style and width
apply here too. Returns 1 on success, -1 on error.
.TP
.B PenColour[colour]
Define the colour in which the linesegments from this point onwards are drawn. This can be a number referring to a predefined
attribute colour; a pointer containing a colourname or a 3-element doubles (intensities) or integer (8bit colour) array.
It can thus be the result from a call to SetColour[] or
SetHighlightColour[]. Returns 1 on success, -1 on error, and 0 when no action has been taken (pen was already in this
colour).
.TP
.B PenFillColour[colour]
Using the same conventions, this routine determines the colour in which filled forms are filled. These forms
are outlined in the normal PenColour. Returns 1 on success, -1 on error, and 0 when no action has been taken (pen was already in this
colour).
.TP
.B PenHighlightColour[boolean[,colour]]
The first argument determines whether the pen is to be highlighted. The optional second argument determines the colour. When\
not given, the highlighting colour is not changed. Else, the same conventions apply as for PenColour[]. In addition, the
global highlighting colour is restored when colour<0. Returns the previous highlighting (boolean) setting.
.TP
.B PenHighlightText[boolean]
Whether or not text drawn by the current pen should be highlighted with the colour set with with PenHighlightColour.
.TP
.B PenMark[[style,size]]
Puts a mark at the current position, or deactivates the marking from the current point onwards.
The mark style is similar to the mark style conventions for DataSets, as is the mark size.
Markers are always drawn over the other pen elements (i.e. when the other pen elements have been drawn). Returns 1 on success.
.TP
.PP

At each position (point), a number of things can be done. The pen tip can come down there, it can draw a line segment to that point,
it can draw a rectangle there, or an ellipse. These points have co-ordinates in the same range as the data - i.e.
world co-ordinates and not screen co-ordinates. You can also draw text, if you like.

.TP
.B PenLift
This command lifts the pen tip.
.TP
.B PenMoveTo[x,y[,direction]]
This command moves the pen tip to (x,y). E.g. \fBPenMoveTo[$DATA{0},$DATA{1}]\fP.  Returns the number of defined points in the pen.
The optional \fIdirection\fP argument allows to set the initial direction for the \fBPen....To-Ego\fP commands described
below.
.TP
.B PenLineTo[x,y]
Starting from the current position, this point puts down the pen tip (when not down already), and draws a
line segment in the current attributes to (x,y), which becomes the new current point.
When no current point exists, it makes (x,y) the current point. Returns the number of defined points in the pen.
.TP
.B PenMoveTo-Ego[length,direction[,radix]]
Moves the pen to the location at a discance \fIlength\fP in direction \fIdirection + current-direction\fP from the
current position. The \fIradix\fP argument defines the radix in which direction is specified - default 2PI.
This and the following command allow basic \fBTurtle\fP graphics. In other words, they allow to specify co-ordinates
and segments in an \fIego-centric\fP (or rather, pen-centric) frame of reference. Internally, these commands
immediately calculate the \fI(x,y)\fP co-ordinate pair the pen has to be moved to - only x, y and the new orientation
are stored.
.TP
.B PenLineTo-Ego[length,direction[,radix]]
Starting at the current position, put down the pen, and draw it over a distance \fIlength\fP in a direction \fIdirection\fP
with respect to the pen's current direction, where \fIdirection\fP is an angle with radix \fIradix\fP.
.TP
.B PenRectangle[x,y,w,h,centre?,fill?]
Adds point (x,y), which is part of a rectangle of width <w> and height <h>.
It can be the lowerleft corner (<centre?> is False, and w and h both positive). When
<centre?> is True, the rectangle is centered around (x,y). When <fill?> is true, the
rectangle is filled in the pen's current fill colour and outlined (fill?>0) or not (fill?< 0; in this case,
the pen's linewidth setting is ignored).
Returns the number of defined points in the pen.
.TP
.B PenEllipse[x,y,rx[,ry]]
Adds a point (x,y) that is the centre of an ellipse with radii <rx> and <ry>. When <ry> is
not specified, a circle with radius <rx> is drawn. Returns the number of defined points in the pen.
NB: suppose you have logarithmic axes. This will of course asymmetrically affect the ellipse
radii: it will become some sort of strange egg. To approximate the egg, XGraph determines the
ellipse's (deformed) bounding rectangle. It then draws an ellipse inside that box. This has
the advantage of being simple, and that an ellipse remains an ellipse (if you really want that
egg, draw it point for point using PenLineTo). If a marker is to be drawn, however, it is
drawn at the true, transformed (x,y). The same mechanism applies to PenRectangles.
.TP
.B PenPolygon[&X, &Y, fill?]
Draws or fills a polygon. Colour, (out)line style, width etc. are as described for PenRectangle[].
\fBX\fP and \fBY\fP are arrays with the lists of X and Y co-ordinates.
The smallest of the two determines the number of points on the polygon.
Polygons are closed if necessary. The behaviour for non-closed polygons depends on
the output device: in X, the outline is drawn with the XDrawLines() function, which does not close the
outline; therefore, an additional call is made to close the outline if necessary.
The fill, drawn with a "fill polygon" function, is closed, however. PostScript draws the
outline, closing it as necessary, and filling it if requested. Polygons can not be marked (which point
would have to be marked?).
NB: polygons can be used to implement 3d graphics. An example of this can be found in the example file
PenTest.xg .
.TP
.B PenText[x,y,`string[,justx[,justy[,[fnt,]&dim]]]]
.TP
.B PenText[x,y,&array[,justx[,justy[,[fnt,]&dim]]]]
.TP
.B PenText[x,y,xval[,yval[,justx[,justy[,[fnt,]&dim]]]]]
Draw some text at location (x,y). The text can be given as a stringpointer, but it is also possible to
pass a pointer to an array (&array; the second form), or to
give up to 2 values to be printed (<xval> and <yval>; the third form). In the last 2 cases, the numerical
values passed are printed in the format currently used for the axes. In the third case, if both
values are specified, PenText[] behaves like value marks: (xval,yval) is displayed.
If only xval is
given, or is yval==NaN, only xval is printed (without the parentheses). The justification arguments
justx and justy determine the justification of the string relative to (x,y). For both arguments, -1
means right/bottom justification, 0 centre, and 1 left/top ("normal") justification. Default is centre/centre
(0,0). \fBNB\fP: the PostScript code currently considers the characters' baseline to be their "bottom". Thus,
drawing bottom aligned with respect to a horizontal line will align cause all descenders to descend under
that line.
A choice can be made from the 4 different fonts available in XGraph through the optional <fnt> argument.
By default, fnt=0 is assumed, which corresponds to the axes font. Other options are fnt=1: title font;
fnt=2: axis label font (used for xname/yname); fnt=3: legend font. However, a custom specified font
can also be used: in that case, <fnt> must be a pointer to a variable initialised by \fBCustomFont\fP.
Finally, if given, the dim argument (either after the justy argument, of after the fnt argument) must
be a pointer to a doubles array. In it are stored the dimensions
of the string (width,height). This means
that the dimension (which is given in "world co-ordinates") depends on the size of the output device (X11
window, PostScript graph,...), and the axes' ranges (the world co-ordinate ranges). This means that
autoscaling is difficult. See the discussion under \fBFitBounds[]\fP.
Text is drawn as (one of) the last operation(s) in the drawing of stored pen commands; it thus overwrites
earlier operations performed with the same pen.
.TP
.B PenTextBox[x,y,expr[,justx[,justy[,[fnt,]&dim]]],fill?]
Draws the text specified by \fIexpr\fP (following the conventions described for \fBPenText\fP) inside a box.
The (compulsory) \fIfill\fP argument follows the conventions described for \fBPenRectangle\fP.
This command allows a more precise default placement of the box in which text is to be drawn: it is hand-tuned
to xgraph's peculiarities in PostScript string placement. The box is also drawn just before the text string,
which is itself always drawn over earlier operations. NB: the screen display is not always perfectly veridical
and representative of the printed version (which itself should be correct!).
The alternative is to determine the text's dimensions
with the \fIdim\fP argument, and then to find the co-ordinates where to draw a box. (Even if this rectangle
command comes (immediately) after the text command, the text will appear over the rectangle.) This
has the advantage of absolute liberty, at the cost of somewhat more work....
.TP
.B PenTextOutside[[flag]]
Marks text (and following text!) as drawable outside the data-window, the part of the plot "within" the axes-box,
that shows the data.
Normally (without calling this routine, or <flag>=False), this window is determined in such a manner that the
text drawn with pens is always contained within it, no matter where it is placed - unless the pen used to
draw the text is floating. When the text-outside option is set, the window will not be adapted to accommodate
the text, but will instead be adapted to only ensure that the text will fit inside the image plane defined
in the hardcopy dialog. This is analog to the \fB-mindlegend\fP option, but functions independently. As of this
writing (2001-07-24), this is an initial implementation. Note that here, as with other functionalities,
the result may differ on screen from the PostScript printout because of XGraph's non-perfect wysiwigness.
This functionality can be required if one wants to draw additional axes using the pen module.
.TP
.B CustomFont[&store, `xfont, `PSfont, PSsize[, PSreencode][, `alt-xfont] ]
Not a Pen routine per se, but currently only used for drawing text with Pens. This routine initialises
an internal structure with a CustomFont - see e.g. \fBVAL_CAT_X_FONT\fP. A custom font is specified
as a screen fontname (xfont, an X11 font specifier, with an optional alternative screen font for use
when the primary font is not available), and a PostScript fontname/size pair (a string and a scalar).
If the PSfont is not a text (but a symbol) font, set <PSreencode> to 0 (it defaults to 1).
A reference to this internal structure is attached to the <store> variable: this must be a scalar.
Not that there is currently no possibility (nor a need!) to "do something" with the settings of that
internal structure, other than modifying them via another call to \fBCustomFont\fP.
CustomFont returns the pointer to <store> upon success.
.TP
.PP

As of this writing, line segments are buffered (as mentioned above). The other commands are not. This
means that if you draw, say, lines and rectangles with the same pen, the result depends on the use
of attributes. If these don't change, the line will be drawn over the rectangles. If they do change,
e.g. because you outline the rectangles with another colour, the buffered linesegments are drawn first,
and than the attributes are changed and the rectangle is drawn. The result is that the rectangles partly
overwrite the linesegments (to their left), while being themselves partly overwritten by the segments
(to their right). If you don't want this, use different pens - you can have as many as you (or rather
your computer :)) like. Also note that the result of reusing a pen during a single redraw (with PenDrawNow) 
depends on whether autoscaling is active or not.
.PP

.SH RESOURCE OPTIONS
Some options can (only) be specified in the X defaults file.  Some
options are described below; for a more complete overview, see the
supplied
.B XGraph.ad
file (probably in
.B /usr/lib/X11/app-defaults
or similar).
Scanning for resource options can be done with 3 levels of complexity, controlled through the X11 resource
\fBXG-GetDefaults\fP. When this option is 0, xgraph only scans for the strict mininum number of options. When it is 1,
xgraph will scan for all known options, but using only the standard X11 mechanism. When it is 2,
when reading a resource option, xgraph first checks
the environment for a variable with the given name: if it exists,
its value is used. If not, it looks for a file named after the option, in the "display directory" ($HOME/.Preferences/.xgraph
or $HOME/Library/xgraph), and uses its contents. The X11 resource option is used as a last resort.
So, for a resource option
.I Name,
xgraph will look for: \fIName="string1"\fP
or it will store the contents of \fI$HOME/.Preferences/.xgraph/Name\fP into \fIstring2\fP
or it will look for \fIXGraph*Name:"string3"\fP
.fi
and use \fIstring1\fP, \fIstring2\fP or \fIstring3\fP in that order of preference.
\fBXG-GetDefaults\fP itself is always read with the full complexity.
.TP
.B <digit>.Colour
Specifies the colour for a data set.  Eight independent colours can
be specified.  Thus,  the digit should be between '0' and '7'.
If there are more than eight data sets,  the colours
will repeat but with a new line style (see below).
.TP
.B <digit>.Style
Specifies the line style for a data set.  A sixteen-bit integer
specifies the sixteen-bit pattern used for the line style.
Eight independent line styles can be specified.  Thus,  the
digit should be between '0' and '7'.  If there are more
than eight data sets,  these styles will be reused.  On colour
workstations,  one line style is used for each of eight colours.
Thus,  64 unique data sets can be displayed.
.TP
.B AllowFractionPrinting
When set, the routine for printing floating point numbers prints a fraction (a/b, with a and b integer) instead
of a decimal notation, when the former takes less place. Finding the fraction does take some time!
.TP
.B AscanfCheckEvent
Interval at which the
.I fascanf()
function routines check for and handle
.I X11
events.
.TP
.B Ascanf_Lazy_Address_Protection
The ascanf "language" defines operations with pointers to its variables and functions. As described elsewhere, these
pointers are values as all others, i.e. double floating point variables. This is true on the level of the scripting
language (a function that doesn't accept pointers will "see" the fl.point value), but of course also internally. Usually,
passing around pointers as doubles does not pose particular problems, but there is a (remote?) possibility that a calculation
yields a fl.point value which the internal pointer-parsing routine will mistake for a pointer because it has the required
properties. If that happens, chances are high that one of the additional checks in that routine will attempt to access
a memory location which is invalid or otherwise off-limits. This will typically generate a trap that would crash the programme
right there. To prevent this from happening, a dictionary of valid internal addresses is maintained. Each time you pass a pointer
(or string) to an ascanf routine, the internal pointer parser will attempt to look up the parsed address for validation as
referencing an existing object. Since you can in principle only obtain an 'ascanf pointer' through the internal pointer
encapsulation routine (which maintains the dictionary), this provides perfect protection at little cost.
As a compile-time option, one can also opt to activate this older mechanism, which is either much slower (and equally perfect),
or somewhat faster (though one has to verify calculation results should traps occur). It is this older mechanism that can 
be tuned at runtime through \fIAscanf_Lazy_Address_Protection\fP:
To avoid this, a trap handler has been installed which detects this sort of event, and permits continuation
of the script (and XGraph): the pointer parsing routine will return NULL, and if all other routines properly check their
pointers, nothing bad will happen.
This protection mechanism has a cost, though: it is SLOW. It slows down the parsing routine by at least a factor 16, sometimes
much more. This is because the \fIsigsetjmp(3)\fP routine is really expensive. For perfect protection, it has to be called
each time the parsing routine is invoked, to ensure that a proper "escape" jump point is set. If it is not called every time,
chances are that the corresponding \fIsiglongjump\fP (executed when a trap occurs) still goes to the right place, but the context
(local variables) is no longer correct. It is impossible to predict what exactly will be the case, but a potential effect is
that calculation results are invalid.
In the default configuration, the protection mechanism is installed anew for each high-level invocation of an ascanf entry function.
If this is not enough (i.e. the programme crashes), the resource/environmental variable \fBAscanf_Lazy_Address_Protection\fP can
be set to \fIFalse\fP or \fIOff\fP or \fI0\fP. This ought to be done also when \fIinvalid pointer\fP or 
\fIinvalid address\fP warnings are detected, just to compare the calculation results.
Set this variable to \fB2\fP in order to bail out off the current toplevel expression. This is more drastic than failing on the
current operation, but has the advantage that it has as few unpredictable side-effects as updating the jump point on each
invocation of the address parser (\fIAscanf_Lazy_Address_Protection==0\fP), while it costs almost nothing. (There are of course
side-effects of jumping out of a \fBverbose[...]\fP expression: the most evident ones are managed properly.)
.TP
.B BackingStore
Flag that activates the Backing Store (Always) and Save Under X11 options (requested at the creation of new windows,
not necessarily honoured (or meaningfull) by (on) all X servers: see \fBXCreateWindow(3x)\fP).
.TP
.B DisplayWidthMM-<scrnnr>
.TP
.B DisplayHeightMM-<scrnnr>
Overrides the X-server's idea about the actual dimensions (in mm) of screen <scrnnr> on the current display.
These variables are read at startup, and (as most other resource values), when the \fB-xrm\fP command line
option is issued.
.TP
.B DisplayXRes-<scrnnr>
.TP
.B DisplayYRes-<scrnnr>
Overrides the X-server's definition about the actual resolutions (X and Y, in DPI) of screen <scrnnr> on the current display.
.TP
.B X11-Greek-Template
Specifies a template string to be used for determining which greek font goes with which "regular" font. Defaults
to '-adobe-symbol-medium-r-normal--%d-%d-%d-%d-p-0-*-*' (the %d fields are substituded by the regular font's
pixelsize, pointsize, x-resolution and y-resolution, respectively). For example, when your ghostscript fonts are declared
to your X11 or font server, you can substitute 'urw' for 'adobe'. Note that this resource only has effect for
the screen display. It does in no way affect the functionally corresponding font used for PostScript printing...
.TP
.B PS-Greek-Font
Specifies which font is to be used for greek text, in PostScript dumps. Defaults to Symbol.
.TP
.B GridColor
.TP
.B GridSize
Width,  in pixels,  of normal grid lines.
.TP
.B GridStyle
Line style pattern of normal grid lines. The pattern is specified as a sequence (string) of bytes; each
element specifies the bit-pattern of max. 15 pixels to be turned on in the first half of a line segment of max.
30 pixels long. Thus, style "f" specifies 15 pixels on, 15 pixels off; "1" specifies 1 pixel on, 1 off; etc.
The style "0" is illegal (in X) and thus interpreted as a shorthand for a solid line.
.TP
.B HighlightColor
Colour used for highlighting.
.TP
.B LegendType
Selects the default legendtype; 0 or 1.
.TP
.B MarkFont
Font used for markers. Presently only used under HPUX X11 server 11.4,
which somehow doesn't display the builtin markers correctly. Two
fonts
.I (spc08x08e.snf
and
.I spc12x12e.snf)
are included. This functionality is a remnant from the time that xgraph was not yet able to
draw symbol markers on screen that are identical to those in PostScript dumps. It \fImay\fP
be slightly faster in some circumstances (lots of markers over a slow net connection?).
.TP
.B MinButtonContrast
When the luminance-difference between zeroPixel and gridPixel is larger than this
value, these colours are used in the buttons in the graph windows. Specified on
a range of [0,65535]; defaults to 65535/3.
.TP
.B MindLegend
See the \fB-mindlegend[0|1]\fP commandline argument.
.TP
.B MonoChrome
Set monochrome mode (see \fB-monochrome\fP).
.TP
.B NoButtons
Controls whether or not XGraph initially shows the Close, HardCopy, Settings, etc. buttons.
Defaults to False
.TP
.B NoLegend
Whether to not draw the legendbox, or to do draw it. Defaults to False.
.TP
.B OverlapLegendTune
Normally, xgraph does a decent job at estimating the printing-width
of PostScript strings, especially when instructed to use the X11
font width information. It turns out to be difficult to estimate the
width of the overlap string (see
.B -show_overlap
above): this string is usually taken too wide. This resource option
specifies a tuning factor which - multiplied by an internal border-padding
constant - is subtracted from the estimated width. It defaults to -0.5 .
This might evolve in a general PS-width tuning factor in a later release.
.TP
.B Progress_ThresholdTime
Sets a minimal time (in seconds) to elapse between two progress report indications when reading a file
or evaluating a PARAM_FUNCTIONS expression. File reading progress is per 10%, or whenever a
\fB*FILE*\fP command is encountered (the only criterium when reading from a compressed file). Defaults to 0.
.TP
.B psFontWidtEstimator
Sets the default value for the \fB-ps_fest\fP option.
.TP
.B gsTextWidths
Sets the default value for the \fB-gs_twidth\fP option.
.TP
.B psLeftMargin
.TP
.B psBottomMargin
Set the default values for the \fB-ps_offset\fP option.
.TP
.B WindowAspect_Precision
Controls the precision with which the window's aspect is matched against the
requested aspect. Less precise matching (set to e.g. 0.05 to accept everything between
0.95 and 1.05 as aspect 1) can reduce the number of iterations required. Note that
a high precision does not guarantee a perfect match - the maximum number of iterations
is fixed to 50.
.TP
.B WM_Titlebar_Height
Height, in pixels, of the window manager's titlebar. Will depend a.o. on the font used. Used in several
instances to determine the "true" position of the "decorated" window.
.TP
.B X_psMarkers
Selects the marker-set: True) use the builtin PostScript markers (at the cost of some
extra drawing time). False) use markFont or pixmaps, depending on the display (see under the
.B MarkFont
resource) (default).
.TP
.B xtbBaseColour
The xtb toolkit used by XGraph will by default use a greenish colour scheme, or a gray one if
\fBxtbGray\fP is set. In all cases, it uses 4 intensities of this colour, plus black and white.
The \fBxtbBaseColour\fP resource variable specifies the standard background colour to be used
in the default (non-gray) mode. Try \fI#abcdef\fP for a nice "electric blue".
.TP
.B xtbGray
A flag that selects a gray scheme for the toolbox windows and buttons that are used for the dialogs.
By default, a greenish scheme is used, or the colour specified via \fBxtbBaseColour\fP.
.TP
.B ZeroColor
.TP
.B ZeroSize
Width,  in pixels,  of the zero grid line.
.TP
.B ZeroStyle
Line style pattern of the zero grid line.
.TP

.SH COMMAND KEYS - AN OVERVIEW
.IR xgraph
responds to various keys typed into its windows. In most
cases these commands apply to the target window only. Keys without a
specific function are collected in a read buffer. Keys tagged with
a
.B *
or
.B #
below try to read a number from this buffer, to be interpreted as the
number of times to apply their specific function (tagged below with #). Entering 0 is allowed: most
functions tagged with # will be performed 0 times. A few other, tagged with $, will be applied to all
windows. Entering a negative number instructs XGraph to perform the #-tagged functions -1 times the entered
number, during which any required modifier-keys do not have to be held. By default (i.e. when entering a
number > 1 ), processing of the command continues only as long as you do hold down all keys forming the
command. The mentioned buffer is cleared by the redraw command (\fB^R\fP) - i.e. the next number "read" will
be \fB1\fP. The \fIEscape\fP key also clears the buffer.

Xgraph doesn't currently have a key for (de)iconifying windows, but instead relies on the window manager for
this. However, these WM functions can be applied to all windows by entering 0 as described above. NB: (de)
iconifying resets the read buffer. The titlebar shows the current contents of this buffer.

Below follows a list of the currently available command keys (loosely ordered alphabetically :)).

.TP
.B <Mod1>-= $
Switch between maintaining the legendbox withing view or not (see \fB-mindlegend[0|1]\fP).
.TP
.B <Mod1>-0 $
Select legend type \fB0\fP.
.TP
.B <Mod1>-1 $
Select legend type \fB1\fP.
.TP
.B <Mod1>-<Shift>-$ #
Add a set showing the average over the currently displayed sets. See under
\fB*AVERAGE*\fP.
The new set is taken from the end of the list of (empty) sets. All consecutively dynamically
added "average sets" are grouped together in a single file (\fInot\fP the sets created with a
\fB*AVERAGE*\fP
command!). The fileName and Y-axis-label (YUnits) of each averaged set contain the respective values
of all sets included. The title is constructed as the per-character average of the included titles.

When the
.B Control
key is also pressed, the default label
.I (Average of sets ....)
is shown in a text-edit-field, allowing it to be altered.
.TP
.B <Mod1>-<Shift>-% #
Similar to the previous command, except that the results of an eventual set of \fB*DATA_PROCESS*\fP transformations
(and everything before)
is used, instead of the raw data. An average set that is created with this command has its \fBraw\fP parameter
set, that excludes it from \fB*DATA_PROCESS*\fPing. This can be changed in the Settings dialog. Note that it is
not possible to perform this kind of averaging with the \fB*AVERAGE*\fP file-based command. To distinguish it from
its "raw" compagnion, the default setname has \fI (tr.)\fP appended to it.
.TP
.B <Mod1>-<Shift>-^ #
Similar to \fB<Mod1>-<Shift>-$\fP, but only Y-averages (cf. \fB*AVERAGE* Y ...\fP).
.TP
.B <Mod1>-<Shift>-& #
Similar to \fB<Mod1>-<Shift>-^\fP, using transformed data.
.TP
.B <Mod1>-<Shift>-* #
Similar to \fB<Mod1>-<Shift>-^\fP, but including interpolated (X,Y,E) values in sets which don't contain a given X.
.TP
.B <Mod1>-<Shift>-( #
Similar to \fB<Mod1>-<Shift>-*\fP, using transformed data.
.TP
.B <Mod1>-<Shift>-) #
This determines the gravity-point \fB(<x>,<y>)\fP of the displayed sets, and the standard deviation \fB<sx>,<sy>\fP in the X and Y
co-ordinates. This defines an ellipse with centre \fB(<x>,<y>)\fP, and radii \fB(1.5 <sx'>, 1.5 <sy'>)\fP (i.e. \fIdiameters\fP
\fB(3 <sx'>, 3 <sy'>)\fP). This ellipse is skewed (rotated) over an angle \fBa\fP, which is calculated as the angle of the
major axis resulting from a \fIPCA\fP on the covariance matrix "centered" around \fB(<x>,<y>)\fP. <sx'> and <sy'> are then
calculated as the standard deviations in the datapoints rotated over \fBa\fP around \fB(<x>,<y>)\fP.
.TP
.B <Mod1>-<Shift>-O #
Similar to \fB<Mod1>-<Shift>-)\fP, using transformed data.
.TP
.B [<Mod1>[<Shift>]]-Delete
The \fBDelete\fP key sets the internal "discard invisible" flag. When this flag is set, an immediate redraw is generated
that causes all points in the currently drawn sets that fall outside of the plotting region to be discarded.
This is a window-specific discard, unlike the other commands that selectively remove datapoints from selected sets.
Typing \fB<Mod1>-Delete\fP does the corresponding undiscard: for all sets currently drawn, points discarded by \fBDelete\fP
are restored, unless the \fBShift\fP key is also held. In the latter case, only the flag is unset, and no points are
restored. In both cases, a redraw is generated: if autoscaling is set, this will cause the entire set(s) to be (re)displayed.
Points discarded with this option are \fInever\fP dumped to XGraph dumps, unless they have previously been undiscarded.
This "discard invisible" is in a way complementary to the "discard in a box" functionality accesable by the combination 
\fB<Mod1>-d\fP \fB<Shift>-<Mod1>-Button1dragging\fP.
.TP
.B *
Toggles the \fBAlwaysDrawHighlighted\fP option. When set, all highlighted sets are always drawn - this makes
it possible to cycle through the collection of sets, comparing each with one (or a selection of) particular set(s).
Currently, the only way to set this global option is interactively (by typing a \fB*f\P in any graph window); the
only way to check whether it is set is to highlight some set(s)...
.TP
.B <Space>
Stops drawing in the current window. Also stops the reading/processing of a file being included.
.TP
.B ^A
Display all sets. Typing
.B ^A
once more restores the previous selection.
.TP
.B <Mod1>-a *
Sets the aspect ratio of the plotting-area. If no number has been entered before
the command is given, an aspect-ratio of 1 is assumed. By default, the maximal windowsize with
the required aspect will be searched for (window is maximised before the search starts).
When the number is negative, the current windowsizes
are used as a starting point; in this case, hitting
.B <Mod1>-a
once more restores the previous window-size.
The "resized state" is indicated by an
asterisk behind the aspect-ratio indication in the window's titlebar. If the "argument"
is an '=', the aspect is set automatically as close as possible to the current axes' aspect
ratio. This is the "window-resizing" homologue of the \fB-aspect\fP option (which adapts
the axes' ranges): this mode is indicated with a double asterisk.
.TP
.B ^C
Exit xgraph. Accidentily, non-target windows are affected too.
.TP
.B <Mod1>-<Shift>-^D
Delete the data of the currently displayed sets. Note that empty sets result; the slots occupied
are not released. This applies only to empty sets followed by (a) non-empty set(s). Empty sets at the
end of the range are put back into the "free pool". After deleting, an empty window results; issue a
set-selecting command to show (part of) the remaining sets. When the Settings Dialog is up, it is reformatted
when the discarding of sets with long names makes this possible. This may result in it disappearing from the screen
(a small bug that I do not yet care to trace down): close it by typing
.B ^D
in the window it is associated with, and reopen.
.TP
.B ^D
Close this window, or the Dialog box(es) associated with it. Dialog boxes are always closed first in last-first order.
.TP
.B ^I
Reset a number of settings to default/off: the
.I logX,Y; sqrtX,Y
and
.I polar
modes are switched off. The axis-labels and the legend are returned to their default positions.
.I raw_display
is turned on (i.e. transformations disabled). The window is redrawn. This feature is handy when
xgraph was started with "incompatible" options and data; it doesn't require the Settings Dialog
to be opened.
.TP
.B <Mod1>-L
Same as clicking in the label button with the \fBShift\fPkey depressed.
.TP
.B ^N
Restart. If the
.B XGRAPHCOMMAND
env. variable is set, its contents are passed to the
.I system(2)
call to start a new process. Otherwise, xgraph attempts to collect the argument-list reflecting the current window-state,
and execute itself like that. If all fails, the original arguments passed to the current process
are passed to the
.I execv(2)
call, which will overlay the current process. In the latter case,
.B xgraph
never exits upon failure to start a new process; in the former, failure cannot always be
detected. Also, in this case, xgraph stores an argument-list reflecting the state of its current
window in the
.B XGRAPH_ARGUMENTS
env. variable. This variable is read and parsed after parsing of arguments given on the commandline and in
all specified datafiles (it is intended to override those).

A restart can also be initiated by sending a SIGUSR2 to an xgraph process (e.g. from
within a datageneration programme).
.TP
.B ^P $
Hitting it once cause xgraph to resize the window so that it matches the currently requested
print dimensions on screen. This of course depends on the size-information supplied by the X server,
and does not take monitor-setup into account. Hitting it once more restores the previous windowsize.
The "resized state" is indicated by an
asterisk behind the aspect-ratio indication in the window's titlebar.
.TP
.B ^S
Swap drawn sets with hidden sets.
.TP
.B ^$
Popup a menu listing the contents of the statistics and angular statistics bins used by
the routines SS_Add.. and SAS_Add... Labels defined with \fB*ASS_NAME*\fP resp. \fB*ASAS_NAME*\fP
statements will show. NB: statsbin variables (as created with \fB$SS_StatsBin\fP and \fB$SAS_StatsBin\fP
are \fInot\fP included in this list!
.TP
.B ^/
Popup a menu listing the currently defined and/or changeable variables, and the currently defined
procedures. Hold down the \fBMod1\fP key to include information about assignments and reads.
In the popup menu, hitting 'h' will centre the window horizontally, 'v' vertically.
.TP
.B ?
Show all available functions and variables in a popup menu.
Hold down the \fBMod1\fP key to flush the cached menu, and rebuild
(refresh) it (to show uptodate information about variables). Clicking on an entry will copy the function's
(or variable's) name to the clipboard and close the menu (clicking always closes it). The menu can be
moved by depressing the \fBMod1\fP key with the pointer near the top or bottom of the screen (scrolling), or
by moving the mouse in the desired direction.  Hitting 'h' will centre the window horizontally, 'v' vertically.
.TP
.B C
Clear the collection of marked sets, and reset the number of the displayed set and file. Highlighting
is not affected.
.TP
.B <Mod1>-c
Clear the global statistics slots (see under \fB<Mod1>-i\fP).
.TP
.B D
Make a duplicate of the current window.
.TP
.B <Mod1>-d
Enter "delete mode". When activated, Mod1-clicking the left mousebutton will "select" the nearest point, which will
be discarded when the button is released with the Mod1 key still depressed.
" This will also create
" a "hole" in the set's trace, an artefact that can be remedied by exporting the data to a new instance
" of xgraph.
Mod1-clicking the middle mousebutton will delete upto and including the selected point, whereas
Mod1-clicking the right button will delete all points beyond and including the selected point. Deletion(s) can
be undone with the \fB<Mod1>-z\fP (last mouse-deleted point) and \fB<Mod1>-Z\fP (all mouse-deleted points in the 
selected set) commands. Holding down the \fBShift\fP key modifies the action of the middle and right buttons: in that
case, the "delete" flag associated with the points affected is reversed. The same key also modifies the left button's
behaviour: shift-mod1-button1-dragging will show a rubber box. Releasing the button with the shift and mod1 modifiers
still depressed will cause the points of all drawn sets that are within the designed box to be discarded. This operation
can be undone (and redone) as long as there is no change in the displayed sets (cycling, discarding of other points).
In all cases, when the nearest point belongs to a User Label, this label is deleted.
Points can also be selectively (and reversibly, though not with \fB<Mod1>-z\fP) discarded with the \fBdiscard[<test>]\fP and
\fBDiscard[<return\-exp>, <test>, <start>, <end>[, <test>, <start>, <end>, ..]]\fP \fIfascanf()\fP processing functions.
.TP
.B f
Show/unshow the filenames or the Y-axis-labels in the legend box.
.TP
.B F
Open as many (tiled) windows as there are file-sets, displaying each file-set in its own window.
.TP
.B <Mod1>-<Shift>-B
.TP
.B <Mod1>-<Shift>-F
Toggles the "\fIBoxFilter\fP" mode, indicated by a "dot-in-a-box" cursor when active. In this mode, when a rectangular
range ("box") is selected with \fB<Mod1>-Button1\fP, the following actions are taken after release of the button. First,
a fascanf() variable is set, \fB$FilterBox= {lowX, lowY, highX, highY}\fP, indicating the range of X and Y co-ordinates
selected (relative to the window's current axes; \fBNOT\fP the upper-left and lower-right corners of the box!). Next,
a dialog requesting a "boxfilter filename" is popped up (at this moment, the operation can be cancelled). The specified
file is then read and processed as usual. Afterwards, the \fB*BOX_FILTER*\fP statement (if any) is evaluated for all
points in all currently drawn sets that fall within the specified "box". All pertinent fascanf variables (\fB$CurrentSet\fP,
\fB$Counter\fP, \fB$numPoints\fP) have their appropiate values. The *BOX_FILTER* statement is (thus) a sort of *EVAL*
evaluated for specific datapoints, and can be used to e.g. change values of those points (example: if the current X axis
shows point index (i.e. $Counter), the box's X-range defines a range of points to operate on). The statement itself is
*not* window-specific as its intended use is to apply some filter to (raw) datavalues (e.g. using DataVal[set,col,index,newvalue]).
A filtering operation can be undone with \fB<Mod1>-z\fP; to this end, all points treated (all columns!) are saved to a
temporary file.
Note that there is a shortcut for applying the boxfilter to a single point of a single set. When boxfilter mode is activated,
use \fB<Mod1>-Button3\fP (instead of Button1) to select the nearest point. This applies the filter directly (and guaranteed
only) to this particular point. (But it is sometimes easier/necessary to "catch" a point by using the "rectangular lasso" 
method..)
If there is a \fB*BOX_FILTER_FINISH*\fP statement, it is evaluated afterwards. This allows to use the first "pass" to e.g. calculate
the gravity point of the contained datapoints, and then to use this information in the 2nd pass.
.TP
.B <Mod1>-f
Opens a request dialog for a filename (or pipe) to be included.
.TP
.B g $
Hide/unhide the buttons. Useful if they cover a lot of datapoints. Hiding results in
a redraw; unhiding generally does not.
.TP
.B G
Open as many (tiled) windows as there are groups, displaying each group in its own window.
.TP
.B h
Highlight the currently displayed sets.
.TP
.B H
Display all sets which are highlighted.
.TP
.B <Mod1>-h
Unhighlight the displayed sets.
.TP
.B I
Show a popup window displaying the global statistics (see under \fB<Mod1>-i\fP) and other information relative to what
is currently being displayed.
NB: clicking on the bounding box line puts a \fB-bbox llx,lly,urx,ury\fP command line argument on the clipboard instead
of the line actually shown.
.TP
.B i
Show the info window.
.TP
.B <Mod1>-i
Add the X, Y, error, low-error, high-error and possibly overlap statistics to the
"global" statistics slots, that can be queried with the \fBI\fP command.
.TP
.B l|L
Layer the windows, without altering their size or position.
.B l
will layer ("stack") with the youngest/newest window on top;
.B L
will stack with the oldest on top.
.TP
.B <cursor left> (XK_Left) #      (CycleSet[-1])
Cycle down the number of the displayed set (i.e. display a set with a setnumber 1
lower than the current setnumber).
.TP
.B Shift-<cursor left> (XK_Left) #      (CycleDrawnSets[-1])
decrements the setnumbers of the displayed sets. This allows cycling through datasets,
always displaying e.g. two sets at a certain distance (in setnumbers) from each other
(marked collection [3,8] will become [2,7]). A displayed set that shifts out of the
legal range (i.e. set 0 when cycling down) "reappears" at the other end of the range: the
collection wraps around. This can result in hard-to-interpret graphs, e.g. when every 3rd
set has something in common with the set 2 before, and the total number of sets is not
a multiple of 3. In this case, a set that reappears "at the other side" will not have
this common property. Therefore, sets reappear as ghosts: they're not shown, (and thus
disappear one by one) until all sets have disappeared. Then, all "ghosts" are revealed,
and the initial selection is shown.

Holding the \fBControl\fP key will add info about the newly displayed sets to the
global statistics slots.
.TP
.B <cursor right> (XK_Right) #      (CycleSet[1])
Cycle up the number of the displayed set. This always starts at the first set (# 0),
regardless of the selection made with
.I -plot_only_set!
.TP
.B Shift-<cursor right> (XK_Right) #    (CycleDrawnSets[1])
increments the setnumbers of the displayed sets, i.e. a displayed set of {1,4,6} becomes
{2,5,7}.

Holding the \fBControl\fP key will add info about the newly displayed sets to the
global statistics slots.
.TP
.B Mod1-<cursor left> (XK_Left) #
.TP
.B Mod1-<cursor right> (XK_Right) #
Idem, except that this cycles the highlighted sets. Useful for successively focussing on
subsequent sets, appreciating them in the context of a larger collection.

Holding the \fBControl\fP key will add info about the newly displayed sets to the
global statistics slots.
.TP
.B <cursor up> #                    (CycleFile[1])
Cycle up the number of the displayed fileset (i.e. display the sets belonging
to a file <current-file-number + 1> )
.TP
.B <cursor down> #                  (CycleFile[-1])
Cycle down the number of the displayed fileset.
.TP
.B Shift-<cursor up> #              (CycleGroup[1])
Cycle up the number of the displayed group. A group is a collection of datasets that are shown
linked with a vertical line in the legend-box. Groups can be made with the 
.I Split
button in the Settings Dialog, or with the
*FILE*
command.
.TP
.B Shift-<cursor down> #            (CycleGroup[-1])
Cycle down the number of the displayed group.

With all these cursor actions, also holding down the
.I Control key
causes a popup window with the legends, statistics, etc (as when
.I control-clicking
on the legendbox) to appear. It disappears with the next keystroke (which doesn't
do anything otherwise).
.TP
.B <Shift|Mod1> Enter
Set the set, group and file pointers used by the cursor commands described above to
the first set displayed, respectively the group and file it belongs to. Depressing the
\fBMod1\fP key subsequently displays all the sets belonging to the selected file.
.TP
.B m
Mark the currently displayed set(s). Cumulative; current sets are added to the
current set of marked sets.
.TP
.B <Mod1>-l
Toggle the \fI add User Label\fP mode. See the description of the Label button above.
.TP
.B <Mod1>-m
Unmark the currently displayed set(s).
.TP
.B M
Draw (only) marked sets. With
.B Shift-<cursor left/right>
this selection of marked sets can be shifted cyclically over the whole collection
of sets.
.TP
.B O
Show/hide the overlap in the current window. Calculations based on raw data.
.TP
.B o
Show/hide the overlap in the current window. Calculations based on values shown in the window.
.TP
.B p
Toggle the marker-set: 1) using markFont or pixmaps (default) or 2) using the builtin
PostScript markers.
.TP
.B P
Open the hardcopy dialog box.
.TP
.B <Mod1>-p|P
Open a window to enter and evaluate a \fB*EVAL*\fP (was: *PARAM_NOW*) expression. The expression is remembered.
Use a \fBP\fP (Shift-Mod1-p) to evaluate the expression(s) in all currently open windows.
.TP
.B <Mod1>-q
Swap the "quick" mode. In this mode, the results of the last transformation(s) are used instead
of performing them at each redraw. Quick mode is temporarily switched of by the \fB<Mod1>-S\fP
rescaling command. When \fB-process_bounds\fP, auto rescaling can be performed satisfactorily
only with the \fB<Mod1>-S\fP command in "quick" mode. This mode can be selected or queried with the
fascanf function \fBQuickMode[[flag]]\fP; the fascanf variable \fB$ReCalculate\fP allows to
ignore it for the next first redraw. The \fB*DRAW_BEFORE*\fP and \fB*DRAW_AFTER*\fP commands are
not subject to this setting.
.TP
.B ^R
Redraw. Hold the \fBShift\fPkey to redraw in X11 synchronised mode: only the data are drawn in this
way - axes, legends, etc. not.
.TP
.B R $
Swap the setting of the window's
.I raw_display
variable (the
.B raw
button in the Settings Dialog), and redraw the window. Useful when zooming in a
window with e.g. a
.B *TRANSFORM_[XY]*
transformation.
.TP
.B <Mod1>[-<Shift>[-<Ctrl>]]-r
Trace the boundaries between the regions of attraction of the displayed points and UserLabels. The
nearest data-point or UserLabel of each
point \fIP\fP in the plottingwindow is compared to that of \fIP\fP's 8 nearest neighbours - if
there's a difference, \fIP\fP is supposed to be on such a boundary. If the \fB<Shift>\fP key is
held, those points are stored in a new set (by default called Bifurcations); else, they're only
shown temporarily. The name of the new set can be changed by holding the \fB<Ctrl>\fP key as well.
To make things simple, one can change the default up-down direction of calculation to left-right
by typing a \fB2\fP first. (This is implemented as two separate functions...)
When the points are stored in a dataset, the distance to the first found different point is stored
as the points' errors. By default these are not shown, but they could be visualised as intensities
by putting the bifurcation set in intensity mode.
.TP
.B S
Open/raise the settings dialog box.
.TP
.B <Mod1>-s
Auto-scale both axes once.
.TP
.B <Mod1>-S
Auto-scale both axes once, forcing "non-quick" mode (see \fB<Mod1>-q\fP).
The first character in the read buffer has effect: when \fIx\fP, only the X-axis is rescaled,
when \fIy\fP, only the Y-axis.
.TP
.B [<Control>-]t|T
Tile the windows on the screen. Xgraph tries to tile in an N*N fashion -- or
to stack vertically when the \fB<Control>\fPkey is pressed -- with all
windows completely on the screen. If this is not possible, it will put more
windows horizontally than vertically (screens are typically wider than high).
Tiling begins in the lower-right corner, so a gap might arise in the upper-left
corner; the window at lower right always ends up at the bottom of xgraph's
window-stack. Windows which are iconified or otherwise unmapped are not taken into
account.
.B t
will tile with youngest/newest window in the left-upper corner, and the oldest
window in the right-bottom corner.
.B T
will tile in the opposite way. Due to some ideosynchracy of the
.B X11
event handling (?), not all windows will always get a redraw event. (Typing
.B l
after
.B t
or
.B L
after
.B T
remedies this effect without changing anything).
.TP
.B [<Mod1>-]t
Pops up a dialog allowing any XGraph input to be entered (like the "TXT" function
of the Settings Dialog).
.TP
.B [<Mod1>-]T
Pops up the Process History dialog.
.TP
.B ^V
(Capital V!): pops up a window showing the current contents of the clipboard (i.e. X11
cutbuffer 0).
.TP
.B <Mod1>-x
Selects "cut-mode". <Mod1>-clicking the left mouse-button in this mode jumps to the nearest point, and
disconnects it from the preceeding point. This is all the action undertaken immediately. The "split" is stored
in export of the data as an XGraph dump, using \fB*SPLIT*\fP commands.
Depending on \fB-splits_disconnect\fP (stored in the file), these SPLIT commands will either cause pen-lifts
in the next invocation of the file (like the "immediate" effect), or will cause a new set to be started
at that point.
.TP
.B <Mod1>-z
Undoes (or redoes after undo) the last shift, split or delete of a datapoint (done by meta (mod1) clicking
the left mousebutton), the X or Y label, or the legendbox (the latter 3 are window-specific).
Holding the \fBShift\fPkey undoes all splits or deletes of datapoints (done by meta (mod1) clicking
the left mousebutton) from the last set from which a point was deleted/split. Undo always works on the last
operation - a new operation deletes the stored undo information. Redoing an undone deletion of a user label
is not possible.
.TP

.SH STRINGS AND THINGS
.IR xgraph
has limited string formatting capabilities. In (almost) all strings,
a '\\' can be used to switch from the default font used for displaying
that string to the corresponding symbol (default Adobe Symbol == greek) font. These symbol fonts
are based on the pointsize of the corresponding default font, and cannot
be specified. Currently, xgraph will first try to find a font matching the specification
'-adobe-symbol-medium-r-normal--%d-%d-%d-%d-p-0-*-*', or any alternative set via the
\fBGreek-Template\fP resource string (with %d replaced by respectively the
appropriate pixelsize, pointsize, x-resolution and y-resolution, or 0s for those values that could not
be parsed from the regular font string), which for many X11 servers with Type1 font
support will provide a scalable Symbol font. If this fails, the pattern '*-symbol*--%d-*' will
be tried, and finally the same pattern, but with a pointsize 1 unit bigger and then smaller. If all fails,
the corresponding default font will be used, or whatever font is stored in the remembered
fontbase for the screen.
(Note that a '\\' can be specified by \\\\ and by ESC\\, and that a "\\n" in the input followed by
a '\\n' (newline - or a "\\r" followed by a '\\r') are translated into a '\\n' resp. a '\\r'.)
In addition to this rudimentary font mechanism, extended characters can be specified as
.B \#xyz
which is substituted for a character with hexadecimal
.B ASCII
code
.B yz.
\fB#xn\fP and \fB#xr\fP are replaced by '\\n' and '\\r' respectively.
.PP

Xgraph uses a font-caching scheme. When first opening a window on a screen that has not
yet been "visited", it searches "best" fonts. This can take time, so the results of the
search are stored in a directory \fB$HOME/.Preferences/.xgraph/$DISPLAY\fP, with the filenames
indicating the type (label, legend, etc) of the font. This information can be copied into
other "$DISPLAY" directories: if a font is not found, the default best will be looked up,
and written back into the file. Otherwise, the information is not touched, so alternatives
can be stored in these files.

Placement of text is a problematic issue, at least as far as PostScript (and probably other
formats) hardcopies are concerned. For screen display, XGraph tries to make the best possible
use of the information provided by X11: string width and height, ascenders, descenders, etc.
This information is not a-priori available for PostScript. As related elsewhere in this document,
XGraph can thus scale the screen-font information to the resolution assumed in the PostScript
version. This works reasonably well when a good match is made between screen and PostScript fonts.
Additionnally, it is possible to use \fBghostscript\fP to determine the printing width of any
string. For the height, this would also be possible, but probably less desirable since there seems
to be no way to obtain information about ascenders, descenders, etc. However, a number of placement
issues can be left up to the PostScript interpreter: notably the various forms of alignment are
handled in PostScript code. This has the drawback that XGraph can only make educated guesses where
the string will actually appear. In a number of cases (e.g. PenTextBox), correct printouts have
therefore been priviledged above veridical wysiwig screen display.

In PostScript, fonts have a name and a size in points (attributes like bold are not attributes: a font is bold,
or italic, or both, or regular). Under X, a font with a given name has many attributes, among which
the size. However, there is a size in pixels, and a size in points, related via the resolution (in X and Y...).
Usually, for a 75DPI (the X,Y resolution) font, pixel and point size are equal. However, this may not
give a good wysiwig match between what is shown on the screen, and what comes out of the postscript
printer... To make that match, some experimenting should be done. That is, try a font with pixel size
'*' or 0, a point size of 10 times the PostScript font size, and a resolution adapted to your screen's resolution.
This is not necessarily the resolution reported by X itself: the optimal probably lies somewhere between
the values reported by X, and the values obtained by dividing the actual screen surface by the actual
resolution (in pixels). For example: my laptop's 14.1" panel is 28.5x21.6 cm large, for a resolution of
1024x768. This means approximately 91DPI. This value seems appropriate for the horizontal dimension, but
for the vertical, a value of 75DPI gives better results (although the text does look
somewhat flatter than in print).
X11 reports a different metric screen size (larger), and a lower resolution (75DPI). It is possible to set
these resolutions, once found, via a resource: \fBDisplayXRes-<screen>\fP and \fBDisplayYRes-<screen>\fP. These values,
or X11's defaults, can be specified in an X11 font specifier by passing \fIXDPI\fP and/or \fIYDPI\fP
instead of a numerical or wildcard resolution field.

A note about environmental variables. XGraph will look for certain settings through specific environmental varialbes,
and it will also recognise X11 resource variables that are specified via env. variables of the same name.
Additionally, the ascanf language provides the \fBgetenv[]\fP routine.
Traditionally under Unix and similar OSes, environmental variables are maintained by the shell in a special memory arena,
that is shared with a programme. On the wonderfully elegant OS that ran on the Amiga family of computers, such
variables also existed (they were actually maintained by a special device), but there were also disk-based variables.
Those are quite pratical, once you get used to them. Therefore, XGraph has an extension to the traditional Unix
functionality. When a variable is not found in the shell's environment, it will be looked for in a directory
\fI.env\fP, either in the current working directory, or in the user's home directory. Additionally, there is an override
mechanism: a disk-based variable _TERM will override the shell's TERM variable, but it will in turn be overridden
by a __TERM variable (disk or shell), and so forth.

.SH SIGNALS
Xgraph reacts to certain signals:
.TP
.B SIGCONT (kill -CONT <pid>)
Generates a redraw
.TP
.B SIGHUP, SIGINT
Kill the programme in an orderly fashion.
.TP
.B SIGUSR1 (kill -USR1 <pid>)
A panic option. Causes xgraph to dump all its windows to the XGraph filenames currently associated
with each window (with an appended .sigdump_<n> where <n> is an increasing number). Some extra text
at the end of each dump gives the windows' current titles, some guess as to what xgraph was doing,
and whether the window was the active window.
.TP
.B SIGUSR2
Generates a restart, similar to typing ^N into an xgraph window.
.TP
.B SIGALRM
This signal is not actually meant to be used externally. It is used internally to "terminate"
a wait during a (requested) pause. Thus, it can be used with caution to unblock a paused/sleeped
programme (when by mishap a very long pause was initiated), if a simple SIGCONT signal won't do.
.PP

.SH FILES
XGraph expects, and looks for, standard files in the \fB$HOME/.Preferences/.xgraph\fP directory. This directory
is created as needed. The following items can be found there:
.TP
.B $DISPLAY/
Fontnames are cached in directories, each with the name for a display connection that XGraph has been opened on. For a
new display\fIname\fP, XGraph will select "best" fonts according to some builtin criteria.
.TP
.B fft_wisdom
Contains information about performed Fast Fourier Transforms done with the FFTW libraries.
.TP
.B Xgraph.psMarkers
Optional file containing PostScript marker definitions. If the env.var \fBXG_PS_MARKSFILE\fP is set,
this file is read instead. If neither of these files are specified, or exist, an attempt is made
to read a default file. In a default installation, this is \fI/usr/local/lib/Xgraph.psMarkers\fP; this file
is (again, by default) a copy of the builtin marker definitions.
.TP
.B xg_init.xg
Startup file. In theory, any valid XGraph input file can be used for this, and any valid command may be issued.
This file is parsed after performing the builtin and X-resource-based default initialisations, but just before parsing
the commandline options. Options passed on the commandline thus override the settings in the init file. NB: options
set in subsequently read files (specified on the commandline, or from within other files) override the options set
on the commandline...
NB2: it is probably not a very good idea to put an \fB*INIT_BEGIN*\fP/\fB*INIT_END*\fP section in this file...
.PP

.SH CAVEAT - READ THIS!
This manpage is slightly adapted to introduce the new options and
facilities added by RJB. The list of options and format commands is
relatively complete; additions/modifications to the X-Resources have
not been included. Nor has the description of the programme been
brought up to date (it (the programme, that is) really has become a lot nicer ;-).
I did not feel like describing all the new buttons and fields in
the dialog boxes - I think they are rather self-explanatory. If not, try Control-Clicking
on it: that should open a help window. One
important bit of knowledge: the value of a numberfield in the dialog
can be de~/in~cremented using the
.I cursor down/up
keys (\fI cursor left/right\fP actually move the cursor in the text field).
This takes place at a fixed rate of 1, making it useful mainly
for counters. Focus is not changed, so you can set the focus on the
.I setNumber
field of the Settings Dialog, and then change buttonstates (settings)
of any sequence of datasets by clicking the mouse and hitting the cursor
keys. Oh, and the setNumbers below zero (-1 and -2, enter as X resp. Y) allow the
.B Y
respectively
.B X
labels to be edited! In addition, setNumbers -3 to -7 (enter as DA, DP, DB) allow specification of
run-time
.B *DATA_AFTER*
respectively
.B *DATA_PROCESS*
resp.
.B *DATA_BEFORE*
resp.
.B *TRANSFORM_Y*
resp.
.B *TRANSFORM_X*
expressions!
setNumber -8 (enter as PN) allows entry and direct evaluation of a
.B *EVAL*
expression. setNumber -9 (enter as RF) allows specification of a filename or pipe-command (starting with
a
.B |
as first token) to be read in. This is the run-time version of the
.B *READ_FILE*
command. With this option, one can "evaluate" commandline options at runtime, by entering
.B | echo "*ARGUMENTS* <optionstring>"
in the entry field. This can now be done also by entering \fB<optionstring>\fP when setNumber=\fBARG\fP.
More generally, the "prefix" \fB| echo\fP and the quotes can be omitted by using setNumber=\fBTXT\fP, which
stores the entered string in a temporary file, and includes that file. A bit confusing, all this? Click
on the [...] button next to the setNumber input field. This pops up a menu with all the different
special functions/values that can be accessed by entering just that right code into the field. Select one,
and wallah, it is all done 4 U.
.PP
There
is thus something of a \fBhelp-facility\fP;
.I Control-Clicking
with the mouse (clicking while holding the
.I Control
key) pops up a small help-window in many cases.
Control-Clicking
inside the title area of the plot will pop up a small (well,
depends on the
.I dialogFont)
showing the titles. This can be handy in case of
a small graph window, or large
.I titleFont.

The same applies to control-clicking inside the legend box. In this
case the co-ordinates of the box are shown too. Also, setnumbers, file-information
and the number of points visible out of the total per set are listed. Marked sets
are indicated, as are sets not visible in the current window/legend. If the Shift key
is depressed also, only the set of which the setName is under the cursor will be
shown in the popup window.

.I Control-Clicking
the \fB1st\fP mousebutton while zooming makes
.I xgraph
close the window that is being zoomed from. When the \fBmiddle\fP button is pressed, xgraph
enters "measurement" mode: in raw_display, it displays in the window's titlebar the first clicked point
(start), or the end point, including the distance (d=..) with the X and Y city block
distances between square brackets, the ratios endX/startX and endY/startY, and the
angle from start to end. The start point's coordinates are also shown next to it.
When no transformations are specified, xgraph draws a line connecting start and endpoints, including
an ellipse centered around the startpoint showing all points at equal distance. (Presently, this
only works correctly with a scaling of 1.) After releasing the mousebutton, a window pops up
summarising the measurement. Note that this measurement shows transformed values, regardless of what
the axes show (see under \fB-transform_axes\fP).

Control-clicking the 3rd (right) button moves the pointer to the closest datapoint of a
displayed set. If the controlkey is still pressed when the mousebutton is released, a label identifying
the point will be created, at that point. \fINote\fP that the label gives the coordinates of the point as shown,
i.e. not necessarily the point's "raw" coordinates. If (in addition) the \fBMeta\fPkey is held when releasing the mousebutton,
the entire set to which the point belongs is highlighted (toggle). Holding the \fBMeta\fP and \fBShift\fP keys and pressing the
3rd mousebutton causes a search for and warp to the nearest point at every mouse-move - releasing the mousebutton highlights
the currently "selected" set.
.PP
.I Shift-Clicking
has another effect: depending on which button is released,
the
.I legendbox (
.B 1
st b.);
.I Y unitname
(
.B 2
nd b.) or
.I X unitname
(
.B 3
rd b.) are
positioned with their upper left corner at the location of the pointer. The
.I Settings Dialog
allows to undo this.
.I Shift-Clicking
in an entry field in one of the dialog boxes allows the contents of that
field to be scrolled by horizontally moving the mouse.

When entered in raw mode, both point-labels and legend/X/Y positions retain their place relative to the other
data when a transformation is added/changed (i.e. their coordinates are mapped with the same functions).
.PP
.I Meta-Clicking
\fB1st\fP button: "selects" the nearest point, and allows it to be dragged (displaced) to a new position. This
option first activates \fBraw\fP mode, if necessary. The begin and end points of UserLabels can also be
dragged in this way. Note that UserLabels which have identical begin- and end-points (and thus have no
box around them) are moved like that; i.e. both points are moved at the same time. Hold down the \fBControl\fP
key to restrict the displacement to purely horizontal, vertical or diagonal (screen..!) movements. Hold
the \fBShift\fP key to move the whole, nearest set. When in addition the Caps are Locked, all other drawn sets
that belong to the same group are displaced together.
Displacing a point needs to be done in "raw" mode, thus,
XGraph puts itself in that mode (or, if you want to move a transformed point, first "validate" the transformation).
For labels, this is not necessary, so no redraw is generated. Note however that a label moved in non-raw mode
looses its "transform" flag: its co-ordinates are now fixed, and no longer subjected to whatever transformation.
In Delete mode, Meta-clicking the first button deletes the nearest point (labels are ignored in this case).

\fB2nd\fP button: measuring mode, similar to Control-Click-2nd button (but no window pops up). In Delete mode,
the nearest point is found, and all points to its left are deleted.

\fB3rd\fP button: selects the nearest point, and highlights the set it belongs to. Also holding the \fBShift\fP
key causes a reselection of the nearest point at every move of the pointer. In Delete mode,
the nearest point is found, and all points to its right are deleted.

\fB4th\fP button: corresponds to 'forward'/upwards scrolling of the mouse \fIwheel\fP on XFree86 style X servers. This moves
the cursor up 1 pixel on the screen, or 1 pixel to the right if the \fBControl\fP key is held.

\fB5th\fP button: corresponds to 'backward'/downwards scrolling of the mouse \fIwheel\fP on XFree86 style X servers. This moves
the cursor down 1 pixel on the screen, or 1 pixel to the left if the \fBControl\fP key is held.

.PP
When the variation in a graph's axis is much smaller than the average (the ones
that have a set of identical numbers written along their axes...), the average
is subtracted from all values before being shown. This should show the variation
along the axis. The corresponding label is printed as
.I (<Label> + <Average>)
or
.I (<Label> - <Average>)
instead of as
.I <Label>.
There is currently no way to deactivate this feature.
.PP
.I Inf
are plotted by substitution with the machine's
.I DBL_MAX.
Given a sufficiently large plotting range, a line to (Inf,non-Inf) can become
slanted.
.PP
.I NaN
values are skipped, hence a point with a NaN X or Y coordinate is not drawn, but treated
as if it were no part of the data.
.PP
Adaptation of the axes-ranges to runtime transformations is automatic only for the
builtin logarithmic transformation; the minimum will be set to the minimal positive
value if negative; also it will be extended if necessary to include the selected
.B log_zero_[xy]
value. Minimum and maximum of an axis-range are interchanged when a
.B *TRANSFORM_[XY]*
transformation makes this necessary (max must be larger than min ;-( ).
In other cases, the user will have to adapt the ranges himself, using the
.I Bounds, proc,
and
.I trax
fields/buttons of the Settings Dialog.

Example: for the following transformation;

.B *TRANSFORM_X* div[1,DATA[0]]

.B *TRANSFORM_Y* div[1,DATA[0]]

the min/max of both axes will be changed automatically. But at least one of the bounds must be
adapted by hand for the graph to be correct. NOTE: exchanging
the min and max of an axes-range normally doesn't work...

Usually,
.B xgraph
does a pretty decent job at reserving enough space for the numbers along the vertical axis (this is
done by repeatedly calling the axis-drawing routine until an optimum is found. Only the "optimal
solution" is shown). In some cases, xgraph gets things confused: resizing the window should remedy
this situation.
.PP
.B xgraph
allows a graph to be exported ("hardcopied") in several formats. Presently, it supports PostScript(tm)
as the only printing language (modules for
.I HPGL
and
.I IDraw
output are included in the distribution). The other
provided formats are
.IP 1)
.I generic SpreadSheet,
which basically exports one column of X-Values, and multiple columns of Y-values and E-values;
.IP 2)
.I Cricket,
which creates a similar dump readable by the Macintosh programme Cricket Graph (tm).
.IP 3)
.I XGraph
creates an executable file in xgraph's own format, which will (to the largest extent) recreate
the graph. For the dump to be executable, the
.B XGraph
script (note: the programme itself is called
.I xgraph)
must reside in the same directory as the programme
.B xgraph.
In this format, the last lines show the commandline (real, and as specified in the
.B XGRAPHCOMMAND
env. variable) that created the graph. Data-values are output in binary, or using a
.I sprintf (3)
format string that can be altered throught the Settings dialog or with the \fB*DPRINTF*\fP statement.
.IP 4)
.I Command
Which dumps the commandline to the specified file.

.B The window's titlebar
("normal" display) contains the following information: a \fBheader\fP consisting of the letters
\fIXG\fP (to identify XGraph) and three numbers describing the window's parentage, the aspect-ratio
of the drawing area, optionally the current output filename, the current first word of the X-axis label, the
current first word of the Y-axis label (as \fIY vs. X\fP), and the time (in seconds) required for the last
<n> redraws (with <n> usually 1, unless an animation has been interrupted).
.PP

It would be very nice to have
.TP
.B Nicer mouse(button) handling
e.g. by popping up a menu when clicking in a window, instead of having
to memorise all possible different combinations of buttons and modifiers.
.TP
.B A good way
to transport data between instances of xgraph. Combined with insertion of datasets other than at
the end (this should not even be *that* difficult to manage ;-)). Currently, the "smoothest" way to transport
data is by dumping (selected sets) in XGraph format from the source instance to a named pipe (fifo) (with \fBXG_Complete\fP
de-selected), and reading (through the Settings Dialog's "RF" command) from the same pipe in the destination
instance. This might be streamlined somewhat by automating the writing and reading and passing the name of the pipe
through the X clipboard.
.TP
.B Animation
can be achieved by requesting redraw, or an action that generates a redraw (like CycleSet[]), e.g. as part of a
\fB*DRAW_AFTER*\fP command. While a window is being animated, it is redrawn only in the toplevel event handling
loop (normally, redraws are handled as quickly as possible, causing currently ongoing redraws to be aborted afterwards).
Thus, reaction to events may be slightly different. Also, the animation loop is interrupted by queued events, and
(unfortunately) not allways smoothly restarted after these have been handled. Bear in mind that many settings (e.g.
the aspect-ratio ([1:1] button)) are deactivated during auto-scale redraws, to be restored afterwards. Thus, changing
such a setting during the animation (or during any redraw, in fact), may very well have no lasting effect. XGraph is
not an animation programme, but I have gone to some lengths to avoid potentially costly operations while a window is
animated. Thus, among others, there are no automatic progress feedback messages via the titlebar; but a brethren window
that is not being animated will not be effected. Animation speed varies as a function of the host machine, the X server
and the connection (local or remote), and the contents being shown. Drawing the axes can be expensive (a potentially
recurrent action), filled simple shapes often quicker than outlined complex shapes, smaller faster than larger, etc.
If processing is performed, the gap between window-wipe (1st thing after auto-rescale, before drawing the axes, labels,
titles and finally the data (and legend)) can become noticeable, and actually longer in duration than the period the
data is displayed. In that case, try to switch on auto-scaling. In that mode, the processing is performed \fIbefore\fP
the wipe, allowing the server to finish drawing and/or the eyes to take in the information. After the rescale, the
data to be displayed has already been transformed, and is thus quickly & immediately drawn, thereby reducing the
blank gap. This does not cause a significant speed penalty because most of the actions necessary for the auto-scale
are performed whether this mode is activated or not. To prevent a continously varying scale, add a few points (2 diagonally
placed suffice) in a raw-displayed set that will "lock" the scaling, and put the changing sets in floating mode (the
[flt] button). This will have the additional advantage that somewhat less statistics are gathered for these sets. Some
time can also be gained by putting as much code as possible into a \fB*DATA_INIT*\fP command (or *DATA_FINISH*) since
these are evaluated only once per set per redraw, instead of per point (as *DATA_BEFORE*). But this may entail the need
of a loop over all points, and going faster than the X server can is not wise neither. (Compare MorBurr99.xg and MorBurr99b.xg
for this.)
.TP
.B x86 FPUs
Note regarding floating point on Intel Pentium processors (and clones?), compiled with gcc.
Floating point is a bit precarious on these processors, especially if one is concerned about portability and such. One
reason is the fact that alignment is very important (and not always handled correctly by the compiler or the ABI!). Another
is the fact that internally, the FPUs work at a higher precision than other FPUs (80bits vs. 64bits conform the IEEE standard).
Therefore, an additional module can be linked in, x86_gcc_fpe.o, that will control the FPU's behaviour. By default, it
will silently put the FPU in double [64 bits] precision at programme startup (using a gcc constructor mechanism).
When the DEFAULT_FPU env. variable is set, it will leave the FPU's state as it is
(probably meaning in extended [80 bits] precision). When the SHOW_FPU env. var is set, the routine prints the old (and new)
state as a hexadecimal number. When SHOW_FPU=verbose, the hexadecimal masks are "parsed" in addition.
See \fIfpu_control.h, g77.info-15, g77.info-16 (__setfpucw)\fP for more information.
Alternatively, one can compile with the \fI-ffloat-store\fP flag. This causes a performance hit, and also different results
(in the last 4-6 decimals).


.PP

.SH THE x-plot COMMAND
.TP
.B x-plot
<xcol>,<ycol>[,<dycol>] [x-plot options] [xgraph options] -f|-F <filename(s)>
.PP
The
.B x-plot
command is a script that allows plotting from datafiles with more than 3 columns.
It calls
.B plot-cut -f <xcol>,<ycol>[,<dycol>] <filename(s)>
to extract the specified columns from the specified files. After extraction (into
an intermediate file with an appropriate filename),
.B x-plot
shows the labels (if any) of the columns it will plot,
and asks the user if he/she wants to plot the indicated files. Enter
.B y
or
.B Y
or <return> to accept;
.B n
or
.B N
to cancel. Entering
.B q
or
.B Q
will abort the current plotting command, and sends a
.I HUP
signal to a (calling) process (batch-script) indicated by the
.B PARENT
env. variable.
.B x-plot
recognises the following options:
.TP
.B -do|-dont
Do or do not draw this graph (i.e. don't ask).
.TP
.B -ntile|-tile <x> <y>
Tile <x> by <y> windows on the screen; the -ntile format causes the first
window to be placed top-left.
.TP
.B -title_file
Causes the filename to be the graph's title.
.TP
.B -xdb
Turn on the shell's (sh) 
.B -x
option.
.TP
.B -f
Specify filename(s) to be plotted.
.TP
.B -F
Idem; each file is plotted in a new window (process).
.TP
.B -nostrip-labels
Normally, x-plot and X-plot strip the
.B *XYLABEL*
and
.B *YXLABEL*
commands from all but the first file specified that has (one of!) them. Thus,
when similar data from several files are drawn, only one set of labels results
(in the case of X-plot, one set for each Y-column combination). With the
.B -nostrip-labels
option, this feature is turned off, and all labels are shown (possibly concatenated).
.PP

The
.B plot-cut
script recognises various compression formats (if RJB's
.B less
variety is available), and pipes the uncompressed data through
\fI$CPP\fP (e.g. set CPP to /lib/cpp to do C-style preprocessing)
before piping it through
.I cut.
The specified cut-selection is passed to xgraph using the
.B *Cxye*
command.
The xgraph distribution contains a
.B cut
version that will handle arbitrarily long lines. Note that the \fBplot-cut\fP utility strips \fB*COLUMNS*\fP specifications, so
a customary \fB-Columns\fP argument has to be passed!
\fIExecute \fBplot-cut\fP without further arguments for more explanation.\fP
.PP

.SH THE X-plot COMMAND
.TP
.B X-plot
	[X-plot options] [xgraph options] -file|-File <filename(s)> -xcol <xcol> -ycol <ycol>[,<dycol>] [<ycol>[,<dycol>]..]
.PP
The
.B X-plot
command is another script that allows plotting from datafiles with more than 3 columns.
This script allows one to combine multiple Y[,E] columns with 1 X column, e.g. to plot multiple
sets from a spreadsheet file. It is not possible to select multiple columns of X-values. The calling
syntax is slightly different from that of
.B x-plot.
.B X-plot
recognises the same options, with the following differences:
.TP
.B -file
Specify filename(s) to be plotted.
.TP
.B -File
Idem; each file is plotted in a new window (process).
.TP
.B -xcol <xcol>
Specify which column has the X-values.
.TP
.B -ycol <ycol>[,<dycol>] [<ycol>[,<dycol>] ..]
Specify which columns contain Y-values (and E-values). For each duplet
.B <ycol>[,<dycol>]
.B X-plot
calls
.B plot-cut -f <xcol>,<ycol>[,<dycol>] <datafile(s)>
the result of which is appended to an intermediate file with an appropriate name.
.PP

.SH THE XGraph COMMAND
.TP
.B XGraph
[-unique|-pid] \-|<filename(s)>
.PP
.B XGraph.sh
[-unique|-pid] \-|<filename(s)>
.PP
The \fBXGraph\fP command is the advocated way to start xgraph: it should be a (soft) link to the \fBxgraph\fP executable
(which must exist!). It is thus used in the header-line of XGraph
dumps in the form \fB#!/usr/local/bin/XGraph\fP (with the \fB-unique\fP option). It provides 3 essential services, through
the intermediate action of the \fBXGraph.sh\fP shell script (which can of course also be invoked directly).
First, it allows such dumps to be executed also on systems where only allowed shells may be started,
or other limits apply. This is maybe a somewhat obsolete phenomenon, but one that seems to be necessary on all
systems that I currently implemented xgraph on (A/UX, HPUX, IRIX, linux).
Second, it allows certain commandline options that \fIhave\fP to be given at startup (= on the commandline) to
be passed through XGraph dumps. Currently, the only such options implemented are \fB-MinBitsPPixel\fP 
and \fB-VisualType\fP which
affect X11 visual selection. Thus, a dump can make (reasonably) sure that at its next invocation it
will have at least the same (number of) colours available. This is implemented rather bluntly: the \fBfilename(s)\fP specified
is/are scanned for occurences of the particular options, and these are passed to xgraph when it is
invoked. This is handled also for input from stdin (pipes etc): for this to work, a \fB-\fP must be given
as the very first argument (this is done by [XGraph] [Preview] in the hardcopy dialog).
Third, and lastly, there are options to XGraph itself:

.TP
.B -unique
specifies that all actions should be
on a per file basis. This means that the command

XGraph -unique options f1 f2 f3

is the same as

XGraph options f1 & ; XGraph options f2 & ; XGraph option f3

Note that the last command is not executed in the background!
This option is passed by default in dumps generated by XGraph itself; thus, the above command can also
be given as

f1 f2 f3

Assuming that at least f1 has execute permission and has been generated by xgraph itself (or contains the proper 1st line).
It multiple instances are executed in this fashion, the script waits for the last command to finish before returning. 
During this wait, killing it has the effect of killing all childs! If only one instance (file..) is executed, it overlays
the script using exec.
.TP
.B -pid
Requests that XGraph inform its caller about the process ID of the underlying xgraph. This is necessary if
the XGraph calling process wants to restart the graphing application when new data becomes available. When
this option is specified, XGraph prints a string "xgraph process id is xxxx" onto the standard output, and
exits with the process number (which does not work on all systems!). Of course, when the \fB-detach\fP option
is specified, the calling process need not include the \fB-pid\fP option as it will not return the correct
ID. Instead, the output should be scanned for "xgraph.child xxxx:". Also note that this option has no effect
in conjunction with \fB-unique\fP.
.TP

The \fBXGraph\fP link (or copy) and the \fBXGraph.sh\fP script \fImust\fP be installed in the same directory as xgraph itself.
.PP

.SH AUTHORS
.TP
.B original code
David Harrison, University of California
.TP

.B all the rest, plus all the rewrites :)
RenE J.V. Bertin (RJ[V]B), Utrecht University, College de France/CNRS, ...
[rjvbertin@hotmail.com]
.TP
.PP

.SH ACKNOWLEDGEMENTS
.TP
.B David Harrison
for writing the original code and releasing it in the public domain...
.TP
.B Bruce Perens @ Pixar
for his nifty Electric Fence package for tracing memory allocation bugs, out-of-bounds errors and the like...
.TP
.B Gerard Corbiau and the publisher G.C.T.H.V. for making the movie Farinelli and its DVD which shows what looks like the original
version being used somewhere in 1992 during the reconstruction of the castrato voice at the IRCAM in Paris....
.PP
